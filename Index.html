<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Etsy Listing Generator & Shop Listings</title>
  <!-- Favicon -->
  <link rel="icon" type="image/png" href="assets/favicon.png">
  <!-- Import Google Material Icons and Materialize CSS -->
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css">
  <!-- Include piexifjs for EXIF manipulation -->
  <script src="https://cdn.jsdelivr.net/npm/piexifjs@1.0.4/piexif.min.js"></script>
  <!-- Include SortableJS -->
  <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.14.0/Sortable.min.js"></script>
  <!-- Include CropperJS -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.js"></script>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100vw;
      font-family: Arial, sans-serif;
      position: relative; /* anchor absolute children to the page */
    }
    .container {
      width: 100vw;
      padding: 10px;
      box-sizing: border-box;
      text-align: left;
    }
    h5, label, p {
      text-align: left;
    }
    input, textarea {
      width: 100%;
      box-sizing: border-box;
    }
    #descriptionAndFileUploadContainer {
      display: flex;
      align-items: center;
    }
    .listing-desc-container {
      position: relative;
      display: inline-block;
      width: 500px;
    }
    .listing-desc-container h5 {
      margin: 0 0 10px 0;
      font-size: 1.2rem;
      font-weight: 500;
    }
    .listing-desc-container label.section-heading {
      font-size: 1.2rem;
      font-weight: 500;
    }
    .listing-desc-container input {
      width: 500px;
      height: 30px;
      border: 1px solid #000;
      padding: 5px;
    }
    #searchKeyPhrases {
      resize: none;
      box-sizing: border-box;
      border: 1px solid grey;
      font-size: 0.82rem; /* 20% smaller than the 1rem textarea default */
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      overflow-x: auto;
    }
    #searchKeyPhrases[rows="14"] {
      height: auto;
    }

    /* === SKP inline highlight overlay === */
    #searchKeyPhrases {
      background-color: transparent;  /* let the blue highlight show through */
      caret-color: #000;
    }

    /* Positioned to exactly mirror the textarea; text transparent so only blue blocks show */
    #skpOverlay {
      position: absolute !important;
      white-space: pre;
      font-family: inherit;
      font-size: inherit;
      line-height: inherit;
      pointer-events: none;
      z-index: 2999;           /* textarea sits at 3000 in your abs layout */
      color: transparent;      /* hide overlay text; we only want backgrounds */
      margin: 0;
    }

    #skpOverlay .mark {
      background: rgba(255, 165, 0, 0.35);
      border-radius: 2px;
    }

    /* Match fonts to #searchKeyPhrases */
    #listingTitle,
    #listingDescription,
    #listingDescInput {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 0.82rem;
    }

    .flex-container {
      display: flex;
      gap: 10px;
      align-items: stretch;
    }
    .textbox-container {
      flex: 1;
    }
    .textbox-container textarea {
      width: 100%;
      padding: 0.8rem;
      font-size: 1rem;
      line-height: 1.2;
      resize: none;
      overflow: auto; /* was visible — content could be clipped with fixed height */
      box-sizing: border-box;
    }

    /* Config mode: show outlines and smooth movement */
    body.config-mode .configurable {
      outline: 2px dashed rgba(0,0,0,.45);
      transition: left .08s linear, top .08s linear, width .08s linear, height .08s linear;
    }
    .modal-overlay { transition: opacity .2s ease; }

    /* Config mode: lighten the sheet and let clicks pass through so previews are visible */
    body.config-mode .modal-overlay {
      opacity: 0.08 !important;
      pointer-events: none !important;
    }

    /* Ensure buttery movement while editing */
    body.config-mode .layout-abs,
    body.config-mode .configurable {
      will-change: left, top, width, height;
    }

    .button-container {
      width: 200px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      align-self: flex-start;
    }
    #listingTitle {
      min-height: 45px;
    }
    #listingDescInput {
      width: 500px;
      height: 30px;
      border: 1px solid #000;
      padding: 5px;
    }
    #listingDescription {
      min-height: 150px;
      width: 500px;
    }
    .section-heading {
      font-size: 1.2rem;
      font-weight: 500;
      margin-bottom: 5px;
      display: inline-block;
    }
    /* NEW: inline title/section spinner */
    .inline-spinner{
      display: none;        /* toggled by JS */
      vertical-align: middle;
      margin-left: 8px;     /* sits to the right of the heading */
    }
    .count-text {
      font-style: italic;
      font-size: 0.9em;
      margin-top: 5px;
    }
    #dropZone {
      width: 712px;
      height: 120px;
      border: 2px dashed #ccc;
      border-radius: 3px;
      display: inline-block;
      vertical-align: middle;
      text-align: center;
      line-height: 120px;
      position: relative;
    }
    /* Hide any unused drop zones */
    #fileDropZonesContainer {
      display: none;
    }
    .modal {
      z-index: 9999 !important;
    }
    .modal-overlay {
      z-index: 9998 !important;
    }
    #previewGridContainer {
      position: relative;
      margin: 20px auto;
      width: auto;
      max-width: 720px;
      text-align: center;
      z-index: 2000;
    }
    #previewGridStatic {
      display: grid;
      grid-template-columns: repeat(5, 120px);
      grid-column-gap: 28px;
      grid-row-gap: 22px;
      margin: 0 auto;
    }
    .preview-cell {
      position: relative;
      width: 120px;
      height: 158px;
      border: 2px solid #ccc;
      border-radius: 3px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      color: #666;
    }
    .preview-cell.reserved {
      z-index: 2500;
    }
    .preview-box {
      position: relative;
      width: 100%;
      height: 100%;
    }
    .preview-box img {
      width: 120px;
      height: 120px;
      object-fit: cover;
      border-radius: 3px;
      display: block;
    }
    .remove-btn {
      position: absolute;
      top: -5px;
      left: -5px;
      width: 15px;
      height: 15px;
      background-color: black;
      color: white;
      font-size: 10px;
      text-align: center;
      cursor: pointer;
      z-index: 999;
      border-radius: 50%;
    }
    .number-overlay {
      position: absolute;
      top: 0;
      right: 0;
      width: 16px;
      height: 16px;
      background-color: rgba(0,0,0,0.7);
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      z-index: 999;
      border-radius: 3px;
    }
    .metadata-status {
      margin-top: 5px;
      text-align: center;
      font-size: 14px;
      min-height: 20px;
    }
    .metadata-progress {
      width: 90%;
    }
    /* Let JS absolute positioning take over; remove relative/negative offsets */
    #container13 {
      position: static;
      width: 250px;
      top: auto;
    }
    #belowSearch {
      margin-top: 0;
      margin-left: 0;
    }
    .title-container {
      margin-top: 0;
    }
    #etsyListingTitleContainer {
      position: static;
      width: 1000px;
    }
    #etsyListingTitleContainer textarea {
      width: 1000px;
    }
    .description-container {
      margin-top: 0px;
    }
    #etsyListingDescriptionContainer {
      position: static;
      width: 1000px;
    }
    #etsyListingDescriptionContainer textarea {
      width: 1000px;
    }
    #userProvidedKeyPhrasesContainer {
      position: static;
      top: auto;
      left: auto;
    }
    #topButtons {
      margin: 10px 0;
    }
    #listingQueueCount {
      width: 25px;
      height: 25px;
      border: 1px solid #000;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      margin-left: 5px;
    }
    .regen-btn, .copy-btn {
      width: 125px;
    }
    .update-btn {
      background-color: #FFA500 !important;
      color: white !important;
    }
    .drag-over {
      border: 2px dashed #2196f3 !important;
    }
    /* Floating button style */
    #floatingViewFileBtn {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10000;
    }
    /* Added to enable repositioning via the Configure Buttons modal */
    #etsyShopListingsContainer {
      position: relative;
    }

    /* Force the new absolute layout system to win over legacy/author CSS */
    .layout-abs { position: absolute !important; }

    /* Absolute layout stage: all configurable components live here */
    #layoutRoot {
      position: relative;
      width: 100vw;
      min-height: 200vh;
      z-index: 2500;
    }

    /* keep the neutralize rule, but without .listing-desc-container */
    .neutralize-wrapper,
    #descriptionAndFileUploadContainer,
    #topButtons,
    #belowSearch,
    #etsyShopListingsContainer,
    #previewGridContainer,
    #previewGridStatic,
    .flex-container,
    .title-container,
    .description-container {
      position: static !important;
      display: contents !important;
    }

    /* make the movable container a real box again */
    #listingDescContainer { display: block !important; }

    /* Analyze Metadata blue progress bar (absolute-positioned + movable) */
    #analyzeMetadataProgress {
      position: absolute;
      height: 22px;
      width: 260px;               /* default; layout system will override */
      border-radius: 6px;
      overflow: hidden;
      background: #e3f2fd;        /* light blue track */
      border: 1px solid #2196f3;  /* blue border */
      box-shadow: 0 1px 2px rgba(0,0,0,.08);
    }
    #analyzeMetadataProgress .bar {
      height: 100%;
      width: 0%;
      background: #2196f3;        /* blue fill */
      transition: width .25s ease;
    }
    #analyzeMetadataProgress .pct {
      position: absolute; inset: 0;
      display: flex; align-items: center; justify-content: center;
      font-weight: 700; font-size: 12px;
      color: #fff;                 /* readable on blue */
      text-shadow: 0 0 2px #000, 0 0 4px #000; /* readable on white */
      letter-spacing: .2px;
      pointer-events: none;
    }

    /* Create Listing blue progress bar (same visuals, hidden initially) */
    #createListingProgress {
      position: absolute;
      height: 22px;
      width: 260px;               /* layout system can override */
      border-radius: 6px;
      overflow: hidden;
      background: #e3f2fd;        /* light blue track */
      border: 1px solid #2196f3;  /* blue border */
      box-shadow: 0 1px 2px rgba(0,0,0,.08);
      display: none;              /* shown on click */
    }
    #createListingProgress .bar { height: 100%; width: 0%; background: #2196f3; transition: width .25s ease; }
    #createListingProgress .pct { position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; font-weight: 700; font-size: 12px; color: #fff; text-shadow: 0 0 2px #000, 0 0 4px #000; letter-spacing: .2px; pointer-events: none; }

    /* NEW: Duplicate-Listing holistic progress (same look) */
    #duplicateListingProgress {
      position: absolute; width: 260px; height: 22px;
      background: rgba(0,0,0,.08); display: none;
    }
    #duplicateListingProgress .bar {
      height: 100%; width: 0%; background: #2196f3; transition: width .25s ease;
    }
    #duplicateListingProgress .pct {
      position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; font-weight: 700; font-size: 12px; color: #fff; text-shadow: 0 0 2px #000, 0 0 4px #000; letter-spacing: .2px; pointer-events: none;
    }

  </style>
</head>
<body>
  <!-- Absolute layout stage (every component will be reparented here) -->
  <div id="layoutRoot"></div>
  <!-- Legacy uiPositions removed: new layout system is source of truth -->

  <button id="openConfigBtn" class="btn waves-effect waves-light configurable" style="margin-left:10px;">Open Config</button>
  
  <div id="descriptionAndFileUploadContainer">
    <div class="listing-desc-container" id="listingDescContainer">
      <h5>Listing Description</h5>
      <input id="listingDescInput" type="text" placeholder="Enter your question here">
    </div>
  </div>
  
  <div id="topButtons">
    <button id="connectEtsyBtn" class="btn waves-effect waves-light configurable">Connect to Etsy</button>
    <button id="createListingBtn" class="btn waves-effect waves-light configurable update-btn" style="margin-left: 10px;">Create Listing</button>
    <!-- Unified blue progress bar (hidden until clicked) -->
    <div id="createListingProgress" class="configurable" style="display:none;">
      <div class="bar"></div>
      <div class="pct">0%</div>
    </div>

     <!-- NEW: Duplicate Listing trigger (to the right of Create Listing) -->
     <button id="duplicateListingBtn" class="btn waves-effect waves-light configurable" style="margin-left: 10px;">
       Duplicate Listing
     </button>
     <!-- NEW: Holistic Duplicate Listing progress (hidden until clicked) -->
     <div id="duplicateListingProgress" class="configurable" style="display:none;">
       <div class="bar"></div>
       <div class="pct">0%</div>
     </div>

    <div id="etsyShopListingsContainer">
      <div id="etsyShopListingsHeading" class="section-heading configurable">
        Etsy Shop Listings
        <span id="listingQueueCount">0</span>
      </div>
      <div class="textbox-container configurable">
        <textarea id="shopListings" class="materialize-textarea" rows="2" placeholder="Enter up to 250 comma-separated 10-digit listing IDs" style="width:500px;"></textarea>
      </div>
    </div>
  </div>
  
  <div class="phrases-header configurable" id="userProvidedKeyPhrasesContainer">
    <span id="searchKeyPhrasesHeading" class="section-heading configurable">
      Search Key Phrases
      <span id="searchSpinner" class="inline-spinner preloader-wrapper small">
        <div class="spinner-layer spinner-blue-only">
          <div class="circle-clipper left"><div class="circle"></div></div>
          <div class="gap-patch"><div class="circle"></div></div>
          <div class="circle-clipper right"><div class="circle"></div></div>
        </div>
      </span>
    </span>
   
    <div id="dropZone" class="configurable">Image Drop</div>
    <button id="analyzeMetadataBtn" class="btn waves-effect waves-light configurable">Analyze Photos</button>
    <!-- Blue progress bar for Analyze Photos -->
    <div id="analyzeMetadataProgress" class="configurable">
      <div class="bar"></div>
      <div class="pct">0%</div>
    </div>
  </div>

  <div id="container13" class="flex-container configurable">
    <div class="textbox-container configurable">
      <textarea id="searchKeyPhrases" class="materialize-textarea" rows="14" wrap="off"></textarea>
      <pre id="skpOverlay" aria-hidden="true"></pre>
    </div>
  </div>
  
  <div id="belowSearch">
    <button id="generateBtn" class="btn waves-effect waves-light configurable">Generate</button>
    <div class="title-container" id="etsyListingTitleContainer" style="margin-top: 0;">
     <div id="listingTitleHeading" class="section-heading configurable">
        Etsy Listing TITLE
        <span id="titleSpinner" class="inline-spinner preloader-wrapper small">
          <div class="spinner-layer spinner-blue-only">
            <div class="circle-clipper left"><div class="circle"></div></div>
            <div class="gap-patch"><div class="circle"></div></div>
            <div class="circle-clipper right"><div class="circle"></div></div>
          </div>
        </span>
      </div>
      <div class="flex-container configurable">
        <div class="textbox-container configurable">
          <textarea id="listingTitle" class="materialize-textarea" rows="2"></textarea>
        </div>
        <div class="button-container configurable">
          <button id="regenTitleBtn" class="btn-small waves-effect waves-light configurable regen-btn">Re-Gen</button>
          <button id="copyTitleBtn" class="btn-small waves-effect waves-light configurable copy-btn">
            <i class="material-icons">content_copy</i>
          </button>
        </div>
        <button id="showTitleRulesBtn" class="btn waves-effect waves-light rules-button configurable" data-target="titleRulesModal" style="display:none;">Title Rules</button>
      </div>
      <p id="titleCount" class="count-text configurable">Count: 0</p>
    </div>
    
    <div class="description-container" id="etsyListingDescriptionContainer" style="margin-top: 0px;">
      <div id="listingDescriptionHeading" class="section-heading configurable">
        Etsy Listing DESCRIPTION
        <span id="descriptionSpinner" class="inline-spinner preloader-wrapper small">
          <div class="spinner-layer spinner-blue-only">
            <div class="circle-clipper left"><div class="circle"></div></div>
            <div class="gap-patch"><div class="circle"></div></div>
            <div class="circle-clipper right"><div class="circle"></div></div>
          </div>
        </span>
      </div>
      <div class="flex-container configurable">
        <div class="textbox-container configurable">
          <textarea id="listingDescription" class="materialize-textarea"></textarea>
        </div>
        <div class="button-container configurable">
          <button id="regenDescriptionBtn" class="btn-small waves-effect waves-light configurable regen-btn">Re-Gen</button>
          <button id="copyDescriptionBtn" class="btn-small waves-effect waves-light configurable copy-btn">
            <i class="material-icons">content_copy</i>
          </button>
        </div>
        <button id="showDescriptionRulesBtn" class="btn waves-effect waves-light rules-button configurable" data-target="descriptionRulesModal" style="display:none;">Description Rules</button>
      </div>
    </div>
  </div>
  
  <div id="previewGridContainer">
    <div id="previewGridStatic">
      <div class="preview-cell" id="previewCell0">Empty</div>
      <div class="preview-cell" id="previewCell1">Empty</div>
      <div class="preview-cell" id="previewCell2">Empty</div>
      <div class="preview-cell" id="previewCell3">Empty</div>
      <div class="preview-cell" id="previewCell4">Empty</div>
      <div class="preview-cell" id="previewCell5">Empty</div>
      <div class="preview-cell" id="previewCell6">Empty</div>
      <div class="preview-cell reserved" id="previewCell7">Empty</div>
      <div class="preview-cell reserved" id="previewCell8">Empty</div>
      <div class="preview-cell reserved" id="previewCell9">Empty</div>
    </div>
  </div>
  
  <!-- Metadata Modal -->
  <div id="metadataModal" class="modal">
    <div class="modal-content">
      <h4>Photo Metadata</h4>
      <textarea id="metadataTextarea" readonly style="width:100%; height:300px;"></textarea>
    </div>
    <div class="modal-footer">
      <a href="#!" id="closeMetadataBtn" class="modal-close waves-effect waves-green btn">Close</a>
    </div>
  </div>
  
  <!-- Analyze Rules Modal -->
  <div id="analyzeRulesModal" class="modal">
    <div class="modal-content">
      <h4>Photo Analysis Rules</h4>
      <textarea id="analyzeRulesTextarea" style="width:100%; height:300px;">
Default Photo Analysis Rules:
1. Use SEO-friendly descriptive long-tail key phrases without special characters, focus on describing the jewelry and charm pendant, also focus and tailor Key Phrases and description to appropriate client based on the type of jewelry.
2. Emphasize charm details, focus image description on the type of jewelry and pendant description (what it is, occasion, metal, size, style).
3. Never estimate or post any sizes or dimensions in the metadata 
3. Focus solely on the jewelry details especially the charm description.
4. Ignore environment, model, and clothing.
5. Organize into a short paragraph.
6. Limit the description to 200 characters.
7. Do not mention earrings unless explicitly identified.
8. Do not mix necklace and earring descriptions.
9. - Ban low-value synonyms: never use {token, keepsake, dainty, whimsical, delicate, unique, inspired, design, lightweight, idea, accessory, accessories}.
10. - Ban the following: "Gift for Him", "Statement Piece", "Unique", "Spiritual Gift", "Outdoor Style", "accessories", "simple", "minimalist", "whimsical", "cute", "filled", "gold filled", "silver", "Vibes", "solid gold", "gold vermeil", "rosegold", "14k", "handmade", "quirky", "delicate", "accessory", "for", "dangle", "gold plated", "jewelry", "custom", "celestial", "design", "lightweight", "Fine Chain Necklace", "Small", "Large", "Nice", "Long", "Dark", "Short", "and", "but", "light", "heavy", "Wanderlust", "Theme", "Minimal Chain Gift", "Tiny Pendant Chain", "Charm Look", "Charm Wear", "Chain Necklace", "Small Pendant Chain", "Everyday", "etched", "detail", "smooth", "polished".
11. - Semantic near-dup drop: if two tags differ only by a leading adjective (e.g., “tiny bird charm” vs “bird charm”) or only by material (e.g., “gold bird pendant” vs “rosegold bird pendant”), keep the single highest-volume variant and discard the rest.
12. Be more to the point with  much less filler words and more jewelry and best fit client focused descriptions
13. ANTI-REPETITION (TITLE)
  - No repeated bigrams: compute all 2-word sequences; each must be unique across the title.
  - Do not repeat the same head-noun pair (e.g., “bird pendant”) more than once.
  - Use at most one subject root twice: if “hummingbird” appears, use “bird” at most once elsewhere.
  - Material frequency: words {gold, rosegold, silver, 14k} → max 2 total occurrences across the whole title.
  - “gift for …” phrase appears at most once in the title; avoid stacking variants (“gift for her”, “gift for mom”) in the same title.
  - Ban filler adjectives in titles as well: {dainty, whimsical, delicate, unique, keepsake, inspired, design, lightweight}.
14. Less narrative and story building with more focus on facts and details about the jewelry and charm to appeal to potential clients.        
      Descriptions of good fit between client needs and our offerings:  
      Example a. Soccer mom would have an appeal for a soccer ball necklace, or a team jersey.         
      Example b. A nurse would have an appeal for a stethoscope earrings, or syringe.        
      Example c. A bride with an upcoming wedding would also interested in birth flowers charm necklaces for her brides maids group present.  
      Example d. A university grad or sorority group would be interested in a pair of graduation cap earrings or necklace sets. 

      </textarea>
    </div>
    <div class="modal-footer">
      <a href="#!" id="updateAnalyzeRulesBtn" class="modal-close waves-effect waves-green btn">Update</a>
    </div>
  </div>
  
  <!-- Title Rules Modal -->
  <div id="titleRulesModal" class="modal">
    <div class="modal-content">
      <h4>Title Rules</h4>
      <textarea id="titleRulesTextarea" style="width:100%; height:300px;">
TITLE RULES (STRICT — MATCH THE EXAMPLES EXACTLY)

CORE STRUCTURE (exact order)
1) Lead = [Action/Style ]{Motif} {Product-Type}
2) Divider = one colon ":" (exactly one in the whole title)
3) Materials = 2–4 items (comma-separated; may include "Handmade" once; optional "or" before the last)
4) Tail = compact category/occasion phrase
5) Never repeat any of these words more than once: Necklace, Charm, Disc, Stud, Earrings, Hoop, Pendant

ALLOWED PRODUCT-TYPES (expanded)
- Pendant Necklace
- Charm Necklace
- Disc Necklace Charm
- Necklace Charm
- Necklace
- Bar Necklace
- Tag Necklace
- Hoop Earrings
- Huggie Hoop Earrings
- Drop Earrings
- Stud Earrings
- Earrings
- Charm

ALLOWED MATERIAL TOKENS (Materials segment only)
- Handmade
- Sterling Silver
- Gold Filled
- Rose Gold
- 14K Solid Gold  (accept "14k" or "14K")

ACTION/STYLE TOKENS (optional, place BEFORE the Motif; Title Case)
- Running, Flying, Leaping, Soaring, Howling, Dancing, Blooming
- Customizable, Personalized, Engraved, Initial, Zodiac, Birth Flower
- Layered, Stackable, Adjustable

TAIL — THEME TOKENS (mix 1–2 with at least one of {Jewelry | Pendant | Charm | Studs})
- Animal, Bird, Floral, Nature, Ocean, Coastal, Nautical, Western, Sports, Zodiac, Astrology, Geometric
Optional: add "Gift" and at most one of {"for her","for mom"}.

WORD PLACEMENT (strict)
- Subject/Motif (with optional Action/Style) first, then Product-Type, then colon, then Materials list, then Tail.
- "Earrings" must be plural; if "Stud" appears it must read "Stud Earrings".
- "Charm" may appear in the lead OR tail; total uses of "Charm" ≤ 2.

PUNCTUATION & CASING
- Exactly one colon.
- Commas with a single space after each comma.
- Title Case for content words.
- No hyphens, slashes, quotes, or emojis.

LENGTH
- 80–120 characters (target 90–110).

REFERENCE EXAMPLES (follow structure/flow)
a. USA Country Flag Pendant Necklace: 14k Solid Gold, Gold Filled, Silver, Dainty Custom Patriotic Jewelry
b. Flying Hawk Wildlife Hoop Earrings: Custom Handmade Sterling Silver, 14k Solid Gold Minimalist Bird Charm, Jewelry lover
c. Pine Tree Lover Charm Necklace: Sterling Silver, Gold Filled, 14K Solid Gold Custom Dainty Nature Pine Needle Pendant
d. Comedy Tragedy Mask Pendant Necklace: Custom, 14K Solid Gold, Sterling Silver, Gold Filled Tiny Theater, Acting Charm Jewelry
e. Running Wolf Pendant Necklace: Handmade 14K Solid Gold, Sterling Silver, Gold Filled Minimalist Animal lover Wildlife Gift for mom
f. Customizable Initial Charm Necklace: Sterling Silver, Gold Filled, 14K Solid Gold Dainty Letter Pendant Gift
g. Dolphin Huggie Hoop Marine Earrings: Gold Filled, 14K Solid Gold, Sterling Silver Custom Ocean, Beach lover Jewelry

VALIDATION CHECKLIST (all must pass)
[ ] One colon present; non-empty text on both sides.
[ ] Lead ends with an allowed Product-Type synonym or similar.
[ ] Earrings rules satisfied; "Charm" ≤ 2.
[ ] No hyphens/slashes/quotes/emojis; single space after commas.
[ ] 80–120 characters inclusive.

SEO Guidance
Compose the title as a chain of distinct, non-repeating search phrases that still read naturally. Favor concrete nouns (motif, product, material, theme) over filler adjectives.

      </textarea>
    </div>
    <div class="modal-footer">
      <a href="#!" id="updateTitleRulesBtn" class="modal-close waves-effect waves-green btn">Update</a>
    </div>
  </div>
  
  <!-- Description Rules Modal -->
  <div id="descriptionRulesModal" class="modal">
    <div class="modal-content">
      <h4>Description Rules</h4>
      <textarea id="descriptionRulesTextarea" style="width:100%; height:300px;">
Rules for Description:
- Merge the key phrases with your output.
- Modify the description to match the jewelry type.
- Keep the output paragraph to 80 words.

Option 1:
"This stunning gold Playing Card Charm is the perfect gift for her, featuring an intricately designed Ace of Spades charm. Ideal for jewelry lovers, this pendant is perfect for personalized pieces."

Option 2:
"This playful Allosaurus charm is the perfect add-on for charm necklaces or huggie hoops. It adds a whimsical touch to any collection, making it a delightful gift."

Option 3:
"This charming gold Alligator Necklace is a delightful gift for animal lovers. Featuring a beautifully designed crocodile pendant, it adds a unique touch to any collection."
      </textarea>
    </div>
    <div class="modal-footer">
      <a href="#!" id="updateDescriptionRulesBtn" class="modal-close waves-effect waves-green btn">Update</a>
    </div>
  </div>
  
  <!-- Keyword Rules Modal -->
  <div id="keywordRulesModal" class="modal">
    <div class="modal-content">
      <h4>Keyword Rules</h4>
      <textarea id="keywordRulesTextarea" style="width:100%; height:300px;">
REPETITION & DEDUP (TAGS)
- Canonicalize before checking duplicates: lowercase, trim, collapse spaces, singularize simple plurals (charms→charm, earrings→earring), strip leading adjectives {tiny, small, little}.
- Exact tag uniqueness: no two identical canonical tags.
- Never repeat the same word noun or adjective more than 2 times across all 13 Tag Phrases.
ANTI-REPETITION (TITLE)
- No repeated bigrams: compute all tag phrase sequences; each must be unique across the title.
- Do not repeat the same head-noun pair (e.g., “bird pendant”) more than once.
- Use at most one subject root twice: if “hummingbird” appears, use “bird” at most once elsewhere.
- Material frequency: words {gold, rosegold, silver, 14k} → max 2 total occurrences across the whole title.
- “gift for …” phrase appears at most once in the title; avoid stacking variants (“gift for her”, “gift for mom”) in the same title.
- Ban filler adjectives in titles as well: {dainty, whimsical, delicate, unique, keepsake, inspired, design, lightweight}.
- Head-noun bigram rule: extract the last two nouns of each tag (e.g., “bird pendant”, “bird charm”). Each head-noun bigram may appear AT MOST once across all 13 tags.
- Phrase families:
  • “gift for …” → MAX 1 tag total (e.g., “gift for her”, “gift for mom”). Prefer the most relevant variant and drop others.
  • Materials {gold, rosegold, silver, 14k} → appear in ≤ 2 tags combined.
- Noun cap: each of {charm, pendant, necklace, earring} may appear in ≤ 2 tags; the same pair (e.g., “bird pendant”) may appear in ≤ 1 tag.
- Ban low-value synonyms: never use {token, keepsake, dainty, whimsical, delicate, unique, inspired, design, lightweight, idea, accessory, accessories}.
- Ban the following: "Gift for Him", "Statement Piece", "Unique", "Spiritual Gift", "Outdoor Style", "accessories", "simple", "minimalist", "whimsical", "cute", "filled", "gold filled", "silver", "Vibes", "solid gold", "gold vermeil", "rosegold", "14k", "handmade", "quirky", "delicate", "accessory", "for", "dangle", "gold plated", "jewelry", "custom", "celestial", "design", "lightweight", "Fine Chain Necklace", "Small", "Large", "Nice", "Long", "Dark", "Short", "and", "but", "light", "heavy", "Wanderlust", "Theme", "Minimal Chain Gift", "Tiny Pendant Chain", "Charm Look", "Charm Wear", "Chain Necklace", "Small Pendant Chain", "Everyday"
- Semantic near-dup drop: if two tags differ only by a leading adjective (e.g., “tiny bird charm” vs “bird charm”) or only by material (e.g., “gold bird pendant” vs “rosegold bird pendant”), keep the single highest-volume variant and discard the rest.

      </textarea>
    </div>
    <div class="modal-footer">
      <a href="#!" id="updateKeywordRulesBtn" class="modal-close waves-effect waves-green btn">Update</a>
    </div>
  </div>
  
  <!-- Crop Modal -->
  <div id="photoCropModal" class="modal" style="width:650px; height:650px;">
    <div class="crop-container" style="position: relative; width:100%; height:100%;">
      <h4 style="text-align:center; margin:0 0 10px 0;">Crop Photo</h4>
      <div class="img-preview-container" style="width:400px; height:400px; margin:0 auto; overflow:hidden;">
        <img id="cropImage" src="" alt="Crop Image" style="display:block; margin:auto; max-width:none;">
      </div>
      <div style="text-align:center; margin-top:10px;">
        <button id="saveCropBtn" class="btn waves-effect waves-light" style="margin-right:10px;">Save</button>
        <button id="cancelCropBtn" class="btn waves-effect waves-light" style="background-color:#f44336;">Cancel</button>
      </div>
    </div>
  </div>

  <!-- Layout Config Modal (mirrors shipping-1 flow) -->
  <div id="configModal" class="modal">
    <div class="modal-content">
      <h5>Configure Component Positions</h5>
      <table class="striped" id="configTable">
        <thead>
          <tr>
            <th>Component</th><th>Left</th><th>Top</th><th>Width</th><th>Height</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
    <div class="modal-footer">
      <a id="resetLayoutBtn" class="waves-effect waves-red btn-flat">Reset</a>
      <a id="saveConfigBtn" class="modal-close waves-effect waves-green btn">Save</a>
    </div>
  </div>
  
  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js"></script>
  <!-- Fallback: inline metadataHandler to avoid 404 while keeping the same API -->
  <script>
    window.metadataHandler = window.metadataHandler || (function(){
      /**
       * analyzeAndEmbedMetadata(i)
       * Minimal implementation:
       * - Generates a short alt/metadata string from the Listing Description or filename
       * - Stores it in window.photoMeta[i] so your upload calls use it as alt_text
       * - Updates the little status text under each preview cell
       */
      async function analyzeAndEmbedMetadata(i){
        try {
          const imgData = (window.previewImages && window.previewImages[i]) || null;
          if (!imgData) {
            if (window.M && M.toast) M.toast({ html: "No image in slot " + (i+1) });
            return;
          }
          const desc = (document.getElementById("listingDescInput")?.value || "").trim();
          const name = (window.photoNames?.[i] || "").replace(/\.[a-z0-9]+$/i, "");
          // Build a concise, SEO-ish line (max ~200 chars)
          const base = (desc || name || "Jewelry photo").replace(/\s+/g, " ").trim();
          const tag  = base.slice(0, 200);
          // Persist for your upload paths (used as alt_text later)
          window.photoMeta[i] = tag;
          // UI status tick
          const s = document.getElementById("metadataStatus" + i);
          if (s) s.textContent = "✓ tagged";
        } catch (e) {
          console.error("metadataHandler.analyzeAndEmbedMetadata error:", e);
          if (window.M && M.toast) M.toast({ html: "Metadata error: " + e.message });
        }
      }
      return { analyzeAndEmbedMetadata };
    })();
  </script>

  <!-- Fallback: inline metadataHandler to avoid 404 while keeping the same API -->
  <script>
    window.metadataHandler = window.metadataHandler || (function(){
      async function analyzeAndEmbedMetadata(i) {
        const txt = (window.previewImages && window.previewImages[i]) ? "OK" : "no image";
        window.photoMeta = window.photoMeta || [];
        window.photoMeta[i] = "AUTO: " + txt;
        const ta = document.getElementById("metadataTextarea");
        if (ta) {
          ta.value = Array.from({ length: Math.min(7, window.previewImages.length) }, (_, idx) =>
            `${idx + 1}. ${window.photoMeta[idx] || ""}`.trim()
          ).join("\n").trim();
        }
      }
      return { analyzeAndEmbedMetadata };
    })();
  </script>

  <!-- ⬇️ Paste your REAL GPT-5 vision-backed handler RIGHT BELOW ⬇️ -->
  <script>
    // Real GPT-5 vision-backed metadata generator
    window.metadataHandler = (function () {
      async function analyzeAndEmbedMetadata(i) {
        try {
          const imgData = (window.previewImages && window.previewImages[i]) || null;
          if (!imgData) {
            if (window.M?.toast) M.toast({ html: "No image in slot " + (i + 1) });
            return;
          }

          const rules = document.getElementById("analyzeRulesTextarea")?.value?.trim() || "";
          const listingDesc = document.getElementById("listingDescInput")?.value?.trim() || "";
          const fileHint = (window.photoNames?.[i] || "").replace(/\.[a-z0-9]+$/i, "");

          const prompt = `
  You are generating Etsy listing photo metadata.
  Return ONE concise alt/metadata line (<= 200 chars), plain text only.
  Prefer concrete product details you can see: material, shape, color, finish, style.
  If rules conflict with what you see, trust the image.
  Listing context (optional):
  ${listingDesc ? ("- " + listingDesc) : ""}
  Rules (optional):
  ${rules ? ("- " + rules) : ""}
  File hint (optional):
  ${fileHint ? ("- " + fileHint) : ""}
  `.trim();

          const payload = {
            model: window.modelName || "gpt-5",
            input: [
              { role: "system", content: "Return ONLY one plain-text line, <=200 characters." },
              {
                role: "user",
                content: [
                  { type: "input_text", text: prompt },
                  { type: "input_image", image_url: imgData }
                ]
              }
            ],
            max_output_tokens: 300,
            reasoning: { effort: "minimal" },
            text: { verbosity: "medium" }
          };

          const data = await callOpenAI(payload);
          const raw = (typeof extractResponseText === "function")
            ? extractResponseText(data)
            : (data?.output_text || "").trim();

          const best = (raw || listingDesc || fileHint || "Jewelry photo")
            .replace(/\s+/g, " ")
            .slice(0, 200);

          window.photoMeta = window.photoMeta || [];
          window.photoMeta[i] = best;

          const s = document.getElementById("metadataStatus" + i);
          if (s) s.textContent = "✓ analyzed";

          const ta = document.getElementById("metadataTextarea");
          if (ta) {
            const count = Math.min(7, window.previewImages.length);
            const lines = Array.from({ length: count }, (_, idx) =>
              `${idx + 1}. ${window.photoMeta[idx] || ""}`.trim()
            ).join("\n").trim();
            if (lines) ta.value = lines;
          }

          return best;
        } catch (e) {
          console.error("metadataHandler.analyzeAndEmbedMetadata error:", e);
          if (window.M?.toast) M.toast({ html: "Metadata error: " + e.message });
        }
      }

      return { analyzeAndEmbedMetadata };
    })();
  </script>

  <script>
    // The temporary debug toast notifications have been removed.

    window.ETSY_SHOP_URL = "https://www.etsy.com/shop/custombrites";
    window.CLIENT_ID = "k75zdspz4r99txpqdji7i2em";
    window.REDIRECT_URI = "https://delicate-tanuki-616ac0.netlify.app/";
    window.modelName = "gpt-5";
    window.accessToken;
    window.photoNames = [];
    window.previewImages = [];
    window.photoMeta = [];
    window.draggedIndex = null;
    window.photoIds = [];
    window.currentCropIndex = null;
    window.cropper = null;
    window.reservedPhotos = [];
    window.listingQueue = [];
    window.photoUpdateComplete = false;
    window.infoUpdateComplete = false;

    // ====== POSITION CONFIG (global, dynamic) ======
    window.configComponentIDs = [];

    /** Every interactive/visible control we want independently positionable */
    const AUTO_SELECTORS = [
      "button",        // all <button>
      "a.btn",         // Materialize anchors acting as buttons
      "input", "textarea", "select",
      "#dropZone",
      ".preview-cell", // each photo cell
      ".section-heading",
      "#titleSpinner",
      "#listingQueueCount",
      "#listingDescContainer",
      "#descriptionSpinner",
      "#searchSpinner",
      "#analyzeMetadataProgress",
      "#createListingProgress",
      "#duplicateListingProgress",
      "#titleCount"             
    ];

    function isExcluded(el){
      // do NOT move overlays or any modal internals (including the config modal itself)
      return el.closest("#configModal") || el.closest(".modal") || el.classList.contains("modal") || el.classList.contains("modal-overlay");
    }

    function ensureId(el){
      if (el.id) return el.id;
      const id = el.tagName.toLowerCase() + "-" + Math.random().toString(36).slice(2,7);
      el.id = id;
      return id;
    }

    function collectMovables(){
      const nodes = new Set();
      AUTO_SELECTORS.forEach(sel => {
        document.querySelectorAll(sel).forEach(n => { if (!isExcluded(n)) nodes.add(n); });
      });
      return Array.from(nodes);
    }

    // 3.2 Hard defaults — FULLY SPECIFIED per user map (all keys get a concrete value)
    const defaultPositions = {
      // Top controls
      openConfigBtn:           { left: 190,  top: 10,  width: 140, height: 35 },
      connectEtsyBtn:          { left: 10,   top: 10,  width: 160, height: 35 },
      createListingBtn:        { left: 700,  top: 10,  width: 160, height: 35 },
      createListingProgress:   { left: 870,  top: 10,  width: 260, height: 22 },
      analyzeMetadataBtn:      { left: 600,  top: 100, width: 160, height: 35 },

      // Generation controls
      generateBtn:             { left: 10,   top: 455, width: 125, height: 35 },
      regenTitleBtn:           { left: 285,  top: 492, width: 100, height: 35 },
      copyTitleBtn:            { left: 410,  top: 492, width: 100, height: 35 },
      showTitleRulesBtn:       { left: 150,  top: 0,   width: 0,   height: 0  },
      regenDescriptionBtn:     { left: 285,  top: 603, width: 100, height: 35 },
      copyDescriptionBtn:      { left: 410,  top: 603, width: 100, height: 35 },
      showDescriptionRulesBtn: { left: 150,  top: 0,   width: 0,   height: 0  },

      // Text inputs / areas
      listingDescInput:        { left: 10,   top: 220, width: 490, height: 35 },
      shopListings:            { left: 10,   top: 110, width: 500, height: 45 },
      searchKeyPhrases:        { left: 10,   top: 325, width: 500, height: 200 },
      listingTitle:            { left: 10,   top: 535, width: 1000,height: 45 },
      listingDescription:      { left: 10,   top: 540, width: 1400,height: 150 },
      listingDescContainer:    { left: 10,   top: 185, width: 520,  height: 70  },
      titleCount:              { left: 1030,   top: 558, width: 150,  height: 24  },

      // Drop zone
      dropZone:                { left: 1340, top: 150, width: 155, height: 350 },

      // Preview cells
      previewCell0:            { left: 600,  top: 150, width: 120, height: 158 },
      previewCell1:            { left: 750,  top: 150, width: 120, height: 158 },
      previewCell2:            { left: 900,  top: 150, width: 120, height: 158 },
      previewCell3:            { left: 1050, top: 150, width: 120, height: 158 },
      previewCell4:            { left: 1200, top: 150, width: 120, height: 158 },
      previewCell5:            { left: 600,  top: 340, width: 120, height: 158 },
      previewCell6:            { left: 750,  top: 340, width: 120, height: 158 },
      previewCell7:            { left: 900,  top: 340, width: 120, height: 158 },
      previewCell8:            { left: 1050, top: 340, width: 120, height: 158 },
      previewCell9:            { left: 1200, top: 340, width: 120, height: 158 },

      // Auto-assigned heading IDs (current session)
      etsyShopListingsHeading:   { left: 10,   top: 75,  width: 180, height: 27 },
      searchKeyPhrasesHeading:   { left: 10,   top: 290, width: 180, height: 27 },
      listingTitleHeading:       { left: 10,   top: 505, width: 180, height: 27 },
      titleSpinner:              { left: 160,  top: 507, width: 20,  height: 20 },
      listingDescriptionHeading: { left: 10,   top: 610, width: 250, height: 27 },
      searchSpinner:             { left: 177,  top: 292, width: 20,  height: 20 },
      descriptionSpinner:        { left: 235,  top: 612, width: 20,  height: 20 },
      analyzeMetadataProgress:   { left: 800,  top: 105, width: 260, height: 27 },
      duplicateListingBtn:       { left: 1040, top: 10, width: 160, height: 35 },
      duplicateListingProgress:  { left: 1040, top: 40, width: 260, height: 22 },

      // Counter chip
      listingQueueCount:       { left: 190,  top: 75,  width: 25,  height: 27 }
    };

    // (Shipping-1 stores to LS as pos-<id>-left|top|width|height and applies absolute layout.  [oai_citation:6‡shipping-1.html](file-service://file-UyzPx2tdaLoZi5ZZoE5Zq8))

    function adoptIntoLayoutRoot(el){
    const stage = document.getElementById("layoutRoot");
    if (!stage || !el || el.parentElement === stage) return;

    // Compute absolute document coordinates BEFORE moving
    const r = el.getBoundingClientRect();
    const L = Math.round(r.left + window.scrollX);
    const T = Math.round(r.top  + window.scrollY);
    const W = Math.round(r.width  || el.offsetWidth  || 0);
    const H = Math.round(r.height || el.offsetHeight || 0);

    stage.appendChild(el); // reparent to stage

    el.classList.add("layout-abs");
    el.classList.add("configurable"); // dashed outline in config-mode
    el.style.setProperty("position","absolute","important");
    el.style.setProperty("left",  L + "px","important");
    el.style.setProperty("top",   T + "px","important");
    el.style.setProperty("width", W + "px","important");
    el.style.setProperty("height",H + "px","important");
    el.style.setProperty("z-index","3000","important");
    // strip conflicting layout styles
    el.style.removeProperty("margin");
    el.style.removeProperty("margin-left");
    el.style.removeProperty("margin-top");
    el.style.removeProperty("right");
    el.style.removeProperty("bottom");
  }

  function initAbsoluteLayout(){
    const stage = document.getElementById("layoutRoot");
    if (!stage) return;

    const movables = collectMovables();
    window.configComponentIDs = [];
    movables.forEach(el => {
      const id = ensureId(el);
      window.configComponentIDs.push(id);
      adoptIntoLayoutRoot(el);
    });
    // de-dupe
    window.configComponentIDs = Array.from(new Set(window.configComponentIDs));
  }

    // Utility to get a safe numeric value
    function _num(v, fallback){ v = (v==null? "" : String(v)); var n = parseInt(v,10); return isFinite(n) ? n : fallback; }

    // Remove old wrapper positions/styles we no longer control
    function cleanupNestedConflicts(){
      ["descriptionAndFileUploadContainer","topButtons","belowSearch"].forEach(function(id){
        var el = document.getElementById(id);
        if (el){
          el.classList.remove("layout-abs");
          el.style.removeProperty("position");
          el.style.removeProperty("left");
          el.style.removeProperty("top");
          el.style.removeProperty("width");
          el.style.removeProperty("height");
        }
        ["left","top","width","height"].forEach(function(k){
          localStorage.removeItem("pos-"+id+"-"+k);
        });
      });
    }

    // ---- ID migration: preserve saved positions after renaming ephemeral IDs ----
    const ID_MIGRATIONS = {
      "div-0g0nl": "etsyShopListingsHeading",
      "span-yr8zb": "searchKeyPhrasesHeading",
      "div-89qwd": "listingTitleHeading",
      "div-0cwxn": "listingDescriptionHeading"
    };
    function migrateLocalStoragePositions(){
      Object.entries(ID_MIGRATIONS).forEach(([oldId, newId]) => {
        ["left","top","width","height"].forEach(k => {
          const oldKey = "pos-" + oldId + "-" + k;
          const newKey = "pos-" + newId + "-" + k;
          const val = localStorage.getItem(oldKey);
          if (val != null && localStorage.getItem(newKey) == null) {
            localStorage.setItem(newKey, val);
          }
          // Always clear the old keys so they won't clutter storage
          localStorage.removeItem(oldKey);
        });
      });
    }

    // 3.3 Apply saved (or default) positions — same storage keys as shipping-1
    function loadPositions(){
      const ids = window.configComponentIDs || [];
      for (var i=0; i<ids.length; i++){
        var id = ids[i];
        var el = document.getElementById(id);
        if(!el) continue;

        // If no hard default provided, seed from the live DOM so first-run layout is preserved.
        var rect = el.getBoundingClientRect();
        var seed = {
          left:  Math.round(rect.left + window.scrollX),
          top:   Math.round(rect.top  + window.scrollY),
          width: Math.round(rect.width  || el.offsetWidth  || 0),
          height:Math.round(rect.height || el.offsetHeight || 0)
        };
        var def = Object.assign(seed, defaultPositions[id] || {});

        var left = localStorage.getItem("pos-"+id+"-left");
        var top  = localStorage.getItem("pos-"+id+"-top");
        var w    = localStorage.getItem("pos-"+id+"-width");
        var h    = localStorage.getItem("pos-"+id+"-height");

        left = _num(left, def.left);
        top  = _num(top,  def.top);
        w    = _num(w,    def.width);
        h    = _num(h,    def.height);

        el.classList.add("layout-abs");
        el.classList.add("configurable"); // show dashed outline + transition in config-mode
        // Use !important to beat author styles and grid/flex side-effects
        el.style.setProperty("position", "absolute", "important");
        el.style.setProperty("left",    left + "px", "important");
        el.style.setProperty("top",     top  + "px", "important");
        el.style.setProperty("width",   ((w>0 ? w : def.width)) + "px", "important");
        el.style.setProperty("height",  ((h>0 ? h : def.height)) + "px", "important");
        // NEW: ensure absolute layout isn't visually offset/hidden
        el.style.removeProperty("margin");
        el.style.removeProperty("margin-left");
        el.style.removeProperty("margin-top");
        el.style.removeProperty("right");
        el.style.removeProperty("bottom");
        el.style.setProperty("z-index", "3000", "important");
      }
    }

    function populateConfigTable(){
      var tbody = document.getElementById("configTable").querySelector("tbody");
      tbody.innerHTML = "";
      const ids = window.configComponentIDs || [];
      for (var i=0; i<ids.length; i++){
        var id = ids[i];
        var el = document.getElementById(id);
        if(!el) continue;

        // Seed exactly like loadPositions(): DOM rect → merged with hard defaults
        var rect = el.getBoundingClientRect();
        var seed = {
          left:  Math.round(rect.left + window.scrollX),
          top:   Math.round(rect.top  + window.scrollY),
          width: Math.round(rect.width  || el.offsetWidth  || 0),
          height:Math.round(rect.height || el.offsetHeight || 0)
        };
        var def = Object.assign(seed, defaultPositions[id] || {});

        // Prefer saved values if present
        var left = _num(localStorage.getItem("pos-"+id+"-left"),   def.left);
        var top  = _num(localStorage.getItem("pos-"+id+"-top"),    def.top);
        var w    = _num(localStorage.getItem("pos-"+id+"-width"),  def.width);
        var h    = _num(localStorage.getItem("pos-"+id+"-height"), def.height);

        var tr = document.createElement("tr");
        tr.innerHTML = `
          <td>${id}</td>
          <td><input id="left_${id}"   type="number" value="${left}"  style="width:90px"></td>
          <td><input id="top_${id}"    type="number" value="${top}"   style="width:90px"></td>
          <td><input id="width_${id}"  type="number" value="${w}"     style="width:90px"></td>
          <td><input id="height_${id}" type="number" value="${h}"     style="width:90px"></td>
        `;
        tbody.appendChild(tr);
        // Live preview while editing numbers (input/change/keyup/mousewheel)
        ["left","top","width","height"].forEach(function(k){
          var inp = document.getElementById(k + "_" + id);
          if (inp) {
            const handler = function(){ previewFromInputs(id); };
            ["input","change","keyup","mousewheel"].forEach(evt => inp.addEventListener(evt, handler));
          }
        });
      }
    }

    /* --- absolute layout helpers --- */
    function applySinglePosition(id, left, top, width, height) {
      const el = document.getElementById(id);
      if (!el) return;

      const cs = window.getComputedStyle(el);
      const curL = parseInt(cs.left, 10)    || el.offsetLeft  || 0;
      const curT = parseInt(cs.top, 10)     || el.offsetTop   || 0;
      const curW = parseInt(cs.width, 10)   || el.offsetWidth || 0;
      const curH = parseInt(cs.height, 10)  || el.offsetHeight|| 0;

      const L = Number.isFinite(+left)  ? +left  : curL;
      const T = Number.isFinite(+top)   ? +top   : curT;
      const W = Number.isFinite(+width) ? +width : curW;
      const H = Number.isFinite(+height)? +height: curH;

      el.classList.add("layout-abs");
      el.style.setProperty("position", "absolute", "important");
      el.style.setProperty("left",  L + "px", "important");
      el.style.setProperty("top",   T + "px", "important");
      el.style.setProperty("width", W + "px", "important");
      el.style.setProperty("height",H + "px", "important");
      el.style.setProperty("z-index","3000","important");

      // Ensure nothing "fights" absolute placement
      el.style.removeProperty("margin");
      el.style.removeProperty("margin-left");
      el.style.removeProperty("margin-top");
      el.style.removeProperty("right");
      el.style.removeProperty("bottom");
    }

    function previewFromInputs(id) {
      const l = document.getElementById("left_"   + id)?.value;
      const t = document.getElementById("top_"    + id)?.value;
      const w = document.getElementById("width_"  + id)?.value;
      const h = document.getElementById("height_" + id)?.value;
      applySinglePosition(id, parseInt(l,10), parseInt(t,10), parseInt(w,10), parseInt(h,10));
    }

    function forceApplyPositions() {
      // Apply now, after modal close animation, and once more after paint
      requestAnimationFrame(() => {
        if (typeof loadPositions === "function") loadPositions();
        setTimeout(() => { if (typeof loadPositions === "function") loadPositions(); }, 180);
      });
    }

    // 3.5 Wire up modal + save handler (same ids as shipping-1)
    document.addEventListener("DOMContentLoaded", function(){
      localStorage.removeItem("buttonPositions"); // purge legacy store once
      // Cleanup old wrapper keys, adopt EVERY control into the absolute stage, then apply layout
      cleanupNestedConflicts();
      initAbsoluteLayout();      // discover, assign IDs, reparent to #layoutRoot
      migrateLocalStoragePositions(); // move saved positions from old random IDs to new stable IDs
      loadPositions();           // apply saved/default positions to all

    var configModal = M.Modal.init(document.getElementById("configModal"), {
      onOpenStart() {
        document.body.classList.add("config-mode");
        // So you can see layout changes behind the modal
        setTimeout(() => {
          const ov = document.querySelector(".modal-overlay");
          if (ov) ov.style.opacity = "0.15";
        }, 0);
        // NEW: show/animate the spinners during layout editing
        ["titleSpinner","descriptionSpinner","searchSpinner"].forEach(id => {
          const sp = document.getElementById(id);
          if (sp) {
            sp.style.display = "inline-block";
            sp.classList.add("active");
          }
        });
      },
      onCloseEnd() {
        document.body.classList.remove("config-mode");
        const ov = document.querySelector(".modal-overlay");
        if (ov) ov.style.opacity = "";
        // NEW: return spinners to normal, API-driven visibility on close
        ["titleSpinner","descriptionSpinner","searchSpinner"].forEach(id => {
          const sp = document.getElementById(id);
          if (sp) {
            sp.classList.remove("active");
            sp.style.display = ""; // let the generators control visibility
          }
        });
      }
    });
    var openBtn = document.getElementById("openConfigBtn");
    if (openBtn){
      openBtn.addEventListener("click", function(){
        populateConfigTable(); // shipping-1 builds table on open.  [oai_citation:8‡shipping-1.html](file-service://file-UyzPx2tdaLoZi5ZZoE5Zq8)
        configModal.open();
      });
    }

      var resetBtn = document.getElementById("resetLayoutBtn");
      if (resetBtn){
        resetBtn.addEventListener("click", function(){
          const ids = window.configComponentIDs || [];
          ids.forEach(id => ["left","top","width","height"].forEach(k => localStorage.removeItem("pos-"+id+"-"+k)));
          if (window.M && M.toast) M.toast({ html: "All positions reset." });
          requestAnimationFrame(() => { if (typeof loadPositions === "function") loadPositions(); });
        });
      }

      var saveBtn = document.getElementById("saveConfigBtn");
      if (saveBtn){
        saveBtn.addEventListener("click", function(){
          const ids = window.configComponentIDs || [];
          for (var i=0; i<ids.length; i++){
            var id = ids[i];
            var el = document.getElementById(id);
            if(!el) continue;

            var cs = window.getComputedStyle(el);
            var left = _num(document.getElementById("left_"+id)?.value,
                            _num(localStorage.getItem("pos-"+id+"-left"),  parseInt(cs.left)||el.offsetLeft||0));
            var top  = _num(document.getElementById("top_"+id)?.value,
                            _num(localStorage.getItem("pos-"+id+"-top"),   parseInt(cs.top)||el.offsetTop||0));
            var w    = _num(document.getElementById("width_"+id)?.value,
                            _num(localStorage.getItem("pos-"+id+"-width"), parseInt(cs.width)||el.offsetWidth||0));
            var h    = _num(document.getElementById("height_"+id)?.value,
                            _num(localStorage.getItem("pos-"+id+"-height"),parseInt(cs.height)||el.offsetHeight||0));

            if (left!=null) localStorage.setItem("pos-"+id+"-left",  left);
            if (top!=null)  localStorage.setItem("pos-"+id+"-top",   top);
            if (w!=null)    localStorage.setItem("pos-"+id+"-width", w);
            if (h!=null)    localStorage.setItem("pos-"+id+"-height",h);

            // Live preview (with margin strip + high z-index)
            if (typeof applySinglePosition === "function") {
              applySinglePosition(id, left, top, w, h);
            } else {
              // Fallback if applySinglePosition() isn't present
              el.classList.add("layout-abs");
              el.classList.add("configurable"); // ensure outline/transition are active
              el.style.setProperty("position", "absolute", "important");
              el.style.setProperty("left",  L + "px", "important");
              el.style.setProperty("top",   T + "px", "important");
              el.style.setProperty("width", W + "px", "important");
              el.style.setProperty("height",H + "px", "important");

              // show above page content while configuring, but still under the modal content
              const z = document.body.classList.contains("config-mode") ? 10050 : 3000;
              el.style.setProperty("z-index", String(z), "important");
              el.style.removeProperty("margin");
              el.style.removeProperty("margin-left");
              el.style.removeProperty("margin-top");
              el.style.removeProperty("right");
              el.style.removeProperty("bottom");
            }
          }

          // Apply everything once after persisting
          if (typeof forceApplyPositions === "function") forceApplyPositions();

          if (window.M && M.toast) M.toast({ html: "Layout saved and applied." });

          // Re-assert once more after modal animates closed
          requestAnimationFrame(loadPositions);
        });
      }
    });

    window.appendedDescriptionText = `

----------------------------------

D E T A I L S 
Materials: 
 •  Sterling Silver
 •  14k Gold Filled
 •  14K Rose Gold Filled 
 •  14K Solid Gold

• We use the Highest Quality materials from the US and Italy.
• Your purchase will come packaged in a lovely Jewelry Box

-----------------------------------

P A C K A G I N G
• Your purchase will come beautifully packaged. If you are ordering for a gift and would like each piece to be packaged separately please let me know. 

• If this purchase is a gift, and you would like us to include a handwritten message, leave a note in the "gift message" box at checkout.

------------------------------------

E X P E D I T E D • S H I P P I N G
You will be able to choose faster shipping options in the drop down menu when you check out. Ship times do NOT include production times (1-3 business days). However, if you select expedited shipping, we will try to get your order done faster.

------------------------------------

E X P L O R E • O U R • S H O P
Don't forget to check out the rest of our shop! We specialize in making handmade custom jewelry for every occasion. We take pride in making sure each order is made exactly to the customers specifications. We love collaborating with our customers to create  special and unique pieces for themselves and their loved ones. Please don't hesitate to contact us with any questions you have.  

http://custombrites.etsy.com

-----------------------------------

C H E C K • U S • O U T
Make sure you follow us on all our social media platforms to get a behind the scenes look, special promo codes, and some daily inspiration :) 

Instagram: https://www.instagram.com/britesjewelry
Facebook: https://www.facebook.com/britesjewelry
Pinterest Page : https://www.pinterest.com/britesjewelry

------------------------------------

S H O P  • P O L I C I E S
Check out our shop polices page for more details about all our polices and please don't hesitate to contact us with any questions you have! Happy Shopping :)

https://www.etsy.com/shop/CustomBrites/policy"

https://www.etsy.com/your/shops/me/listing-editor/edit/1822973998
`;

    // On persistDataBeforeRedirect, store current queue to local storage.
    function persistDataBeforeRedirect() {
      try {
        const listingsInputValue = document.getElementById("shopListings").value || "";
        localStorage.setItem("shopListingsText", listingsInputValue);
        localStorage.setItem("listingQueue", JSON.stringify(window.listingQueue));
      } catch (err) {
        console.error("Error persisting data before redirect:", err);
      }
    }

    // Show metadata in modal
    function showMetadata(index) {
      const metadata = (window.photoMeta && window.photoMeta[index]) 
                         ? window.photoMeta[index] 
                         : "No metadata available.";
      document.getElementById("metadataTextarea").value = metadata;
      let modalElem = document.getElementById("metadataModal");
      let modalInstance = M.Modal.getInstance(modalElem) || M.Modal.init(modalElem);
      modalInstance.open();
    }

    // Helper function: parseListingNumbers using regex to split by comma with optional whitespace
    function parseListingNumbers(rawInput) {
      const parts = rawInput.split(/\s*,\s*/);
      const cleaned = parts.filter(p => /^\d{10}$/.test(p));
      return Array.from(new Set(cleaned)).slice(0, 250);
    }

    // Attach event listeners to shopListings:
    // - "paste": parse pasted text and update queue (but do not save immediately)
    // - "change": update queue on manual change
    // - "keydown": on Enter (without Shift) update local storage (overwrite saved numbers)
    // When the user pastes into the shopListings textarea.
  document.getElementById("shopListings").addEventListener("paste", (e) => {
    e.preventDefault();
    let pasteData = (e.clipboardData || window.clipboardData).getData("text");
    window.listingQueue = parseListingNumbers(pasteData);
    loadNextListingInQueue();
  });

    // When the user changes the shopListings textarea manually.
  document.getElementById("shopListings").addEventListener("change", () => {
    let rawInput = document.getElementById("shopListings").value;
    window.listingQueue = parseListingNumbers(rawInput);
    loadNextListingInQueue();
  });

// When the user presses "Enter" (without Shift) in the shopListings textarea,
// update the listingQueue, save it to local storage, and display only the first number.
document.getElementById("shopListings").addEventListener("keydown", (e) => {
  if (e.key === "Enter" && !e.shiftKey) {
    e.preventDefault();
    let rawInput = document.getElementById("shopListings").value;
    window.listingQueue = parseListingNumbers(rawInput);
    localStorage.setItem("listingQueue", JSON.stringify(window.listingQueue));
    loadNextListingInQueue();
  }
});

    // loadNextListingInQueue displays only the first number from the queue and updates local storage.
    function loadNextListingInQueue() {
      window.photoUpdateComplete = false;
      window.infoUpdateComplete = false;
      if (window.listingQueue.length > 0) {
        document.getElementById("shopListings").value = window.listingQueue[0];
      } else {
        document.getElementById("shopListings").value = "";
      }
      updateListingQueueCount();
      localStorage.setItem("listingQueue", JSON.stringify(window.listingQueue));
    }

    // updateListingQueueCount updates the counter element.
    function updateListingQueueCount() {
      document.getElementById("listingQueueCount").textContent = window.listingQueue.length;
    }

    // On page load, restore the listing queue from local storage (if available)
    function restoreDataAfterRedirect() {
      try {
        // Load listingQueue from local storage if it exists.
        let storedQueue = localStorage.getItem("listingQueue");
        if (storedQueue) {
          window.listingQueue = JSON.parse(storedQueue);
          // Display only the first number from the restored queue.
          if (window.listingQueue.length > 0) {
            document.getElementById("shopListings").value = window.listingQueue[0];
          }
        }
      } catch (err) {
        console.error("Error restoring data after redirect:", err);
      }
    }

    window.addEventListener("load", () => {
      let container13 = document.getElementById("container13");
      container13.style.height = (container13.offsetHeight * 2.5) + "px";
    });

    function openCropModal(index) {
      window.currentCropIndex = index;
      let cropModal = document.getElementById("photoCropModal");
      let cropImage = document.getElementById("cropImage");
      cropImage.src = window.previewImages[index];
      cropImage.onload = function() {
        window.cropper = new Cropper(cropImage, {
          viewMode: 1,
          autoCropArea: 1,
          movable: true,
          zoomable: true,
          scalable: false,
          rotatable: false,
          responsive: true,
          background: false,
          modal: true,
          guides: true,
          center: true,
          highlight: true,
          cropBoxMovable: true,
          cropBoxResizable: true,
          dragMode: 'move',
          ready: function() {
            let containerData = window.cropper.getContainerData();
            let cropBoxData = window.cropper.getCropBoxData();
            window.cropper.setCropBoxData({
              left: (containerData.width - cropBoxData.width) / 2,
              top: (containerData.height - cropBoxData.height) / 2
            });
          }
        });
      };
      let instance = M.Modal.getInstance(cropModal) || M.Modal.init(cropModal, {});
      instance.open();
    }

    document.getElementById("saveCropBtn").addEventListener("click", () => {
      if (window.cropper && window.currentCropIndex !== null) {
        let croppedCanvas = window.cropper.getCroppedCanvas({ width: 3000, height: 3000 });
        window.previewImages[window.currentCropIndex] = croppedCanvas.toDataURL("image/jpeg", 0.85);
        updateStaticPreviewGrid();
        window.cropper.destroy();
        window.cropper = null;
        window.currentCropIndex = null;
        M.Modal.getInstance(document.getElementById("photoCropModal")).close();
      }
    });

    document.getElementById("cancelCropBtn").addEventListener("click", () => {
      if (window.cropper) {
        window.cropper.destroy();
        window.cropper = null;
      }
      window.currentCropIndex = null;
      M.Modal.getInstance(document.getElementById("photoCropModal")).close();
    });

    async function uploadPhotos() {
      let listingInput = document.getElementById("shopListings").value.trim();
      if (!listingInput) {
        M.toast({ html: "Please provide a listing URL or ID in 'Etsy Shop Listings'." });
        return;
      }
      if (!window.previewImages.length) {
        M.toast({ html: "No images to upload. Please drag and drop images first." });
        return;
      }

       if (!window.accessToken || String(window.accessToken).trim() === "") {
        M.toast({ html: "Not connected to Etsy. Click “Connect to Etsy” first." });
        return;
      }

      let listingId = /^\d+$/.test(listingInput)
        ? listingInput
        : (listingInput.match(/\/listing\/(\d+)/) || [])[1];
      if (!listingId) {
        M.toast({ html: "Invalid listing URL or ID." });
        return;
      }
      for (let i = 0; i < window.previewImages.length; i++) {
        let dataURL = window.previewImages[i];
        let altText = (window.photoMeta[i] || "").slice(0, 250); // mirror server clamp
        let rankNumber = i + 1;
        try {
          let res = await fetch(dataURL);
          let blob = await res.blob();
          let formData = new FormData();
          formData.append("listingId", listingId);
          formData.append("token", window.accessToken);
          formData.append("fileName", window.photoNames[i] || `uploaded_photo_${i}.jpg`);
          formData.append("rank", rankNumber);
          formData.append("alt_text", altText);
          formData.append("file", blob, window.photoNames[i] || `uploaded_photo_${i}.jpg`);
          let uploadUrl = `/.netlify/functions/imageUpload`;
          let response = await fetch(uploadUrl, { method: "POST", body: formData });
          const raw = await response.text();
          let msg = raw;
          try { msg = JSON.parse(raw).error || JSON.parse(raw).message || raw; } catch {}
          if (!response.ok) {
            M.toast({ html: `Photo #${rankNumber} failed (${response.status}): ${msg}` });
          } else {
            M.toast({ html: `Photo #${rankNumber} uploaded with alt_text!` });
            bumpCreateProgressPerImage(); // +8% per successful image upload
          }
        } catch (e) {
          console.error(e);
          M.toast({ html: `Exception uploading photo #${rankNumber}: ${e.message}` });
        }
      }
    }
    window.uploadPhotos = uploadPhotos;

    function toTwoColumns(phrases, perCol = 7, gap = 3) {
      const left = phrases.slice(0, perCol);
      const right = phrases.slice(perCol, perCol * 2);
      const leftWidth = Math.max(0, ...left.map(p => p.length));
      const pad = leftWidth + gap; // space between columns
      const lines = [];
      for (let i = 0; i < perCol; i++) {
        const l = (left[i] || "");
        const r = (right[i] || "");
        lines.push(l.padEnd(pad, " ") + r);
      }
      return lines.join("\n");
    }

    async function uploadReservedPhotos() {
      let listingInput = document.getElementById("shopListings").value.trim();
      if (!listingInput) {
        M.toast({ html: "Please provide a listing URL or ID in 'Etsy Shop Listings'." });
        return;
      }
      if (!window.reservedPhotos.length) {
        M.toast({ html: "No reserved photos to upload." });
        return;
      }
      let listingId = /^\d+$/.test(listingInput)
        ? listingInput
        : (listingInput.match(/\/listing\/(\d+)/) || [])[1];
      if (!listingId) {
        M.toast({ html: "Invalid listing URL or ID." });
        return;
      }
      for (let i = 0; i < window.reservedPhotos.length; i++) {
        let dataURL = window.reservedPhotos[i].src;
        let altText = window.reservedPhotos[i].meta || "";
        let rankNumber = i + 8;
        try {
          let res = await fetch(dataURL);
          let blob = await res.blob();
          let formData = new FormData();
          formData.append("listingId", listingId);
          formData.append("token", window.accessToken);
          formData.append("fileName", window.reservedPhotos[i].name || `reserved_photo_${i}.jpg`);
          formData.append("rank", rankNumber);
          formData.append("alt_text", altText);
          formData.append("file", blob, window.reservedPhotos[i].name || `reserved_photo_${i}.jpg`);
          let uploadUrl = `/.netlify/functions/imageUpload`;
          let response = await fetch(uploadUrl, { method: "POST", body: formData });
          const raw = await response.text();
          let msg = raw;
          try { msg = JSON.parse(raw).error || JSON.parse(raw).message || raw; } catch {}
          if (!response.ok) {
            M.toast({ html: `Photo #${rankNumber} failed (${response.status}): ${msg}` });
          } else {
            M.toast({ html: `Photo #${rankNumber} uploaded with alt_text!` });
            bumpCreateProgressPerImage(); // +8% per successful reserved image upload
          }
        } catch (e) {
          console.error(e);
          M.toast({ html: `Exception uploading reserved photo #${rankNumber}: ${e.message}` });
        }
      }
    }

    function setMetadataProgress(pct) {
      const wrap = document.getElementById("analyzeMetadataProgress");
      if (!wrap) return;
      const bar = wrap.querySelector(".bar");
      const txt = wrap.querySelector(".pct");
      const clamped = Math.max(0, Math.min(100, Math.round(pct)));
      if (bar) bar.style.width = clamped + "%";
      if (txt) txt.textContent = clamped + "%";
    }
    function resetMetadataProgress() {
      setMetadataProgress(0);
    }

    // --- Create Listing unified progress (Photos -> Info)
    function setCreateProgress(pct) {
      const wrap = document.getElementById("createListingProgress");
      if (!wrap) return;
      const bar = wrap.querySelector(".bar");
      const txt = wrap.querySelector(".pct");
      const clamped = Math.max(0, Math.min(100, Math.round(pct)));
      if (bar) bar.style.width = clamped + "%";
      if (txt) txt.textContent = clamped + "%";
    }
    function resetCreateProgress() { window._createPct = 0; setCreateProgress(0); }
    function showCreateProgress(show) {
      const wrap = document.getElementById("createListingProgress");
      if (wrap) wrap.style.display = show ? "block" : "none";
    }
    function bumpCreateProgressPerImage() {
      const prev = Number(window._createPct || 0);
      const next = Math.min(100, prev + 8); // 8% per successful upload
      window._createPct = next;
      setCreateProgress(next);
    }

    // NEW: Duplicate progress (holistic)
    function setDuplicateProgress(pct) {
      const wrap = document.getElementById("duplicateListingProgress");
      if (!wrap) return;
      const bar = wrap.querySelector(".bar");
      const txt = wrap.querySelector(".pct");
      const clamped = Math.max(0, Math.min(100, Math.round(pct)));
      if (bar) bar.style.width = clamped + "%";
      if (txt) txt.textContent = clamped + "%";
    }
    function resetDuplicateProgress(){ window._dupPct = 0; setDuplicateProgress(0); }
    function showDuplicateProgress(show){ const w = document.getElementById("duplicateListingProgress"); if (w) w.style.display = show ? "block" : "none"; }

    document.getElementById("analyzeMetadataBtn").addEventListener("click", async () => {
      try {
        const total = (window.previewImages && window.previewImages.length) || 0;
        if (!total) {
          if (window.M?.toast) M.toast({ html: "No images to analyze." });
          return;
        }
        resetMetadataProgress();
        for (let i = 0; i < total; i++) {
          await metadataHandler.analyzeAndEmbedMetadata(i);
          setMetadataProgress(((i + 1) / total) * 100);
        }
        if (window.M?.toast) M.toast({ html: `Analyzed metadata for ${total} image${total !== 1 ? "s" : ""}.` });
      } catch (e) {
        console.error(e);
        if (window.M?.toast) M.toast({ html: "Metadata analyze error: " + (e?.message || e) });
      }
    });

    // --- Create Listing: Photos (1/2) then Info (2/2) with a single blue progress bar
    document.getElementById("createListingBtn").addEventListener("click", async () => {
      const btn = document.getElementById("createListingBtn");
      try {
        // Resolve listing ID (accepts plain ID or URL with /listing/ID)
        let listingInput = (document.getElementById("shopListings").value || "").trim();
        if (!listingInput) { M.toast({ html: "Please provide a listing URL or ID in 'Etsy Shop Listings'." }); return; }
        let listingId = /^\d+$/.test(listingInput) ? listingInput : ((listingInput.match(/\/listing\/(\d+)/) || [])[1]);
        if (!listingId) { M.toast({ html: "Invalid listing URL or ID." }); return; }
        if (!window.accessToken) { M.toast({ html: "Please Connect to Etsy first." }); return; }

        // UI: show unified progress + disable button
        btn && (btn.disabled = true);
        showCreateProgress(true);
        resetCreateProgress(); // now sets window._createPct=0 and bar to 0%

        // ---------------- Stage 1: Upload Photos (main + reserved) ----------------
        await uploadPhotos();               // existing function
        await uploadReservedPhotos();       // existing function
        window.photoUpdateComplete = true;

        // ---------------- Stage 2: Upload Info (title/desc/tags) -----------------
        const userTitle = (document.getElementById("listingTitle").value || "").trim();
        const userDescription = document.getElementById("listingDescription").value || "";
        const finalDescription = userDescription + (window.appendedDescriptionText || "");

        // Build Etsy-safe tags (≤13 items, ≤20 chars each), honoring two-column numbering
        const raw = (document.getElementById("searchKeyPhrases").value || "");
        const tags = [];
        const seen = new Set();
        const pushTag = (s) => {
          let tag = (s || "")
            .normalize("NFKD")
            .replace(/[^\p{Letter}\p{Number}\s]/gu, " ")
            .replace(/\s+/g, " ")
            .trim();
          if (!tag) return;
          if (tag.length > 20) {
            const cut = tag.slice(0, 20); const sp = cut.lastIndexOf(" ");
            tag = (sp > 7 ? cut.slice(0, sp) : cut).trim();
          }
          const key = tag.toLowerCase();
          if (!seen.has(key)) { seen.add(key); tags.push(tag); }
        };
        raw.split("\n").forEach(line => {
          let foundAny = false;
          for (const m of line.matchAll(/\b\d{1,2}[.)]\s*([^0-9]+?)(?=(\s+\d{1,2}[.)]\s*|$))/g)) {
            foundAny = true; pushTag(m[1]); if (tags.length >= 13) break;
          }
          if (!foundAny) { const fallback = line.replace(/^\s*\d+[.)]\s*/, ""); pushTag(fallback); }
        });
        const slicedTags = tags.slice(0, 13);

        const payload = {
          listing_id: listingId,
          title: userTitle,
          description: finalDescription,
          tags: slicedTags
        };
        const resp = await fetch(`/.netlify/functions/updateListing?listingId=${encodeURIComponent(listingId)}`, {
          method: "PUT",
          headers: { "Content-Type": "application/json", Authorization: "Bearer " + window.accessToken },
          body: JSON.stringify(payload)
        });
        const result = await resp.json();
        if (!resp.ok) {
          throw new Error(`Info update failed ${resp.status} — ${JSON.stringify(result)}`);
        }
        window.infoUpdateComplete = true;
        setCreateProgress(100);
        M.toast({ html: "Create Listing complete: Photos + Info updated." });

        // Advance queue if present
        if (window.listingQueue && window.listingQueue.length > 0) {
          window.listingQueue.shift();
          if (typeof loadNextListingInQueue === "function") loadNextListingInQueue();
        }
      } catch (err) {
        console.error(err);
        M.toast({ html: "Create Listing error: " + (err?.message || err) });
      } finally {
        setTimeout(() => { showCreateProgress(false); resetCreateProgress(); }, 600);
        btn && (btn.disabled = false);
      }
    });

     // NEW: Ensure Analyze results differ if re-run
    function _normLine(s){ return String(s||"").toLowerCase().replace(/[^a-z0-9]+/g," ").trim(); }
    async function _rephraseAltDifferent(prev){
      const payload = {
        model: window.modelName || "gpt-5",
        input: [
          { role: "system", content: "Return ONLY one plain text line (<=200 chars). Must not be identical to the input. Avoid trivial punctuation-only changes." },
          { role: "user", content: `Rephrase this Etsy photo alt text so it says the same thing in different words (<=200 chars):\n${prev}` }
        ],
        max_output_tokens: 180,
        reasoning: { effort: "minimal" },
        text: { verbosity: "low" }
      };
      const data = await callOpenAI(payload);
      const out = (typeof extractResponseText === "function")
        ? extractResponseText(data)
        : (data?.output_text || "").trim();
      const line = (out || prev).replace(/\s+/g, " ").slice(0,200);
      if (_normLine(line) === _normLine(prev)) {
        // deterministic tiny nudge to ensure difference if model returned same text
        return line.replace(/\bcharm\b/i, "pendant");
      }
      return line;
    }

    // NEW: Duplicate Listing sequential orchestrator
    document.getElementById("duplicateListingBtn").addEventListener("click", async () => {
      const btn = document.getElementById("duplicateListingBtn");
      try {
        btn && (btn.disabled = true);
        showDuplicateProgress(true);
        resetDuplicateProgress(); // 0%

        // 1) Guarded Key Phrases (skip orange)
        await generateTagPhrasesGuarded();
        setDuplicateProgress(25);

        // 2) Re-generate Title
        await generateTitleOnly();
        setDuplicateProgress(50);

        // 3) Re-generate Description
        await generateDescriptionOnly();
        setDuplicateProgress(75);

        // 4) Analyze again, ensuring difference vs existing metadata
        const count = Array.isArray(window.previewImages) ? window.previewImages.length : 0;
        const metaTA = document.getElementById("metadataTextarea");
        for (let i = 0; i < count; i++) {
          const before = (window.photoMeta && window.photoMeta[i]) || "";
          const best = await window.metadataHandler.analyzeAndEmbedMetadata(i);
          let finalLine = best || "";
          if (_normLine(finalLine) === _normLine(before)) {
            finalLine = await _rephraseAltDifferent(before);
            window.photoMeta = window.photoMeta || [];
            window.photoMeta[i] = finalLine;
          }
          // keep textarea in sync
          if (metaTA) {
            const lines = Array.from({ length: Math.min(7, count) }, (_, idx) =>
              `${idx + 1}. ${window.photoMeta[idx] || ""}`.trim()
            ).join("\n").trim();
            if (lines) metaTA.value = lines;
          }
          const pct = 75 + Math.round(((i + 1) * 25) / Math.max(1, count));
          setDuplicateProgress(pct);
        }

        setDuplicateProgress(100);
        if (window.M?.toast) M.toast({ html: "Duplicate prep complete (SKP kept, Title/Desc re-gen, Analyze diversified)." });
      } catch (e) {
        console.error(e);
        if (window.M?.toast) M.toast({ html: "Duplicate flow error: " + e.message });
      } finally {
        btn && (btn.disabled = false);
      }
    });

    async function generateTagPhrases() {
      let question = document.getElementById("listingDescInput").value.trim();
      if (!question) {
        M.toast({ html: "Please enter a question in the Listing Description." });
        return;
      }

      // NEW: show blue spinner beside Search Key Phrases
      toggleSpinner("searchSpinner", true);

      try {
        let phrasesArray = await getInitialPhrases(
          question,
          document.getElementById("keywordRulesTextarea").value
        );

        // enforce ≤ 20 chars per phrase by regenerating offenders
        for (let i = 0; i < phrasesArray.length; i++) {
          if (phrasesArray[i].length > 20) {
            let otherValid = phrasesArray.filter((_, idx) => idx !== i && phrasesArray[idx].length <= 20);
            let newPhrase = await regenerateSinglePhrase(
              question,
              document.getElementById("keywordRulesTextarea").value,
              otherValid
            );
            phrasesArray[i] = newPhrase;
          }
        }
        if (phrasesArray.some(p => p.length > 20)) {
          throw new Error("Could not fix some phrases under 20 chars. Please try again.");
        }

        // build 2-column, numbered (1–7 / 8–14), fixed to 7 lines
        const left  = phrasesArray.slice(0, 7);
        const right = phrasesArray.slice(7, 14);
   // NEW: Guarded generator that preserves orange-highlighted phrases
    async function generateTagPhrasesGuarded() {
      // 1) Gather current + protected indices
      const ta = document.getElementById("searchKeyPhrases");
      const current = (typeof extractSkpPhrasesFromText === "function")
        ? extractSkpPhrasesFromText(ta?.value || "")
        : [];
      const protectedIdx = (typeof getSkpChangedIndices === "function")
        ? getSkpChangedIndices()
        : new Set();

      // 2) Ask model for fresh phrases (same source as your normal gen)
      const question = (document.getElementById("listingDescInput")?.value || "").trim();
      const keywordRules = document.getElementById("keywordRulesTextarea")?.value || "";
      const fresh = await getInitialPhrases(question, keywordRules); // returns array of strings

      // 3) Canonicalize, de-dup, cap to 13
      const canon = (s) => {
        let tag = String(s || "")
          .normalize("NFKD")
          .replace(/[^\p{Letter}\p{Number}\s]/gu, " ")
          .replace(/\s+/g, " ")
          .trim();
        if (!tag) return "";
        if (tag.length > 20) {
          const cut = tag.slice(0, 20);
          const sp = cut.lastIndexOf(" ");
          tag = (sp > 7 ? cut.slice(0, sp) : cut).trim();
        }
        return tag;
      };
      const seen = new Set();
      const sanitizedFresh = [];
      for (const f of fresh) {
        const t = canon(f);
        if (!t) continue;
        const key = t.toLowerCase();
        if (seen.has(key)) continue;
        seen.add(key);
        sanitizedFresh.push(t);
        if (sanitizedFresh.length >= 13) break;
      }

      // 4) Merge: keep protected (“orange”) current items; replace the rest
      const out = new Array(14).fill("");
      let pick = 0;
      for (let i = 0; i < 13; i++) {
        const keep = protectedIdx.has(i) && (current[i] || "").trim();
        if (keep) {
          out[i] = current[i];
        } else {
          // take the next fresh not already used
          while (pick < sanitizedFresh.length && out.includes(sanitizedFresh[pick])) pick++;
          out[i] = sanitizedFresh[pick] || current[i] || "";
          if (pick < sanitizedFresh.length) pick++;
        }
      }
      const phrasesArray = out.slice(0, 14);

      // 5) Rebuild the exact 2-column, fixed 7-line view (same as your formatter)
      const left  = phrasesArray.slice(0, 7);
      const right = phrasesArray.slice(7, 14);
      const leftLabels  = left.map((p, i) => `${i + 1}. ${p || ""}`);
      const rightLabels = right.map((p, i) => `${i + 8}. ${p || ""}`);
      const leftWidth = Math.max(0, ...leftLabels.map(s => s.length));
      const pad = leftWidth + 3;
      const colLines = [];
      for (let i = 0; i < 7; i++) {
        const L = leftLabels[i]  || `${i + 1}. `;
        const R = rightLabels[i] || "";
        colLines.push(L.padEnd(pad, " ") + R);
      }
      const outputText = colLines.join("\n");

      if (ta) {
        ta.value = outputText;
       // preserve highlights (do NOT reseed baseline here)
        if (typeof repadSkpColumnsPreserveCaret === "function") repadSkpColumnsPreserveCaret();
        if (typeof refreshSkpOverlay === "function") refreshSkpOverlay();
      }
      M.toast({ html: "Key Phrases updated (orange kept)" });
    }
        const leftLabels = left.map((p, i) => `${i + 1}. ${p || ""}`);
        const rightLabels = right.map((p, i) => `${i + 8}. ${p || ""}`);
        const leftWidth = Math.max(0, ...leftLabels.map(s => s.length));
        const pad = leftWidth + 3;
        const colLines = [];
        for (let i = 0; i < 7; i++) {
          const L = leftLabels[i]  || `${i + 1}. `;
          const R = rightLabels[i] || "";
          colLines.push(L.padEnd(pad, " ") + R);
        }
        const outputText = colLines.join("\n");

        const skp = document.getElementById("searchKeyPhrases");
        if (skp) {
          skp.value = outputText;
          skp.setAttribute("wrap", "off");
          skp.style.fontFamily = 'ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
          skp.style.overflowX = "auto";
          skp.style.fontSize = "85%";
          skp.setAttribute("rows", "7");
          skp.style.setProperty("height", "auto", "important");
          const cs = window.getComputedStyle(skp);
          let lh = parseFloat(cs.lineHeight);
          if (!lh || Number.isNaN(lh)) lh = parseFloat(cs.fontSize) * 1.2;
          const padY    = (parseFloat(cs.paddingTop) || 0) + (parseFloat(cs.paddingBottom) || 0);
          const borderY = (parseFloat(cs.borderTopWidth) || 0) + (parseFloat(cs.borderBottomWidth) || 0);
          const exactPx = Math.ceil(lh * 7 + padY + borderY);
          skp.style.setProperty("height",    exactPx + "px", "important");
          skp.style.setProperty("min-height",exactPx + "px", "important");
          skp.style.setProperty("max-height",exactPx + "px", "important");
          skp.style.setProperty("overflow-y","hidden", "important");
          skp.scrollTop = 0;
          // === PATCH 4: seed baseline & clear highlights on fresh generation ===
          if (typeof extractSkpPhrasesFromText === "function" && typeof refreshSkpOverlay === "function") {
            window.skpBaseline = extractSkpPhrasesFromText(skp.value);
            refreshSkpOverlay();
          }
        }

        M.toast({ html: "Tag Phrases generated successfully!" });
      } catch (err) {
        console.error(err);
        M.toast({ html: "Error generating valid tag phrases: " + err.message });
      } finally {
        // NEW: hide spinner
        toggleSpinner("searchSpinner", false);
      }
    }

    // Precise double-click selection inside #searchKeyPhrases:
    // Select ONLY the tag phrase (exclude "1. ", "2. ", and exclude the other column).
    (function attachTagPhraseDblClick(){
      const ta = document.getElementById("searchKeyPhrases");
      if (!ta) return;
      ta.addEventListener("dblclick", function(e){
        const text = ta.value;
        // Use current selectionStart as the click anchor
        let pos = ta.selectionStart ?? 0;
        // Identify current line
        const lineStart = text.lastIndexOf("\n", Math.max(0, pos - 1)) + 1;
        const nl = text.indexOf("\n", pos);
        const lineEnd = (nl === -1 ? text.length : nl);
        const line = text.slice(lineStart, lineEnd);
        // Line format: "<num>. <leftPhrase><spaces><num>. <rightPhrase>"
        const mNumLeft = line.match(/^(\s*\d{1,2}\.\s)/);
        if (!mNumLeft) return;
        const leftPrefixLen = mNumLeft[0].length;     // includes "1. "
        const rest = line.slice(leftPrefixLen);
        const mDelim = /\s{3,}\d{1,2}\.\s/.exec(rest); // gap + "8. "
        let leftText = rest, rightText = "", rightStartInLine = -1;
        if (mDelim) {
          leftText = rest.slice(0, mDelim.index);
          const rightOffset = mDelim.index + mDelim[0].length;
          rightText = rest.slice(rightOffset);
          rightStartInLine = leftPrefixLen + rightOffset;
        }
        const leftStartInLine = leftPrefixLen;
        const leftEndInLine   = leftPrefixLen + leftText.length;
        const clickOffset = (ta.selectionStart ?? 0) - lineStart;
        // Snap selection to the phrase under the click:
        if (clickOffset >= leftStartInLine && clickOffset <= leftEndInLine) {
          ta.setSelectionRange(lineStart + leftStartInLine, lineStart + leftEndInLine);
          e.preventDefault();
          return;
        }
        if (rightText && clickOffset >= rightStartInLine && clickOffset <= (line.length)) {
          ta.setSelectionRange(lineStart + rightStartInLine, lineEnd);
          e.preventDefault();
        }
      });
    })();

    /* === SKP HIGHLIGHT: helpers & wiring === */
    function _skpEscape(s){
      const mapEsc = { '&':'&amp;', '<':'&lt;', '>':'&gt;', '"':'&quot;', "'":'&#39;' };
      return String(s||'').replace(/[&<>"']/g, c => mapEsc[c]);
    }

    // Parse current 2-col lines into up to 14 phrases (1–7 left, 8–14 right)
    function extractSkpPhrasesFromText(text){
      const lines = String(text||"").split("\n");
      const phrases = [];
      for (let i=0;i<7;i++){
        const line = lines[i] ?? "";
        const mNumLeft = line.match(/^(\s*\d{1,2}\.\s)/);
        if(!mNumLeft){ phrases[i] = ""; phrases[i+7] = ""; continue; }
        const leftPrefixLen = mNumLeft[0].length;
        const rest = line.slice(leftPrefixLen);
        const mDelim = /\s{3,}\d{1,2}\.\s/.exec(rest); // gap + "8. "
        if (mDelim){
          const leftText  = rest.slice(0, mDelim.index);
          const rightText = rest.slice(mDelim.index + mDelim[0].length);
          phrases[i]   = leftText.trim();
          phrases[i+7] = rightText.trim();
        } else {
          phrases[i]   = rest.trim();
          phrases[i+7] = "";
        }
      }
      return phrases;
    }

    // Build overlay HTML from CURRENT TEXT (keeps exact spacing), marking changed indices
    function buildOverlayHtmlFromCurrentText(text, changedSet){
      const lines = String(text||"").split("\n");
      const out = [];
      for (let i=0;i<7;i++){
        const line = lines[i] ?? "";
        const mNumLeft = line.match(/^(\s*\d{1,2}\.\s)/);
        if(!mNumLeft){ out.push(_skpEscape(line)); continue; }

        const pre    = mNumLeft[0];
        const leftPrefixLen = pre.length;
        const rest   = line.slice(leftPrefixLen);
        const mDelim = /\s{3,}\d{1,2}\.\s/.exec(rest);

        let leftText="", rightText="", delim="";
        if (mDelim){
          leftText  = rest.slice(0, mDelim.index);
          delim     = rest.slice(mDelim.index, mDelim.index + mDelim[0].length);
          rightText = rest.slice(mDelim.index + mDelim[0].length);
        } else {
          leftText = rest;
        }

        const leftIdx  = i;      // 0..6
        const rightIdx = i + 7;  // 7..13

        const leftHTML  = changedSet.has(leftIdx)
          ? `<span style="background: rgba(255,165,0,0.35); border-radius:2px;">${_skpEscape(leftText)}</span>`
          : _skpEscape(leftText);
        const rightHTML = rightText!=="" && changedSet.has(rightIdx)
          ? `<span style="background: rgba(255,165,0,0.35); border-radius:2px;">${_skpEscape(rightText)}</span>`
          : _skpEscape(rightText);

        out.push(_skpEscape(pre) + leftHTML + _skpEscape(delim) + rightHTML);
      }
      return out.join("\n");
    }

    // Keep overlay positioned exactly over the textarea (absolute layout friendly)
    function syncSkpOverlayPosition(){
      const ta = document.getElementById("searchKeyPhrases");
      const ov = document.getElementById("skpOverlay");
      if(!ta || !ov) return;
      const cs = getComputedStyle(ta);
      ov.style.position   = "absolute";
      ov.style.whiteSpace = "pre";
      ov.style.fontFamily = cs.fontFamily;
      ov.style.fontSize   = cs.fontSize;
      ov.style.lineHeight = cs.lineHeight;
      ov.style.pointerEvents = "none";
      ov.style.zIndex = String((parseInt(cs.zIndex)||3000) - 1); // sit just under textarea’s z-index
      ov.style.color  = "transparent";      // hide overlay text; we only want background marks
      ov.style.left   = cs.left;
      ov.style.top    = cs.top;
      ov.style.width  = cs.width;
      ov.style.height = cs.height;
      ov.style.padding = cs.padding;
      ov.style.border  = "none";
      ov.style.background = "transparent";
      ov.style.margin = "0";
      // match scroll offsets
      ov.scrollTop  = ta.scrollTop;
      ov.scrollLeft = ta.scrollLeft;
    }

    // Ensure overlay node exists; create if missing and wire observers
    function ensureSkpOverlay(){
      const ta = document.getElementById("searchKeyPhrases");
      if(!ta) return null;
      let ov = document.getElementById("skpOverlay");
      if(!ov){
        ov = document.createElement("pre");
        ov.id = "skpOverlay";
        ov.setAttribute("aria-hidden","true");
        ta.insertAdjacentElement("afterend", ov);
      }
      // keep in lock-step with textarea scrolling & style changes
      ta.addEventListener("scroll", syncSkpOverlayPosition);
      const mo = new MutationObserver(syncSkpOverlayPosition);
      mo.observe(ta, { attributes: true, attributeFilter: ["style"] });
      window.addEventListener("resize", syncSkpOverlayPosition);
      // initial
      syncSkpOverlayPosition();
      return ov;
    }

    // Compute changed phrases vs baseline and repaint overlay
    window.skpBaseline = window.skpBaseline || [];
    function refreshSkpOverlay(){
      const ta = document.getElementById("searchKeyPhrases");
      const ov = ensureSkpOverlay();
      if(!ta || !ov) return;

      const current = extractSkpPhrasesFromText(ta.value);
      const base    = (window.skpBaseline && window.skpBaseline.length) ? window.skpBaseline : extractSkpPhrasesFromText(ta.value);

      const changed = new Set();
      const cap = Math.max(current.length, base.length);
      for (let i=0;i<cap;i++){
        const a = (current[i]||"").trim();
        const b = (base[i]||"").trim();
        if (a !== b) changed.add(i);
      }

      ov.innerHTML = buildOverlayHtmlFromCurrentText(ta.value, changed);
      syncSkpOverlayPosition();
    }

    // NEW: indices of phrases that are orange-highlighted (changed vs baseline)
    function getSkpChangedIndices() {
      const ta = document.getElementById("searchKeyPhrases");
      const cur = (typeof extractSkpPhrasesFromText === "function")
        ? extractSkpPhrasesFromText(ta?.value || "")
        : [];
      const base = Array.isArray(window.skpBaseline) ? window.skpBaseline : [];
      const changed = new Set();
      for (let i = 0; i < Math.max(cur.length, base.length); i++) {
        const a = (cur[i] || "").trim().toLowerCase();
        const b = (base[i] || "").trim().toLowerCase();
        if (a !== b) changed.add(i);
      }
      return changed;
    }

     /* === NEW: keep 2 columns aligned on edit (auto-pad to a fixed tab stop) ===
     Recomputes the left column max width and re-injects spaces so the right
     column (8–13) always starts at the same character, regardless of edits.
     Caret position is preserved. */
    function repadSkpColumnsPreserveCaret(){
      const ta = document.getElementById("searchKeyPhrases");
      if(!ta) return;

      const original = ta.value;
      const selStart = ta.selectionStart ?? 0;
      const selEnd   = ta.selectionEnd ?? selStart;

      // Identify current line and whether caret is in left or right phrase
      const lines = String(original).split("\n");
      let lineIdx = 0, acc = 0;
      for (; lineIdx < 7; lineIdx++){
        const len = (lines[lineIdx] ?? "").length + 1; // +1 for newline
        if (selStart < acc + len) break;
        acc += len;
      }
      const lineStart = acc;
      const line = lines[lineIdx] ?? "";
      const mNumLeft = line.match(/^(\s*\d{1,2}\.\s)/);
      let caretIsRight = false, caretOffsetInPhrase = 0;
      let leftText = "", rightText = "";
      if (mNumLeft){
        const leftPrefixLen = mNumLeft[0].length;
        const rest = line.slice(leftPrefixLen);
        const mDelim = /\s{3,}\d{1,2}\.\s/.exec(rest);
        if (mDelim){
          leftText  = rest.slice(0, mDelim.index);
          const rightOffset = mDelim.index + mDelim[0].length;
          rightText = rest.slice(rightOffset);
          const rightAbsStart = lineStart + leftPrefixLen + rightOffset;
          const leftAbsStart  = lineStart + leftPrefixLen;
          if (selStart >= rightAbsStart){
            caretIsRight = true;
            caretOffsetInPhrase = selStart - rightAbsStart;
          } else {
            caretOffsetInPhrase = Math.max(0, Math.min(selStart - leftAbsStart, leftText.length));
          }
        } else {
          leftText = rest;
          const leftAbsStart  = lineStart + leftPrefixLen;
          caretOffsetInPhrase = Math.max(0, Math.min(selStart - leftAbsStart, leftText.length));
        }
      }

      // Rebuild with a fixed tab-stop using your existing 2-column formatter
      const phrases = extractSkpPhrasesFromText(original);
      const left  = phrases.slice(0,7);
      const right = phrases.slice(7,14);
      const leftLabels  = left.map((p,i)=>`${i+1}. ${p||""}`);
      const rightLabels = right.map((p,i)=> right[i] ? `${i+8}. ${right[i]}` : "");
      const leftWidth = Math.max(0, ...leftLabels.map(s=>s.length));
      const pad = leftWidth + 3; // ≥ 3 spaces between columns

      const rebuilt = [];
      const newStarts = [];
      for (let i=0;i<7;i++){
        const L = leftLabels[i]  || `${i+1}. `;
        const R = rightLabels[i] || "";
        const newLine = L.padEnd(pad," ") + R;
        newStarts[i] = (i===0 ? 0 : newStarts[i-1] + rebuilt[i-1].length + 1);
        rebuilt.push(newLine);
      }
      const newText = rebuilt.join("\n");

      if (newText !== original){
        ta.value = newText;
        // Restore caret at the same logical spot inside the edited phrase
        let newCaret = selStart;
        const thisStart = newStarts[lineIdx] ?? 0;
        const newL = leftLabels[lineIdx] || `${lineIdx+1}. `;
        const newLeftPrefixLen = (newL.match(/^(\s*\d{1,2}\.\s)/)||[""])[0].length;
        const newLeftLen   = newL.length;
        const newLeftPad   = Math.max(pad, newLeftLen); // after padEnd
        if (caretIsRight){
          const rightNum = right[lineIdx] ? `${lineIdx+8}. ` : "";
          newCaret = thisStart + newLeftPad + rightNum.length
                   + Math.min(caretOffsetInPhrase, (right[lineIdx]||"").length);
        } else {
          newCaret = thisStart + newLeftPrefixLen
                   + Math.min(caretOffsetInPhrase, (left[lineIdx]||"").length);
        }
        ta.setSelectionRange(newCaret, newCaret);
      }
      // repaint highlights after normalize
      refreshSkpOverlay();
    }

    // Wire input handler: normalize columns first, then repaint highlights
    (function attachSkpInputHighlighter(){
      const ta = document.getElementById("searchKeyPhrases");
      if(!ta) return;
      ta.addEventListener("input", repadSkpColumnsPreserveCaret);
      const init = () => {
        window.skpBaseline = extractSkpPhrasesFromText(ta.value);
        repadSkpColumnsPreserveCaret();
      };
      if (document.readyState === "loading") {
        window.addEventListener("DOMContentLoaded", init);
      } else {
        init();
      }
    })();

    // --- Unify Responses/Chat return shapes (robust to either) ---
    function extractResponseText(data) {
      // 1) Responses API (direct)
      if (typeof data?.output_text === "string") return data.output_text.trim();
      if (Array.isArray(data?.output)) {
        return data.output
          .flatMap(block => Array.isArray(block?.content) ? block.content : [])
          .map(part => (typeof part?.text === "string" ? part.text : ""))
          .join("")
          .trim();
      }

      // 2) Responses API (nested under .response)
      if (typeof data?.response?.output_text === "string") return data.response.output_text.trim();
      if (Array.isArray(data?.response?.output)) {
        return data.response.output
          .flatMap(block => Array.isArray(block?.content) ? block.content : [])
          .map(part => (typeof part?.text === "string" ? part.text : ""))
          .join("")
          .trim();
      }

      // 3) Chat Completions fallback
      const chat = (data?.choices?.[0]?.message?.content || "").trim();
      if (chat) return chat;

      // 4) Last-ditch: common text fields
      for (const k of ["text", "message", "content"]) {
        const v = data?.[k];
        if (typeof v === "string" && v.trim()) return v.trim();
      }
      return "";
    }

    // Fallback description builder (≤ 400 chars; never starts with "gift for her")
    function buildFallbackDescription({ keyPhrases, rawDescription }) {
      const phrases = String(keyPhrases || "")
        .split(/\n+/)
        .map(s => s.replace(/^\d+\.\s*/, "").trim())
        .filter(Boolean);
      const head = (rawDescription || "").trim();
      const tagLine = phrases.length ? phrases.slice(0, 6).join(", ") : "";
      let desc = head
        ? head
        : `A thoughtful piece made to wear every day. Highlights: ${tagLine}. Ideal for birthdays, holidays, or a sweet gift for mom.`;
      if (desc.length > 400) desc = desc.slice(0, 397).trimEnd() + "...";
      return desc;
    }

    async function getInitialPhrases(question, keywordRules) {
      const prompt = `
    Listing Description: "${question}"

    Keyword Rules:
    ${keywordRules}

    Generate exactly 13 Etsy SEO key phrases (each ≤ 20 characters). Return as plain text, one per line.
      `.trim();

      const payload = {
        model: window.modelName,            // "gpt-5"
        input: [
          { role: "system", content: "Generate concise, varied Etsy tags. No duplicates. Each tag ≤ 20 chars." },
          { role: "user", content: prompt }
        ],
        max_output_tokens: 120,
        reasoning: { effort: "minimal" },   // light reasoning = faster/cheaper on GPT-5
        text: { verbosity: "medium" }
      };

      const data = await callOpenAI(payload);
      const answer = extractResponseText(data);
      return answer
        .split(/[\n,]+/)
        .map(s => s.replace(/^\d+\.\s*/, "").trim())
        .filter(Boolean);
    }

    async function regenerateSinglePhrase(question, keywordRules, currentValid, maxAttempts = 5) {
      for (let attempt = 1; attempt <= maxAttempts; attempt++) {
        const prompt = `
    We already have valid phrases:
    ${currentValid.join(", ")}

    Produce ONE new Etsy tag (≤ 20 chars) that is not too similar to the above.

    Listing Description: "${question}"

    Keyword Rules:
    ${keywordRules}
        `.trim();

        const payload = {
          model: window.modelName,
          input: [
            { role: "system", content: "Return ONE short tag only, no numbering, ≤ 20 chars." },
            { role: "user", content: prompt }
          ],
          max_output_tokens: 220,
          reasoning: { effort: "minimal" },
          text: { verbosity: "medium" }
        };

        const data = await callOpenAI(payload);
        const tag = extractResponseText(data).split(/[\n,]+/)[0].trim();
        if (tag && tag.length <= 20 && !currentValid.includes(tag)) return tag;
      }
      throw new Error("Could not generate a new short tag.");
    }

      async function callOpenAI(payload) {
        const res = await fetch("/.netlify/functions/openaiProxy", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload)
        });

        const text = await res.text(); // handle both JSON and plain text error bodies
        if (!res.ok) {
          let msg = text;
          try {
            const j = JSON.parse(text);
            msg = j?.error?.message || msg;
          } catch (_) { /* non-JSON error body */ }
          throw new Error("API Error: " + msg);
        }
        return JSON.parse(text);
      }

    function updateTitleCount(text) {
      document.getElementById("titleCount").textContent = "Count: " + text.length;
    }

    document.getElementById("copyTitleBtn").addEventListener("click", () => {
      let text = document.getElementById("listingTitle").value;
      navigator.clipboard.writeText(text).catch(err => console.error("Copy error:", err));
    });
    document.getElementById("copyDescriptionBtn").addEventListener("click", () => {
      let text = document.getElementById("listingDescription").value;
      navigator.clipboard.writeText(text).catch(err => console.error("Copy error:", err));
    });

    function updateTitleCount(text) {
    document.getElementById("titleCount").textContent = "Count: " + text.length;
    }

    // NEW: show/hide a heading spinner
    function toggleSpinner(elId, show) {
      const el = document.getElementById(elId);
      if (!el) return;
      el.style.display = show ? "inline-block" : "none";
      el.classList.toggle("active", !!show); // <— key: Materialize needs this
    }

    function loadReservedPhotos() {
      const stored = localStorage.getItem("reservedPhotos");
      window.reservedPhotos = stored ? JSON.parse(stored) : [];
    }
    function saveReservedPhotos() {
      localStorage.setItem("reservedPhotos", JSON.stringify(window.reservedPhotos));
    }

    async function resizeImage(dataURL, width, height) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => {
          const canvas = document.createElement("canvas");
          canvas.width = width;
          canvas.height = height;
          const ctx = canvas.getContext("2d");
          ctx.drawImage(img, 0, 0, width, height);
          resolve(canvas.toDataURL("image/jpeg", 0.85));
        };
        img.onerror = reject;
        img.src = dataURL;
      });
    }

    const dropZone = document.getElementById("dropZone");
    dropZone.addEventListener("dragover", e => {
      e.preventDefault();
      dropZone.style.borderColor = "#000";
    });
    dropZone.addEventListener("dragleave", e => {
      e.preventDefault();
      dropZone.style.borderColor = "#ccc";
    });
    dropZone.addEventListener("drop", async e => {
      e.preventDefault();
      dropZone.style.borderColor = "#ccc";
      const files = e.dataTransfer.files;
      const maxRemaining = 10 - window.previewImages.length;
      for (let i = 0; i < Math.min(files.length, maxRemaining); i++) {
        let file = files[i];
        if (/image\/(jpeg|png)/.test(file.type)) {
          try {
            const dataURL = await new Promise((resolve, reject) => {
              const reader = new FileReader();
              reader.onload = event => resolve(event.target.result);
              reader.onerror = reject;
              reader.readAsDataURL(file);
            });
            const resizedDataURL = await resizeImage(dataURL, 3000, 3000);
            window.previewImages.push(resizedDataURL);
            window.photoNames.push(file.name);
            window.photoIds.push('img-' + Date.now() + '-' + i);
          } catch (err) {
            console.error(err);
            M.toast({ html: "Error dropping image: " + err.message });
          }
        } else {
          M.toast({ html: "Only JPEG/PNG images supported." });
        }
      }
      updateStaticPreviewGrid();
    });

    function updateStaticPreviewGrid() {
      for (let i = 0; i < 10; i++) {
        let cell = document.getElementById("previewCell" + i);
        if (!cell) continue;
        cell.innerHTML = "Empty";
        if (i < 7) {
          if (i < window.previewImages.length && window.previewImages[i]) {
            cell.innerHTML = "";
            let previewBox = document.createElement("div");
            previewBox.className = "preview-box";
            previewBox.setAttribute("data-id", window.photoIds[i] || "");
            previewBox.setAttribute("draggable", "true");
            previewBox.addEventListener("dragstart", e => { window.draggedIndex = i; });
            let img = document.createElement("img");
            img.src = window.previewImages[i];
            previewBox.appendChild(img);
            let removeBtn = document.createElement("div");
            removeBtn.className = "remove-btn";
            removeBtn.textContent = "X";
            removeBtn.addEventListener("click", ev => {
              ev.stopPropagation();
              window.previewImages.splice(i, 1);
              window.photoNames.splice(i, 1);
              window.photoMeta.splice(i, 1);
              window.photoIds.splice(i, 1);
              updateStaticPreviewGrid();
            });
            previewBox.appendChild(removeBtn);
            let numOverlay = document.createElement("div");
            numOverlay.className = "number-overlay";
            numOverlay.textContent = (i + 1).toString();
            previewBox.appendChild(numOverlay);
            let cropBtn = document.createElement("button");
            cropBtn.textContent = "Crop";
            cropBtn.style.position = "absolute";
            cropBtn.style.bottom = "2px";
            cropBtn.style.right = "2px";
            cropBtn.style.width = "20px";
            cropBtn.style.height = "20px";
            cropBtn.style.borderRadius = "50%";
            cropBtn.style.backgroundColor = "green";
            cropBtn.style.color = "white";
            cropBtn.style.fontSize = "10px";
            cropBtn.addEventListener("click", ev => {
              ev.stopPropagation();
              openCropModal(i);
            });
            previewBox.appendChild(cropBtn);
            if (window.photoMeta[i] && window.photoMeta[i].trim() !== "") {
              let checkmark = document.createElement("span");
              checkmark.innerHTML = "&#10003;";
              checkmark.style.fontSize = "18px";
              checkmark.style.color = "green";
              checkmark.style.position = "absolute";
              checkmark.style.bottom = "-15px";
              checkmark.style.left = "5px";
              previewBox.appendChild(checkmark);
            }
            previewBox.addEventListener("click", () => { showMetadata(i); });
            cell.appendChild(previewBox);
            let metadataStatus = document.createElement("div");
            metadataStatus.className = "metadata-status";
            metadataStatus.id = "metadataStatus" + i;
            cell.appendChild(metadataStatus);
          } else {
            cell.innerHTML = "Empty";
            let metadataStatus = document.createElement("div");
            metadataStatus.className = "metadata-status";
            metadataStatus.id = "metadataStatus" + i;
            cell.appendChild(metadataStatus);
          }
        } else {
          let rIndex = i - 7;
          if (rIndex < window.reservedPhotos.length && window.reservedPhotos[rIndex] && window.reservedPhotos[rIndex].src) {
            cell.innerHTML = "";
            let previewBox = document.createElement("div");
            previewBox.className = "preview-box";
            previewBox.setAttribute("data-id", window.reservedPhotos[rIndex].id || "");
            previewBox.setAttribute("draggable", "true");
            previewBox.addEventListener("dragstart", e => { window.draggedIndex = i; });
            let img = document.createElement("img");
            img.src = window.reservedPhotos[rIndex].src;
            previewBox.appendChild(img);
            let removeBtn = document.createElement("div");
            removeBtn.className = "remove-btn";
            removeBtn.textContent = "X";
            removeBtn.addEventListener("click", ev => {
              ev.stopPropagation();
              window.reservedPhotos.splice(rIndex, 1);
              saveReservedPhotos();
              updateStaticPreviewGrid();
            });
            previewBox.appendChild(removeBtn);
            let numOverlay = document.createElement("div");
            numOverlay.className = "number-overlay";
            numOverlay.textContent = (i + 1).toString();
            previewBox.appendChild(numOverlay);
            previewBox.addEventListener("click", () => { showMetadata(i); });
            cell.appendChild(previewBox);
            let metadataStatus = document.createElement("div");
            metadataStatus.className = "metadata-status";
            metadataStatus.id = "metadataStatus" + i;
            cell.appendChild(metadataStatus);
          } else {
            cell.innerHTML = "Empty";
            let metadataStatus = document.createElement("div");
            metadataStatus.className = "metadata-status";
            metadataStatus.id = "metadataStatus" + i;
            cell.appendChild(metadataStatus);
          }
        }
      }
    }

    function initializeCellDragAndDrop() {
      for (let i = 0; i < 10; i++) {
        let cell = document.getElementById("previewCell" + i);
        if (!cell.dataset.listenersAttached) {
          cell.addEventListener("dragover", function(e) {
            e.preventDefault();
            this.classList.add("drag-over");
          });
          cell.addEventListener("dragleave", function(e) {
            e.preventDefault();
            this.classList.remove("drag-over");
          });
          cell.addEventListener("drop", async function(e) {
            e.preventDefault();
            this.classList.remove("drag-over");
            let cellIndex = parseInt(this.id.replace("previewCell", ""));
            if (cellIndex < 7) {
              if (window.draggedIndex !== null && window.draggedIndex !== cellIndex) {
                if (window.previewImages[window.draggedIndex]) {
                  const [movedImage] = window.previewImages.splice(window.draggedIndex, 1);
                  window.previewImages.splice(cellIndex, 0, movedImage);
                  const [movedName] = window.photoNames.splice(window.draggedIndex, 1);
                  window.photoNames.splice(cellIndex, 0, movedName);
                  const [movedMeta] = window.photoMeta.splice(window.draggedIndex, 1);
                  window.photoMeta.splice(cellIndex, 0, movedMeta);
                  const [movedId] = window.photoIds.splice(window.draggedIndex, 1);
                  window.photoIds.splice(cellIndex, 0, movedId);
                  updateStaticPreviewGrid();
                  window.draggedIndex = null;
                }
              }
            } else {
              let rIndex = cellIndex - 7;
              if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
                let file = e.dataTransfer.files[0];
                if (/image\/(jpeg|png)/.test(file.type)) {
                  const reader = new FileReader();
                  reader.onload = async ev => {
                    try {
                      const dataURL = ev.target.result;
                      const resizedDataURL = await resizeImage(dataURL, 3000, 3000);
                      let newReserved = {
                        src: resizedDataURL,
                        name: file.name,
                        meta: "",
                        id: 'img-' + Date.now()
                      };
                      window.reservedPhotos[rIndex] = newReserved;
                      saveReservedPhotos();
                      updateStaticPreviewGrid();
                    } catch (err) {
                      console.error(err);
                    }
                  };
                  reader.readAsDataURL(file);
                }
              } else if (window.draggedIndex !== null && window.draggedIndex !== cellIndex) {
                if (window.draggedIndex < 7) {
                  const [movedImage] = window.previewImages.splice(window.draggedIndex, 1);
                  const [movedName] = window.photoNames.splice(window.draggedIndex, 1);
                  const [movedMeta] = window.photoMeta.splice(window.draggedIndex, 1);
                  const [movedId] = window.photoIds.splice(window.draggedIndex, 1);
                  let newReserved = {
                    src: movedImage,
                    name: movedName,
                    meta: movedMeta || "",
                    id: movedId
                  };
                  window.reservedPhotos[rIndex] = newReserved;
                  saveReservedPhotos();
                } else {
                  let oldRIndex = window.draggedIndex - 7;
                  const [moved] = window.reservedPhotos.splice(oldRIndex, 1);
                  window.reservedPhotos[rIndex] = moved;
                  saveReservedPhotos();
                }
                updateStaticPreviewGrid();
                window.draggedIndex = null;
              }
            }
          });
          cell.dataset.listenersAttached = "true";
        }
      }
    }

    function generateRandomString(length) {
      const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
      let text = '';
      for (let i = 0; i < length; i++) {
        text += possible.charAt(Math.floor(Math.random() * possible.length));
      }
      return text;
    }
    function base64urlEncode(buffer) {
      return btoa(String.fromCharCode(...new Uint8Array(buffer)))
        .replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
    }
    async function generateCodeChallenge(codeVerifier) {
      let encoder = new TextEncoder();
      let data = encoder.encode(codeVerifier);
      let digest = await crypto.subtle.digest("SHA-256", data);
      return base64urlEncode(digest);
    }

    document.getElementById("connectEtsyBtn").addEventListener("click", async () => {
      persistDataBeforeRedirect();
      let state = "randomState123";
      let scope = "listings_w listings_r";
      let codeVerifier = generateRandomString(64);
      localStorage.setItem("etsy_code_verifier", codeVerifier);
      let codeChallenge = await generateCodeChallenge(codeVerifier);
      let etsyAuthUrl = `https://www.etsy.com/oauth/connect?response_type=code&client_id=${window.CLIENT_ID}` +
        `&redirect_uri=${encodeURIComponent(window.REDIRECT_URI)}` +
        `&scope=${encodeURIComponent(scope)}` +
        `&state=${state}` +
        `&code_challenge=${encodeURIComponent(codeChallenge)}` +
        `&code_challenge_method=S256`;
      window.location.href = etsyAuthUrl;
    });

    document.addEventListener("DOMContentLoaded", async () => {
      loadPositions();
      loadReservedPhotos();
      restoreDataAfterRedirect();
      let urlParams = new URLSearchParams(window.location.search);
      let code = urlParams.get("code");
      if (code) {
        exchangeCodeForToken(code);
        window.history.replaceState({}, document.title, window.REDIRECT_URI);
      }
      updateStaticPreviewGrid();
      initializeCellDragAndDrop();
      // Attach paste and change events to process multiple comma-separated numbers
      document.getElementById("shopListings").addEventListener("paste", (e) => {
        e.preventDefault();
        let pasteData = (e.clipboardData || window.clipboardData).getData('text');
        window.listingQueue = parseListingNumbers(pasteData);
        loadNextListingInQueue();
      });
      document.getElementById("shopListings").addEventListener("change", () => {
        let rawInput = document.getElementById("shopListings").value;
        window.listingQueue = parseListingNumbers(rawInput);
        loadNextListingInQueue();
      });
      // Pressing Enter (without Shift) will update local storage and overwrite any saved listings.
      document.getElementById("shopListings").addEventListener("keydown", (e) => {
        if (e.key === "Enter" && !e.shiftKey) {
          e.preventDefault();
          let rawInput = document.getElementById("shopListings").value;
          window.listingQueue = parseListingNumbers(rawInput);
          localStorage.setItem("listingQueue", JSON.stringify(window.listingQueue));
          loadNextListingInQueue();
        }
      });
    });

    async function exchangeCodeForToken(code) {
      let codeVerifier = localStorage.getItem("etsy_code_verifier");
      if (!codeVerifier) {
        M.toast({ html: "No code verifier found. Please try connecting again." });
        return;
      }
      try {
        let response = await fetch(`/.netlify/functions/exchangeToken?code=${encodeURIComponent(code)}&code_verifier=${encodeURIComponent(codeVerifier)}`);
        let tokenData = await response.json();
        if (tokenData.access_token) {
          window.accessToken = tokenData.access_token;
          window.etsyUserId = tokenData.user_id; // needed for Etsy v3 Bearer format
          M.toast({ html: "Connected to Etsy!" });
        } else {
          M.toast({ html: "Error obtaining token: " + JSON.stringify(tokenData) });
        }
      } catch (error) {
        console.error(error);
        M.toast({ html: "Error exchanging code for token" });
      }
    }

    function dataURLtoBlob(dataurl) {
      const arr = dataurl.split(',');
      const mime = arr[0].match(/:(.*?);/)[1];
      const bstr = atob(arr[1]);
      let n = bstr.length;
      const u8arr = new Uint8Array(n);
      while (n--) {
        u8arr[n] = bstr.charCodeAt(n);
      }
      return new Blob([u8arr], { type: mime });
    }

    document.getElementById("listingDescInput").addEventListener("keydown", async (e) => {
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        await generateTagPhrases();
      }
    });

    document.getElementById("generateBtn").addEventListener("click", async () => {
      await Promise.all([generateTitleOnly(), generateDescriptionOnly()]);
    });
    
    async function generateTitleOnly() {
      let etsyLink = window.ETSY_SHOP_URL;
      let keyPhrases = document.getElementById("searchKeyPhrases").value.trim();
      let rawDescription = document.getElementById("listingDescInput").value.trim();
      if (!keyPhrases) { M.toast({ html: "Please provide the search key phrases." }); return; }

      let rulesText = document.getElementById("titleRulesTextarea").value;
      let promptText = `
    You are ChatGPT using ${window.modelName}.
    Based on the inputs below, generate an Etsy Listing TITLE only.
    Input Context:
    Etsy Link: "${etsyLink}"
    Listing Description: "${rawDescription}"
    Key Phrases: "${keyPhrases}"
    --- Rules for TITLE ---
    ${rulesText}
    Important: Return ONLY the title as plain text.`;

        document.getElementById("listingTitle").value = "Generating title...";
        toggleSpinner("titleSpinner", true);   // NEW: show blue spinner
      const payload = {
        model: window.modelName,
        input: [
          { role: "system", content: "Return ONLY the title as plain text." },
          { role: "user", content: promptText }
        ],
        max_output_tokens: 120,
        reasoning: { effort: "minimal" },
        text: { verbosity: "medium" }
      };

      try {
        const data = await callOpenAI(payload);
        const output = extractResponseText(data);
        document.getElementById("listingTitle").value = output || "No title generated.";
        updateTitleCount(output || "");
      } catch (error) {
        const msg = (error && error.message) ? error.message : String(error);
        document.getElementById("listingTitle").value = "Error: " + msg;
        } finally {
        toggleSpinner("titleSpinner", false); // NEW: hide spinner
      }
    }

     //    Word-safe 400-char cap, no ellipsis, trims trailing punctuation/spaces.
     function capDescription(s, limit = 400) {
       const t = (s || "").trim();
       if (t.length <= limit) return t;
       let cut = t.slice(0, limit + 1);           // slight overrun gives us room to backtrack
       const lastSpace = cut.lastIndexOf(" ");
       if (lastSpace > 0) cut = cut.slice(0, lastSpace);
       return cut.replace(/[\s.,;:!?-]+$/,"");    // clean up ragged tail
     }

    async function generateDescriptionOnly() {
      let etsyLink = window.ETSY_SHOP_URL;
      let keyPhrases = document.getElementById("searchKeyPhrases").value.trim();
      let rawDescription = document.getElementById("listingDescInput").value.trim();

      if (!keyPhrases) {
        M.toast({ html: "Please provide the search key phrases." });
        return;
      }

      let rulesText = document.getElementById("descriptionRulesTextarea").value;

      let promptText = `
    You are ChatGPT using ${window.modelName}.
    Based on the inputs below, generate an Etsy Listing DESCRIPTION only.
    Input Context:
    Etsy Link: "${etsyLink}"
    Listing Description: "${rawDescription}"
    Key Phrases: "${keyPhrases}"
    --- Rules for DESCRIPTION ---
    ${rulesText}
    Important: Return ONLY the description as plain text.`.trim();

      const out = document.getElementById("listingDescription");
      out.value = "Generating description...";

      // NEW: show blue spinner beside DESCRIPTION heading
      toggleSpinner("descriptionSpinner", true);

      try {
        // Responses API payload for GPT-5
        const payload = {
          model: window.modelName, // e.g., "gpt-5"
          input: [
            { role: "system", content: "Return ONLY the description as plain text." },
            { role: "user", content: promptText }
          ],
          max_output_tokens: 350,
          reasoning: { effort: "minimal" },
          text: { verbosity: "medium" }
        };

        const data = await callOpenAI(payload);

        // Use global helper if present; otherwise unwrap Responses API locally
        let text =
          (typeof extractResponseText === "function")
            ? extractResponseText(data)
            : (
                typeof data?.output_text === "string" ? data.output_text :
                (Array.isArray(data?.output)
                  ? data.output
                      .flatMap(b => Array.isArray(b?.content) ? b.content : [])
                      .map(p => (typeof p?.text === "string" ? p.text : ""))
                      .join("")
                      .trim()
                  : (data?.choices?.[0]?.message?.content || "")
                ).trim()
              );

        text = (text || "").trim();

        // If nothing came back, build a local fallback that respects house rules
        if (!text) {
          console.warn("Empty description from API; raw response follows:", data);
          const fallback = buildFallbackDescription({ keyPhrases, rawDescription });
          text = fallback || "";
        }

         // Enforce 400-char cap without ellipsis and without cutting words
         text = capDescription(text, 400);

        out.value = text;
      } catch (error) {
        console.error(error);
        M.toast({ html: "API Error while generating description." });

        // Best-effort fallback respecting house rules
        let fallback = buildFallbackDescription({ keyPhrases, rawDescription }) || "";
        if (fallback.length > 400) fallback = fallback.slice(0, 397).trimEnd() + "...";
        out.value = fallback || ("Error: " + (error?.message || String(error)));
      } finally {
        // NEW: hide spinner once done
        toggleSpinner("descriptionSpinner", false);
      }
    }

    async function callOpenAI(payload) {
      let response = await fetch("/.netlify/functions/openaiProxy", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload)
      });
      if (!response.ok) {
        let errorData = await response.json();
        throw new Error("API Error: " + (errorData.error ? errorData.error.message : response.statusText));
      }
      let jsonData = await response.json();
      return jsonData;
    }

    function updateTitleCount(text) {
      document.getElementById("titleCount").textContent = "Count: " + text.length;
    }

    document.getElementById("copyTitleBtn").addEventListener("click", () => {
      let text = document.getElementById("listingTitle").value;
      navigator.clipboard.writeText(text).catch(err => console.error("Copy error:", err));
    });
    document.getElementById("copyDescriptionBtn").addEventListener("click", () => {
      let text = document.getElementById("listingDescription").value;
      navigator.clipboard.writeText(text).catch(err => console.error("Copy error:", err));
    });
  </script>
</body>
</html>