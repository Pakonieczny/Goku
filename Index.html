<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Etsy Listing Generator & Shop Listings</title>
  <!-- Favicon -->
  <link rel="icon" type="image/png" href="assets/favicon.png">
  <!-- Import Google Material Icons and Materialize CSS -->
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css">
  <!-- Include piexifjs for EXIF manipulation -->
  <script src="https://cdn.jsdelivr.net/npm/piexifjs@1.0.4/piexif.min.js"></script>
  <style>
    /* (CSS styles remain unchanged â€“ see your base code) */
    /* ... */
    
    /* Styles for the new Upload to Etsy button container at the bottom center */
    #uploadContainer {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: inline-block;
    }
  </style>
</head>
<body>
  <!-- Configure Buttons control -->
  <button id="configureButtonsBtn" class="btn waves-effect waves-light configurable">Configure Buttons</button>
  
  <!-- Wrap Listing Description and File Drop Zones -->
  <div id="descriptionAndFileUploadContainer">
    <div class="listing-desc-container" id="listingDescContainer">
      <h5>Listing Description</h5>
      <input id="listingDescInput" type="text" placeholder="Enter your question here">
    </div>
    <div id="fileDropZonesContainer">
      <div id="ordersContainer">
        <div id="ordersDropZone">Etsy Sold Orders</div>
        <div id="csvProgressContainer">
          <progress id="csvProgressBar" max="100" value="0"></progress>
        </div>
      </div>
      <div id="listingsDropZone">Etsy Listings</div>
      <textarea id="uploadedFilesList" class="materialize-textarea" rows="2" placeholder="Uploaded .csv/.jsonl files will appear here"></textarea>
    </div>
  </div>
  
  <!-- Etsy OAuth and Shop Listings Section -->
  <button id="connectEtsyBtn" class="btn waves-effect waves-light configurable">Connect to Etsy</button>
  <div style="margin-top: -180px; margin-left: 10px;">
    <div class="section-heading configurable">My Etsy Shop Listings</div>
    <div class="textbox-container configurable">
      <textarea id="shopListings" class="materialize-textarea"></textarea>
    </div>
  </div>
  
  <!-- Etsy Listing Generator UI -->
  <div class="phrases-header configurable" style="position: relative; top: 125px; left: 10px;">
    <span class="section-heading configurable">2. User Provided Search Key Phrases</span>
    <button id="clearKeyPhrasesBtn" class="btn-small waves-effect waves-light configurable">Clear</button>
    <button id="copyKeyPhrasesBtn" class="btn-small waves-effect waves-light configurable">Copy</button>
    <div id="dropZone" class="configurable">Drop Image Here</div>
    <div id="primaryPreview" class="configurable"></div>
    <button id="analyzeMetadataBtn" class="btn waves-effect waves-light configurable">Analyze Photos</button>
    <button id="showAnalyzeRulesBtn" class="btn waves-effect waves-light configurable" data-target="analyzeRulesModal" style="margin-top:25px;">Analyze Rules</button>
  </div>
  <div id="container13" class="flex-container configurable">
    <div class="textbox-container configurable">
      <textarea id="searchKeyPhrases" class="materialize-textarea" rows="14"></textarea>
    </div>
  </div>
  
  <!-- Components below Search Key Phrases -->
  <div id="belowSearch">
    <button id="generateBtn" class="btn waves-effect waves-light configurable">Generate</button>
    <div class="title-container" style="margin-top: -50px;">
      <div class="section-heading configurable">Etsy Listing TITLE</div>
      <div class="flex-container configurable">
        <div class="textbox-container configurable">
          <textarea id="listingTitle" class="materialize-textarea" rows="2"></textarea>
        </div>
        <div class="button-container configurable" style="margin-top: -60px;">
          <button id="regenTitleBtn" class="btn-small waves-effect waves-light configurable">Re-Generate</button>
          <button id="copyTitleBtn" class="btn-small waves-effect waves-light configurable">
            <i class="material-icons">content_copy</i>
          </button>
        </div>
        <button id="showTitleRulesBtn" class="btn waves-effect waves-light rules-button configurable" data-target="titleRulesModal">Title Rules</button>
      </div>
      <p id="titleCount" class="count-text configurable">Count: 0</p>
    </div>
    <div class="description-container" style="margin-top: 0px;">
      <div class="section-heading configurable">Etsy Listing DESCRIPTION</div>
      <div class="flex-container configurable">
        <div class="textbox-container configurable">
          <textarea id="listingDescription" class="materialize-textarea"></textarea>
        </div>
        <div class="button-container configurable">
          <button id="regenDescriptionBtn" class="btn-small waves-effect waves-light configurable">Re-Generate</button>
          <button id="copyDescriptionBtn" class="btn-small waves-effect waves-light configurable">
            <i class="material-icons">content_copy</i>
          </button>
        </div>
        <button id="showDescriptionRulesBtn" class="btn waves-effect waves-light rules-button configurable" data-target="descriptionRulesModal">Description Rules</button>
      </div>
    </div>
  </div>
  
  <!-- Preview Grid Container -->
  <div id="previewGridContainer">
    <div id="previewGrid"></div>
  </div>
  
  <!-- New Upload to Etsy button container -->
  <div id="uploadContainer">
    <button id="uploadToEtsyBtn" class="btn waves-effect waves-light configurable">Upload to Etsy</button>
  </div>
  
  <!-- Modals (Title Rules, Description Rules, Analyze Rules, Keyword Rules, Button Config, Metadata, Crop) -->
  <!-- (Modal content remains similar to your previous version) -->
  
  <!-- Include jQuery and Materialize JS -->
  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js"></script>
  
  <script>
    // Global variable declarations
    const ETSY_SHOP_URL = "https://www.etsy.com/shop/custombrites";
    const CLIENT_ID = "k75zdspz4r99txpqdji7i2em";
    const REDIRECT_URI = "https://delicate-tanuki-616ac0.netlify.app/";
    const SHOP_ID = "YOUR_ASSISTANT_ID"; // Replace if you have a numeric shop ID.
    const modelName = "chatgpt-4o-latest";
    let accessToken;
    
    // Reintroduce missing global variables
    let soldOrdersCSV = [];
    let listingsCSV = [];
    let photoNames = [];
    let previewImages = [];
    let photoStatuses = [];
    let photoMeta = [];
    let photoObjects = [];
    
    // All OpenAI API calls are proxied via Netlify functions
    async function callOpenAI(payload) {
      const response = await fetch("/.netlify/functions/openaiProxy", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload)
      });
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error("API Error: " + (errorData.error ? errorData.error.message : response.statusText));
      }
      const data = await response.json();
      return data;
    }
    
    // File upload functions now use our Netlify function "uploadFile"
    async function uploadCSVFile(file, progressCallback) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = async (event) => {
          try {
            // Read file as text (works for CSV or JSONL)
            const textContent = event.target.result;
            if (!textContent.trim()) {
              throw new Error("File content is empty. Please check your file structure.");
            }
            // Encode text content in Base64
            const base64Content = btoa(unescape(encodeURIComponent(textContent)));
            const payload = {
              file: base64Content,
              fileName: file.name,
              purpose: "fine-tune"
            };
            const response = await fetch("/.netlify/functions/uploadFile", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(payload)
            });
            if (!response.ok) {
              throw new Error("Upload failed with status " + response.status);
            }
            const responseData = await response.json();
            resolve({ id: responseData.id, name: responseData.filename });
          } catch (err) {
            reject(err);
          }
        };
        reader.onerror = reject;
        reader.readAsText(file);
      });
    }
    
    async function uploadDocFile(file, progressCallback) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = async (event) => {
          try {
            const base64Content = event.target.result.split(',')[1];
            const payload = {
              file: base64Content,
              fileName: file.name,
              purpose: "fine-tune"
            };
            const response = await fetch("/.netlify/functions/uploadFile", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(payload)
            });
            if (!response.ok) {
              throw new Error("Upload failed with status " + response.status);
            }
            const responseData = await response.json();
            resolve({ id: responseData.id, name: responseData.filename });
          } catch (err) {
            reject(err);
          }
        };
        reader.onerror = reject;
        reader.readAsDataURL(file);
      });
    }
    
    // PKCE Utility Functions
    function generateRandomString(length) {
      const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~';
      let text = '';
      for (let i = 0; i < length; i++) {
        text += possible.charAt(Math.floor(Math.random() * possible.length));
      }
      return text;
    }
    function base64urlEncode(buffer) {
      return btoa(String.fromCharCode(...new Uint8Array(buffer)))
        .replace(/\+/g, '-')
        .replace(/\//g, '_')
        .replace(/=+$/, '');
    }
    async function generateCodeChallenge(codeVerifier) {
      const encoder = new TextEncoder();
      const data = encoder.encode(codeVerifier);
      const digest = await crypto.subtle.digest("SHA-256", data);
      return base64urlEncode(digest);
    }
    
    // OAuth Flow for Etsy
    document.getElementById("connectEtsyBtn").addEventListener("click", async () => {
      const state = "randomState123";
      const scope = "listings_w listings_r";
      const codeVerifier = generateRandomString(64);
      localStorage.setItem("etsy_code_verifier", codeVerifier);
      const codeChallenge = await generateCodeChallenge(codeVerifier);
      const etsyAuthUrl = `https://www.etsy.com/oauth/connect?response_type=code&client_id=${CLIENT_ID}` +
        `&redirect_uri=${encodeURIComponent(REDIRECT_URI)}` +
        `&scope=${encodeURIComponent(scope)}` +
        `&state=${state}` +
        `&code_challenge=${encodeURIComponent(codeChallenge)}` +
        `&code_challenge_method=S256`;
      window.location.href = etsyAuthUrl;
    });
    
    document.addEventListener("DOMContentLoaded", () => {
      const urlParams = new URLSearchParams(window.location.search);
      const code = urlParams.get("code");
      if (code) {
        exchangeCodeForToken(code);
        window.history.replaceState({}, document.title, REDIRECT_URI);
      }
      renderPreviewGrid();
      loadButtonPositions();
      updateUploadedFilesList();
    });
    
    async function exchangeCodeForToken(code) {
      const codeVerifier = localStorage.getItem("etsy_code_verifier");
      if (!codeVerifier) {
        M.toast({ html: "No code verifier found. Please try connecting again." });
        return;
      }
      try {
        const response = await fetch(`/.netlify/functions/exchangeToken?code=${encodeURIComponent(code)}&code_verifier=${encodeURIComponent(codeVerifier)}`);
        const tokenData = await response.json();
        if (tokenData.access_token) {
          accessToken = tokenData.access_token;
          M.toast({ html: "Connected to Etsy!" });
        } else {
          M.toast({ html: "Error obtaining token: " + JSON.stringify(tokenData) });
        }
      } catch (error) {
        console.error("Error exchanging code:", error);
        M.toast({ html: "Error exchanging code for token" });
      }
    }
    
    async function duplicateListing() {
      let listingLink = document.getElementById("shopListings").value.trim();
      console.log("Listing Link:", listingLink);
      if (!listingLink) {
        M.toast({ html: "Please provide a listing link in 'My Etsy Shop Listings'" });
        return;
      }
      let listingIdMatch = listingLink.match(/\/listing\/(\d+)/);
      if (!listingIdMatch) {
        M.toast({ html: "Invalid listing link. Please provide a valid Etsy listing URL." });
        console.log("Regex did not match listing link.");
        return;
      }
      let listingId = listingIdMatch[1];
      console.log("Extracted Listing ID:", listingId);
      if (!accessToken) {
        M.toast({ html: "No access token. Please connect to Etsy first." });
        return;
      }
      try {
        console.log("Fetching listing details for listing ID:", listingId);
        let getUrl = `https://api.etsy.com/v3/application/listings/${listingId}`;
        let getResponse = await fetch(getUrl, {
          method: "GET",
          headers: { "Authorization": `Bearer ${accessToken}` }
        });
        if (!getResponse.ok) {
          throw new Error("Error fetching listing details: " + getResponse.statusText);
        }
        let listingData = await getResponse.json();
        console.log("Fetched listing data:", listingData);
        let payload = {
          quantity: listingData.quantity || 1,
          title: listingData.title || "Duplicated Listing",
          description: listingData.description || "",
          price: listingData.price || 0,
          who_made: listingData.who_made || "i_did",
          when_made: listingData.when_made || "made_to_order",
          taxonomy_id: listingData.taxonomy_id || 0
        };
        console.log("Payload for new listing:", payload);
        let postUrl = `https://api.etsy.com/v3/application/shops/${SHOP_ID}/listings`;
        let postResponse = await fetch(postUrl, {
          method: "POST",
          headers: {
            "Content-Type": "application/x-www-form-urlencoded",
            "Authorization": `Bearer ${accessToken}`
          },
          body: new URLSearchParams(payload)
        });
        if (!postResponse.ok) {
          throw new Error("Error duplicating listing: " + postResponse.statusText);
        }
        let newListingData = await postResponse.json();
        M.toast({ html: "Listing duplicated as Draft successfully!" });
        console.log("Duplicated Listing:", newListingData);
      } catch(e) {
        console.error(e);
        M.toast({ html: "Error duplicating listing: " + e.message });
      }
    }
    
    document.getElementById("uploadToEtsyBtn").addEventListener("click", duplicateListing);
    
    document.getElementById("clearKeyPhrasesBtn").addEventListener("click", () => {
      document.getElementById("searchKeyPhrases").value = "";
    });
    
    // Drop zone and file upload event handlers
    const dropZone = document.getElementById("dropZone");
    const previewGrid = document.getElementById("previewGrid");
    const primaryPreview = document.getElementById("primaryPreview");
    
    function updatePrimaryPreview() {
      if (previewImages.length > 0) {
        primaryPreview.innerHTML = `<img src="${previewImages[0]}" alt="Primary Preview">`;
      } else { 
        primaryPreview.innerHTML = ""; 
      }
    }
    
    primaryPreview.addEventListener("click", function() {
      if (previewImages.length > 0) {
        document.getElementById("cropImage").src = previewImages[0];
        let cropModalElem = document.getElementById("photoCropModal");
        let cropModalInstance = M.Modal.getInstance(cropModalElem);
        if (!cropModalInstance) {
          cropModalInstance = M.Modal.init(cropModalElem, { preventScrolling: false });
        }
        cropModalInstance.open();
      }
    });
    
    dropZone.addEventListener("dragover", e => { 
      e.preventDefault(); 
      e.stopPropagation(); 
      dropZone.style.borderColor = "#000"; 
    });
    dropZone.addEventListener("dragleave", e => { 
      e.preventDefault(); 
      e.stopPropagation(); 
      dropZone.style.borderColor = "#ccc"; 
    });
    dropZone.addEventListener("drop", async e => {
      e.preventDefault(); 
      e.stopPropagation(); 
      dropZone.style.borderColor = "#ccc";
      const files = e.dataTransfer.files;
      if (files.length > 10) { alert("Maximum 10 images allowed."); }
      for (let i = 0; i < Math.min(files.length, 10); i++) {
        const file = files[i];
        if (file.type === "image/jpeg" || file.type === "image/png") {
          try {
            const dataURL = await processUploadedImage(file);
            previewImages.push(dataURL);
            photoStatuses.push(null);
            photoMeta.push(null);
            photoNames.push(file.name);
            updatePrimaryPreview();
            renderPreviewGrid();
            updateUploadedFilesList();
          } catch (err) { console.error("Error processing image:", err); }
        } else {
          M.toast({ html: "Only JPEG images are supported for metadata embedding." });
        }
      }
    });
    
    const ordersDropZone = document.getElementById("ordersDropZone");
    ordersDropZone.addEventListener("dragover", e => { 
      e.preventDefault(); 
      e.stopPropagation(); 
      ordersDropZone.style.borderColor = "#000"; 
    });
    ordersDropZone.addEventListener("dragleave", e => { 
      e.preventDefault(); 
      e.stopPropagation(); 
      ordersDropZone.style.borderColor = "#ccc"; 
    });
    ordersDropZone.addEventListener("drop", async e => {
      e.preventDefault(); 
      e.stopPropagation(); 
      ordersDropZone.style.borderColor = "#ccc";
      const files = e.dataTransfer.files;
      const progressBar = document.getElementById("csvProgressBar");
      for (let i = 0; i < files.length; i++) {
         let file = files[i];
         const fileName = file.name.toLowerCase();
         if (fileName.endsWith(".csv") || fileName.endsWith(".jsonl") || fileName.endsWith(".doc") || fileName.endsWith(".docx")) {
            try {
              let fileData;
              if (fileName.endsWith(".csv") || fileName.endsWith(".jsonl")) {
                 fileData = await uploadCSVFile(file, percent => { progressBar.value = percent; });
              } else {
                 fileData = await uploadDocFile(file, percent => { progressBar.value = percent; });
              }
              progressBar.value = 0;
              soldOrdersCSV.push(fileData);
              console.log("Uploaded Sold Orders file:", fileData);
              updateUploadedFilesList();
              await updateAssistantWithCSVFiles();
            } catch(err) { console.error("Error uploading file:", err); }
         } else {
            alert("Only .csv, .jsonl, .doc, and .docx files are supported for Etsy Sold Orders.");
         }
      }
    });
    
    const listingsDropZone = document.getElementById("listingsDropZone");
    listingsDropZone.addEventListener("dragover", e => { 
      e.preventDefault(); 
      e.stopPropagation(); 
      listingsDropZone.style.borderColor = "#000"; 
    });
    listingsDropZone.addEventListener("dragleave", e => { 
      e.preventDefault(); 
      e.stopPropagation(); 
      listingsDropZone.style.borderColor = "#ccc"; 
    });
    listingsDropZone.addEventListener("drop", async e => {
      e.preventDefault(); 
      e.stopPropagation(); 
      listingsDropZone.style.borderColor = "#ccc";
      const files = e.dataTransfer.files;
      const progressBar = document.getElementById("csvProgressBar");
      for (let i = 0; i < files.length; i++) {
         let file = files[i];
         const fileName = file.name.toLowerCase();
         if (fileName.endsWith(".csv") || fileName.endsWith(".jsonl") || fileName.endsWith(".doc") || fileName.endsWith(".docx")) {
            try {
              let fileData;
              if (fileName.endsWith(".csv") || fileName.endsWith(".jsonl")) {
                 fileData = await uploadCSVFile(file, percent => { progressBar.value = percent; });
              } else {
                 fileData = await uploadDocFile(file, percent => { progressBar.value = percent; });
              }
              progressBar.value = 0;
              listingsCSV.push(fileData);
              console.log("Uploaded Listings file:", fileData);
              updateUploadedFilesList();
              await updateAssistantWithCSVFiles();
            } catch(err) { console.error("Error uploading file:", err); }
         } else {
            alert("Only .csv, .jsonl, .doc, and .docx files are supported for Etsy Listings.");
         }
      }
    });
    
    async function updateAssistantWithCSVFiles() {
      const allFileIds = [...soldOrdersCSV, ...listingsCSV].map(file => file.id);
      if(allFileIds.length === 0) {
        console.log("No files uploaded yet.");
        return;
      }
      try {
        const vectorStorePayload = { name: "CSV Vector Store", file_ids: allFileIds };
        const vectorStoreResponse = await fetch("/.netlify/functions/vectorStore", {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify(vectorStorePayload)
        });
        if (!vectorStoreResponse.ok) {
          const errorData = await vectorStoreResponse.json();
          throw new Error("Error creating vector store: " + (errorData.error ? errorData.error.message : vectorStoreResponse.statusText));
        }
        const vectorStoreData = await vectorStoreResponse.json();
        console.log("Created Vector Store:", vectorStoreData);
        const updatePayload = { tool_resources: { file_search: { vector_store_ids: [vectorStoreData.id] } } };
        const assistantUpdateResponse = await fetch("/.netlify/functions/updateAssistant", {
          method: "PATCH",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify(updatePayload)
        });
        if (!assistantUpdateResponse.ok) {
          const errorData = await assistantUpdateResponse.json();
          throw new Error("Error updating assistant: " + (errorData.error ? errorData.error.message : assistantUpdateResponse.statusText));
        }
        const updatedAssistantData = await assistantUpdateResponse.json();
        console.log("Updated Assistant with File Search:", updatedAssistantData);
      } catch (err) {
        console.error("Error in updateAssistantWithCSVFiles:", err);
      }
    }
    
    function updateUploadedFilesList() {
      let fileList = [];
      soldOrdersCSV.forEach(file => {
        if (file.name.toLowerCase().endsWith(".csv") || file.name.toLowerCase().endsWith(".jsonl")) {
          fileList.push(file.name);
        }
      });
      listingsCSV.forEach(file => {
        if (file.name.toLowerCase().endsWith(".csv") || file.name.toLowerCase().endsWith(".jsonl")) {
          fileList.push(file.name);
        }
      });
      document.getElementById("uploadedFilesList").value = fileList.join("\n");
      const modalTextarea = document.getElementById("uploadedFilesListModal");
      if(modalTextarea){
        modalTextarea.value = fileList.join("\n");
      }
    }
    
    document.getElementById("listingDescInput").addEventListener("input", function() {
      console.log("Listing Description input changed. Resetting key phrase state.");
      document.getElementById("searchKeyPhrases").value = "";
    });
    
    window.addEventListener("load", function() {
      var container13 = document.getElementById("container13");
      var originalHeight = container13.offsetHeight;
      container13.style.height = (originalHeight * 2.5) + "px";
    });
    
    // Utility: Strip Markdown formatting from JSON responses.
    function stripMarkdownJSON(text) { 
      return text.replace(/^```json\s*/, "").replace(/\s*```$/, "").trim(); 
    }
    
    function updateTitleCount(text) { 
      document.getElementById("titleCount").textContent = "Count: " + text.length; 
    }
    
    // Functions for generating title, description, and tag phrases via OpenAI proxy.
    async function generateBoth() {
      await Promise.all([generateTitleOnly(), generateDescriptionOnly()]);
      const titleEl = document.getElementById("listingTitle");
      const descEl = document.getElementById("listingDescription");
      const output = { title: titleEl.value, description: descEl.value };
      console.log("Generate Output:", output);
    }
    
    async function generateTitleOnly() {
      const etsyLink = ETSY_SHOP_URL;
      const keyPhrases = document.getElementById("searchKeyPhrases").value.trim();
      if (!keyPhrases) { 
        M.toast({ html: "Please provide the search key phrases." }); 
        return; 
      }
      const promptText = `
You are ChatGPT using ${modelName}.
Based on the inputs below, generate an Etsy Listing TITLE only.
Input Context:
Etsy Link: "${etsyLink}"
Search Key Phrases: "${keyPhrases}"
--- Rules for TITLE ---
${stripMarkdownJSON(document.getElementById("titleRulesTextarea").value)}
Important: Return ONLY the title as plain text.`;
      document.getElementById("listingTitle").value = "Generating title...";
      const payload = {
        model: modelName,
        messages: [
          { role: "system", content: "Return ONLY the title as plain text." },
          { role: "user", content: promptText }
        ],
        temperature: 0.7
      };
      try {
        const data = await callOpenAI(payload);
        if (data.choices && data.choices.length > 0) {
          let output = stripMarkdownJSON(data.choices[0].message.content);
          document.getElementById("listingTitle").value = output || "No title generated.";
          updateTitleCount(document.getElementById("listingTitle").value);
        } else {
          document.getElementById("listingTitle").value = "No title generated.";
        }
      } catch (error) {
        document.getElementById("listingTitle").value = "Error: " + error;
      }
    }
    
    async function generateDescriptionOnly() {
      const etsyLink = ETSY_SHOP_URL;
      const keyPhrases = document.getElementById("searchKeyPhrases").value.trim();
      if (!keyPhrases) { 
        M.toast({ html: "Please provide the search key phrases." }); 
        return; 
      }
      const promptText = `
You are ChatGPT using ${modelName}.
Based on the inputs below, generate an Etsy Listing DESCRIPTION only.
Input Context:
Etsy Link: "${etsyLink}"
Search Key Phrases: "${keyPhrases}"
--- Rules for DESCRIPTION ---
${stripMarkdownJSON(document.getElementById("descriptionRulesTextarea").value)}
Important: Return ONLY the description as plain text.`;
      document.getElementById("listingDescription").value = "Generating description...";
      const payload = {
        model: modelName,
        messages: [
          { role: "system", content: "Return ONLY the description as plain text." },
          { role: "user", content: promptText }
        ],
        temperature: 0.7
      };
      try {
        const data = await callOpenAI(payload);
        if (data.choices && data.choices.length > 0) {
          let output = stripMarkdownJSON(data.choices[0].message.content);
          document.getElementById("listingDescription").value = output || "No description generated.";
        } else {
          document.getElementById("listingDescription").value = "No description generated.";
        }
      } catch (error) {
        document.getElementById("listingDescription").value = "Error: " + error;
      }
    }
    
    async function generateTagPhrases() {
      let question = document.getElementById("listingDescInput").value;
      if (!question.trim()) {
        M.toast({ html: "Please enter a question in the Listing Description." });
        return;
      }
      let listingDescription = question;
      let extraText = "Emphasis on SEO friendliness with a focus on generating the most effective long tail tag phrases for Etsy.";
      let soldOrdersInfo = soldOrdersCSV.map(item => `Filename: ${item.name}, FileID: ${item.id}`).join("\n");
      let listingsInfo = listingsCSV.map(item => `Filename: ${item.name}, FileID: ${item.id}`).join("\n");
      const keywordRules = stripMarkdownJSON(document.getElementById("keywordRulesTextarea").value);
      let prompt = `
Listing Description (for emphasis): "${listingDescription}"
${extraText}

Keyword Rules:
${keywordRules}
      
Using the Sales Report and Product List Files, extrapolate the best tag phrases.
Generate exactly 13 separate tag phrases, each â‰¤ 20 characters.
Include "Gift for Her" and ensure "Charm" appears at least once in a multi-word phrase (max 4 times total).
"Necklace" must appear â‰¤ 3 times, "Gift" â‰¤ 3 times, "Lover" â‰¤ 2 times.
Exclude: "Gift for Him", "Statement Piece", "Unique", "Spiritual Gift", "Outdoor Style", "accessories", "simple", "minimalist", "whimsical", "cute", "filled", "gold filled", "silver", "solid gold", "gold vermeil", "rosegold", "14k", "handmade", "quirky", "delicate", "accessory", "for", "dangle", "gold plated", "jewelry", "custom", "celestial", "design", "lightweight", "Fine Chain Necklace", "Small", "Large", "Nice", "Long", "Dark", "Short", "and", "but", "light", "heavy", "Wanderlust", "Theme", "Minimal Chain Gift", "Tiny Pendant Chain", "Charm Look", "Charm Wear", "Chain Necklace", "Small Pendant Chain", "Everyday"
Return your answer as plain text.
      `;
      try {
        const payload = {
          model: modelName,
          messages: [
            { role: "system", content: "Generate tag phrases according to the provided rules." },
            { role: "user", content: prompt }
          ],
          temperature: 0.7,
          max_tokens: 500
        };
        const data = await callOpenAI(payload);
        let answer = data.choices[0].message.content;
        let phrases = answer.split(/[\n,]+/)
          .map(s => s.replace(/^\d+\.\s*/, "").trim())
          .join("\n");
        document.getElementById("searchKeyPhrases").value = phrases;
      } catch (err) {
        console.error("Error generating tag phrases:", err);
        M.toast({ html: "Error generating tag phrases: " + err.message });
      }
    }
    
    document.getElementById("listingDescInput").addEventListener("keydown", async function(e) {
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        console.log("Enter key pressed in listingDescInput");
        await generateTagPhrases();
        await delay(100);
        await processKeyPhrases();
      }
    });
    
    async function processKeyPhrases() {
      let keyText = document.getElementById("searchKeyPhrases").value;
      let phrases = keyText.split(/\n+/)
        .map(phrase => phrase.trim())
        .filter(phrase => phrase !== "");
      
      let processedPhrases = [];
      for (let i = 0; i < phrases.length; i++) {
        let phrase = phrases[i];
        while (phrase.length > 20) {
          try {
            const altPayload = {
              model: modelName,
              messages: [
                { role: "system", content: "Generate an alternate key phrase that is â‰¤ 20 characters." },
                { role: "user", content: phrase }
              ],
              temperature: 0.7,
              max_tokens: 20
            };
            const altData = await callOpenAI(altPayload);
            let altPhrase = stripMarkdownJSON(altData.choices[0].message.content).trim();
            phrase = altPhrase;
          } catch (error) {
            console.error("Error generating alternate key phrase:", error);
            break;
          }
          await delay(50);
        }
        while (processedPhrases.includes(phrase)) {
          try {
            const dupPayload = {
              model: modelName,
              messages: [
                { role: "system", content: "Generate a unique key phrase that is â‰¤ 20 characters." },
                { role: "user", content: phrase }
              ],
              temperature: 0.7,
              max_tokens: 20
            };
            const dupData = await callOpenAI(dupPayload);
            let dupPhrase = stripMarkdownJSON(dupData.choices[0].message.content).trim();
            phrase = dupPhrase;
          } catch (error) {
            console.error("Error generating alternate for duplicate key phrase:", error);
            break;
          }
          await delay(50);
        }
        processedPhrases.push(phrase);
        document.getElementById("searchKeyPhrases").value = processedPhrases.join("\n");
        await delay(50);
      }
    }
    
    document.getElementById("copyKeyPhrasesBtn").addEventListener("click", () => {
      let lines = document.getElementById("searchKeyPhrases").value.split(/\n+/).map(l => l.trim()).filter(l => l !== "");
      const formatted = lines.join(", ");
      navigator.clipboard.writeText(formatted).catch(err => console.error("Error copying key phrases: " + err));
    });
    
    document.getElementById("generateBtn").addEventListener("click", generateBoth);
    document.getElementById("regenTitleBtn").addEventListener("click", generateTitleOnly);
    document.getElementById("regenDescriptionBtn").addEventListener("click", generateDescriptionOnly);
    document.getElementById("copyTitleBtn").addEventListener("click", () => {
      const titleText = document.getElementById("listingTitle").value;
      navigator.clipboard.writeText(titleText).catch(err => console.error("Error copying title: " + err));
    });
    document.getElementById("copyDescriptionBtn").addEventListener("click", () => {
      const descText = document.getElementById("listingDescription").value;
      navigator.clipboard.writeText(descText).catch(err => console.error("Error copying description: " + err));
    });
    
    document.getElementById("configureButtonsBtn").addEventListener("click", function() {
      var configContainer = document.getElementById("buttonConfigContainer");
      configContainer.innerHTML = "";
      var selectors = "button:not(#configureButtonsBtn), #listingDescContainer, #ordersDropZone, #listingsDropZone, #dropZone, #csvProgressContainer, #previewGridContainer, #primaryPreview, #container13, #uploadedFilesList";
      var elements = document.querySelectorAll(selectors);
      var table = document.createElement("table");
      table.className = "striped";
      var thead = document.createElement("thead");
      thead.innerHTML = "<tr><th>Element ID</th><th>Top (px)</th><th>Left (px)</th></tr>";
      table.appendChild(thead);
      var tbody = document.createElement("tbody");
      elements.forEach(function(el) {
        var id = el.id;
        var currentTop = el.style.top || "0";
        var currentLeft = el.style.left || "0";
        var tr = document.createElement("tr");
        tr.innerHTML = `<td>${id}</td>
                        <td><input type="number" id="${id}_top" value="${parseInt(currentTop)||0}"></td>
                        <td><input type="number" id="${id}_left" value="${parseInt(currentLeft)||0}"></td>`;
        var topInput = tr.querySelector(`#${id}_top`);
        var leftInput = tr.querySelector(`#${id}_left`);
        topInput.addEventListener("input", function() { el.style.top = topInput.value + "px"; });
        leftInput.addEventListener("input", function() { el.style.left = leftInput.value + "px"; });
        tbody.appendChild(tr);
      });
      table.appendChild(tbody);
      configContainer.appendChild(table);
      var modalElem = document.getElementById("buttonConfigModal");
      var modalInstance = M.Modal.getInstance(modalElem);
      if (!modalInstance) { 
        modalInstance = M.Modal.init(modalElem, { preventScrolling: false }); 
      }
      modalInstance.open();
    });
    
    document.getElementById("saveButtonPositionsBtn").addEventListener("click", function() {
      var selectors = "button:not(#configureButtonsBtn), #listingDescContainer, #ordersDropZone, #listingsDropZone, #dropZone, #csvProgressContainer, #previewGridContainer, #primaryPreview, #container13, #uploadedFilesList";
      var elements = document.querySelectorAll(selectors);
      var positions = {};
      elements.forEach(function(el) {
        var id = el.id;
        var topVal = document.getElementById(id + "_top").value;
        var leftVal = document.getElementById(id + "_left").value;
        positions[id] = { top: topVal + "px", left: leftVal + "px" };
        el.style.top = topVal + "px";
        el.style.left = leftVal + "px";
      });
      localStorage.setItem("buttonPositions", JSON.stringify(positions));
    });
    
    function loadButtonPositions() {
      var stored = localStorage.getItem("buttonPositions");
      if (stored) {
        var positions = JSON.parse(stored);
        for (var id in positions) {
          var el = document.getElementById(id);
          if (el) { 
            el.style.top = positions[id].top; 
            el.style.left = positions[id].left; 
          }
        }
      }
    }
    
    window.addEventListener("load", function() {
      var container13 = document.getElementById("container13");
      var originalHeight = container13.offsetHeight;
      container13.style.height = (originalHeight * 2.5) + "px";
    });
    
    document.getElementById("listingDescInput").addEventListener("input", function() {
      console.log("Listing Description input changed. Resetting key phrase state.");
      document.getElementById("searchKeyPhrases").value = "";
    });
  </script>
</body>
</html>