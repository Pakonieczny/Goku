<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>Sorting - Single-Click Zoom</title>
  <!-- Materialize CSS -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css" />
  <style>
    body {
      background-color: #fff;
      margin: 0;
      height: 100vh;
      position: relative;
      opacity: 0;
      transition: opacity 0s;
    }
    /* Main Buttons */
    #connectEtsyBtn, 
    #openConfigBtn {
      position: absolute;
      left: 20px;
      width: 140px;
      height: 36px;
    }
    #connectEtsyBtn {
      top: 20px;
    }
    #openConfigBtn {
      top: 120px;
    }

    /* Etsy Order Number input */
    #etsyOrderNumber {
      position: absolute;
      left: 20px;
      top: 270px;
      width: 300px;
      height: 30px;
      border: 1px solid #999;
      padding: 4px;
      outline: none;
      font-size: 0.9em;
    }

    .loadingTxt{
      color:#2196F3;          /* same blue as spinner + hover outline */
    }

    /* wrapper holds spinner + text and centres them */
    .loadingWrap{
      display:inline-flex;
      align-items:center;      /* vertical centring */
      gap:6px;                 /* keeps the space you had */
    }

    .metal-counter{
      position:absolute;
      font-size:0.8em;             /* ‚Üê 0 .8 em */
      background:#fff9c4;
      padding:4px 8px;
      border:1px solid #999;
    }

    /* spinner keeps its blue look & spin */
    @keyframes btnSpin{100%{transform:rotate(360deg)}}
    .spinner{
      width:18px;height:18px;
      border:3px solid transparent;border-top-color:#2196F3;border-radius:50%;
      animation:btnSpin .7s linear infinite;
    }
    .loadingTxt{color:#2196F3;}

    /* Image Comparison UI */
    #imageComparisonContainer {
      position: absolute;
      left: 20px;
      top: 310px;
    }

    /* --- Update-Order-List button --- */
    #updateOrderListBtn {
      position: absolute;
      left: 20px;
      top: 170px;           /* 50 px below ‚ÄúOpen Config‚Äù */
      width: 160px;
      height: 36px;
    }


    /* ‚îÄ‚îÄ‚îÄ Header-bar chevrons ‚îÄ‚îÄ‚îÄ */
    #orderHeaderBar .chev{
      font-size:66%;          /* 33 % smaller */
      line-height:0.85em;
      display:inline-block;
      vertical-align:middle;
    }

    /* listing-detail modal layout */
    .modal-flex-row{
      display:flex;
      align-items:flex-start;
    }

/* column wrapper ‚Äì sits 20 px right of the image */
.modal-notes-col{
  margin-left:20px;
  display:flex;
  flex-direction:column;
}

/* remove old left-margin so notes align with input */
.modal-notes-col #modalListingNotes{ margin:0; }

/* staff-note field */
#modalStaffNote{
  width:300px;
  height:35px;
  margin-top:40px;
  padding:4px;
  border:1px solid #999;
}

    /* fixed thumbnail size, border stays */
    #modalListingImg{
      width:200px;
      height:200px;
      object-fit:cover;
      border:1px solid #ccc;
    }

    #modalListingNotes{
      display:block;
      width:300px;              /* initial; user can drag to resize */
      height:120px;             /* initial; user can drag to resize */
      margin:0 0 0 20px;
      padding:8px;
      background:#f5f5f5;
      border:1px solid #ccc;
      border-radius:4px;
      resize: both;             /* ‚Üê enable corner dragging horizontally & vertically */
      overflow: auto;           /* scrollbars appear when needed */
      line-height:1.2;
      font-family: inherit;
      font-size: .95em;
      /* intentionally no flex:1 so manual width/height changes persist */
    }

    /* --- Container that holds the stacked ‚ÄúnewOrder‚Äù boxes --- */
    #newOrderContainer {
      position: absolute;
      left: 20px;
      top: 236px;          /* 30 px below the 206 px bottom of Update-Order button */
      width: 318px;
      height: 800px;       /* scrollable window */
      overflow-y: auto;
      border: 1px dashed #bbb;
      padding: 4px;
      background: #fafafa;
    }

    /* active metal counter = blue 3 px outline */
    .metal-counter.active{ outline:3px solid #2196f3; }

    /* 3-px orangered flag for personalization / buyer-message */
    .preview-attn{
      outline:none;
      box-shadow:0 0 0 4px orangered;
    }

    .new-order-box {
      position: relative;

      /* 1 ‚ñ∏ make it a grid, not flex */
      display: grid;                 /* üî∏ REPLACES display:flex */

      /* 2 ‚ñ∏ give each column its exact width */
      grid-template-columns: 103px 67px 25px 25px 25px 25px;

      /* optional overall breathing room between columns */
      column-gap: 5px;              /* tweak this to taste */

      /* 3 ‚ñ∏ let the row size itself, or set an explicit width that
             matches your columns + gaps (80+90+30*4 + 10*5 = 320 px).   */
      width: 290px;                  /* or simply remove width:‚Ä¶ */

      height: 35px;
      margin-bottom: 10px;
      align-items: center;
      font-size: 0.9em;
      border: 1px solid #999;
      padding-left: 4px;
      background: #f5f5f5;
    }
    .new-order-box input[type="checkbox"] {
      position: absolute;
      right: 6px;
      top: 6px;
    }

    /* Realtime selection = light red + (optionally) locked */
    .new-order-box.rt-selected { background:#ffcdd2 !important; }  /* red lighten-4 */
    .new-order-box.rt-locked   { pointer-events:none; cursor:not-allowed; opacity:.9; }

    /* put right after your .new-order-box rule */
    .new-order-box.selected{
      background:#FFE2B5 !important;   /* force-override any other bg */
    }

    /* ‚îÄ‚îÄ‚îÄ Hover outline for each order row ‚îÄ‚îÄ‚îÄ */
    .new-order-box:hover{
      outline:3px solid #2196F3;   /* vivid blue circumference */
      outline-offset:-1px;         /* keeps outline snug inside row */
    }



    /* Container for dynamically generated preview boxes and detail boxes */
    #photoGridContainer {
      position: relative;
      width: 1500px;
      max-height: 830px;
      overflow-y: auto;
      border-left: 1px dashed #ccc;
      border-right: 1px dashed #ccc;
      left: 350px;
      top: 20px;
    }

    /* === keep images square & clipped inside preview boxes === */
    .preview-box {
      width: 110px;          /* box itself */
      height: 110px;
      overflow: hidden;      /* clip anything that spills */
    }

    .preview-box img {
      width: 110%;
      height: 110%;
      object-fit: cover;     /* center-crop to square */
    }  

    /* ‚îÄ‚îÄ‚îÄ circular 15-px page buttons ‚îÄ‚îÄ‚îÄ */
    .page-btn{
      width:15px;height:15px;
      border-radius:50%;
      background:#eeeeee;color:#000;
      display:inline-flex;align-items:center;justify-content:center;
      font-size:9px;margin:2px;cursor:pointer;border:1px solid #999;
    }
    .page-btn.active{
      background:#2196F3;color:#fff;
    }

    /* Detail text boxes: 55px x 7px */
    .detail-box {
      position: absolute;
      width: 55px;
      height: 7px;
      font-size: 0.6em !important;
      border: none !important;
      outline: none !important;
      -webkit-appearance: none !important;
      -moz-appearance: none !important;
      appearance: none !important;
      background: #f0f0f0;
      color: #333;
      padding: 0;
      margin: 0;
      box-shadow: none !important;
    }

    /* container for the three read-only boxes */
    .modal-detail-row{
      margin-top:7px;
      display:block;               /* stack vertically */
    }

    /* individual read-only box */
    .modal-detail-row input{
      display:block !important;    /* one per line */
      width:200px !important;
      height:20px !important;                 /* ‚Üê fixed height 20 px */
      line-height:20px !important;            /* keep text vertically centered */

      font-size:0.9em !important;

      /* remove Materialize underline & glow */
      border:none !important;
      border-bottom:none !important;
      box-shadow:none !important;

      background:transparent;
      padding:0 2px;               /* small left/right inset */

      margin:0 0 2px 0 !important; /* 2 px gap below each box */
    }

    /* prevent focus style from re-adding underline */
    .modal-detail-row input:focus{
      border-bottom:none !important;
      box-shadow:none !important;
    }

    /* pointer-events enabled on read-only inputs */
    .detail-box:read-only {
      pointer-events: auto !important;
      cursor: pointer !important;
    }

    /* finished orders in the side list */
    .new-order-box.completed{
      background:#4caf50 !important;   /* Materialize green-500 */
      color:#fff;
    }

    .wrap-preview.preview-attn{
      outline:none;                     /* (no !important) so hover can override */
      box-shadow:0 0 0 4px orangered;   /* 4-px warning ring */
    }

    /* purple + bold when Staff Note exists */
    .new-order-box.has-staff-note{
      font-weight:700;
      color:purple;
    }

    /* ‚Äî‚Äî 3-px BLUE hover ring (outer) ‚Äî‚Äî */
    #photoGridContainer .wrap-preview:hover{
      box-shadow: 0 0 0 3px #2196F3 !important;  /* outer blue ring */
      outline:0;                                 /* never suppressed */
      z-index:10;
    }

    /* Config Modal */
    #configModal.modal {
      position: fixed !important;
      top: 30% !important;
      left: 50% !important;
      transform: translate(-50%, -50%) !important;
      width: 575px !important;
      height: 300px !important;
      max-height: none !important;
      overflow-y: auto !important;
    }
    #configTable thead tr th {
      font-size: 0.9em;
    }
    #configTable tbody tr td {
      font-size: 0.8em;
    }
    #configTable .left-input,
    #configTable .top-input,
    #configTable .width-input,
    #configTable .height-input {
      width: 80px !important;
    }
    .modal {
      opacity: 0 !important;
      transform: translateY(20px) scale(0.95) !important;
      will-change: opacity, transform;
      transition: opacity 300ms ease, transform 300ms ease;
    }
    .modal.open {
      opacity: 1 !important;
      transform: translateY(0) scale(1) !important;
    }
    .modal-overlay {
      opacity: 0;
      will-change: opacity;
      transition: opacity 300ms ease;
    }
    .modal-overlay.show {
      opacity: 1;
    }

    /* UI-only: hide the Completed metal counter */
    #completedCounter{display:none!important;}

    /* ‚Äî‚Äî‚Äî BLUE hover ring always sits INSIDE the 4-px orangered ring ‚Äî‚Äî‚Äî */
    #photoGridContainer .wrap-preview.preview-attn:hover{
      box-shadow: 0 0 0 4px orangered,      /* outer warning ring  */
                  inset 0 0 0 3px #2196F3;  /* inner blue ring     */
    }

    /* subtle grey placeholder, 40 % opacity */
    #etsyOrderNumber::placeholder {
      color: rgba(128,128,128,0.4);   /* grey at 40 % */
    }

    /* =========================================================
     * Hover helper ‚Äî 3-px BLUE ring for rows + previews
     * ========================================================*/
    .hover-blue.new-order-box{
      outline:3px solid #2196F3;
      outline-offset:-2px;           /* keeps it inside the row */
      z-index:10;
    }

    .hover-blue.wrap-preview{
      box-shadow:0 0 0 3px #2196F3;  /* blue ring (outside)     */
      z-index:10;
    }

    .hover-blue.preview-attn{
      box-shadow:0 0 0 4px orangered,   /* keep red/orange ring */
                 inset 0 0 0 3px #2196F3;
    }

    /* === Listing-modal COMPLETE checkbox === */
    .modal-complete-label{
      position:absolute;
      right:10px;          /* ‚¨ÖÔ∏è pin to top-right */
      top:30px;            /* 5 px below the title */
      cursor:pointer;
      user-select:none;
    }
    .modal-complete-label input[type="checkbox"]+span{
      transform:scale(1.3);
      margin:0;
    }

    /* ‚ÄúSkip Order‚Äù heading (5 px above the box) */
    .modal-skip-title{
      position:absolute;
      right:10px;
      top:10px;
      font-size:0.9em;
      font-weight:600;
      user-select:none;
    }

    /* === listingModal: make SKU text + Copy button match the Order # (h5) size === */
    #listingModal .modal-sku-row .sku-text{
      font-size: 1.2rem;           /* Materialize h5 default */
    }

    #listingModal #modalSkuCopyBtn{
      font-size: 1.1rem !important; /* match the SKU text */
      height: auto !important;       /* let size follow the font */
      line-height: 1.2 !important;   /* comfy click target */
      padding: 4px 12px !important;  /* subtle breathing room */
      display: inline-flex;          /* nice vertical alignment */
      align-items: center;
    }

    #qrPreviewModal.modal {
      position: fixed !important;
      top: 20% !important;
      left: 20% !important;
      transform: translate(-20%, -20%) !important;
      width: 860px !important;        /* a bit wider to fit more tiles per row */
      height: auto !important;        /* allow content to define height */
      max-height: 80vh !important;    /* cap to viewport for large batches */
      overflow: hidden !important;    /* let .modal-content handle scrolling */
    }
    #qrPreviewModal .modal-content{
      max-height: calc(80vh - 96px) !important; /* header + footer allowance */
      overflow-y: auto !important;              /* smooth scroll for many QR tiles */
    }

  </style>

  <!-- üÜï Etsy counters overlay styles -->
  <style id="etsyCountersStyles">
    #etsyCounters{
      position:fixed; right:10px; top:10px;
      background:rgba(0,0,0,0.65);
      color:#fff; font:12px/1.2 monospace;
      padding:8px 10px; border-radius:10px;
      z-index:99999; box-shadow:0 2px 8px rgba(0,0,0,0.25);
      user-select:none;
    }
    #etsyCounters .row{ display:flex; gap:6px; align-items:baseline; }
    #etsyCounters .label{ opacity:0.85; }
    #etsyCounters .value{ font-weight:700; }
  </style>

   <!-- QR-Preview dependency -->
   <script src="https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js"></script>

</head>
<body>
  <!-- Main Buttons -->
<button id="connectEtsyBtn"    class="btn waves-effect waves-light">Connect</button>
<button id="openConfigBtn"     class="btn waves-effect waves-light">Open Config</button>
<button id="updateOrderListBtn"class="btn waves-effect waves-light">Update</button>
<button id="clearBtn"          class="btn red lighten-1">Clear</button>

<!-- NEW orange ‚ÄúUndo Complete‚Äù button (same drag-friendly style) -->
<button id="undoCompleteBtn"  class="btn orange" style="position:absolute;left:170px;top:220px;width:160px;height:36px;">Undo&nbsp;Remove</button>

<!-- NEW green ‚ÄúComplete !‚Äù button (drag-positionable inside the modal) -->
<button id="completeBtn"
    class="btn green"
    style="position:absolute;left:20px;top:220px;width:140px;height:36px;">
  Generate&nbsp;QR
</button>

<!-- Etsy Order Number input -->
<input id="etsyOrderNumber"
       placeholder="Search Order Number" />

<!-- NEW container that will hold the stacked boxes -->
<div id="newOrderContainer"></div>

<!-- üÜï Etsy request counters -->
<div id="etsyCounters">
  <div class="row"><span class="label">Etsy Max QPS:</span><span id="etsyMaxQps" class="value">0</span></div>
  <div class="row"><span class="label">Etsy Total:</span><span id="etsyTotal"  class="value">0</span></div>
  <!-- keep this ultra-minimal & temporary -->
</div>

<!-- Page-jump buttons will appear here -->
<div id="pageButtonsContainer"></div>

<!-- Live metal counters (draggable via Config modal) -->
<div id="goldCounter"   class="metal-counter active" data-metal="gold">Gold: 0          <!-- ‚Üê renamed label -->
</div>

<div id="silverCounter" class="metal-counter active" data-metal="silver">Silver: 0        <!-- ‚Üê renamed label -->
</div>

<div id="roseCounter"   class="metal-counter active" data-metal="rose">Rose: 0
</div>

<div id="completedCounter" class="metal-counter" data-metal="completed">Completed
</div>

<div id="solidCounter"  class="metal-counter active" data-metal="14k">14K: 0
</div>

<!-- Container that will hold temporarily unmatched images -->
<div id="unmatchedContainer"></div>

<!-- Container for dynamically generated preview boxes and detail boxes -->
<div id="photoGridContainer">
  <!-- Preview boxes and detail boxes will be created dynamically -->
</div>

<!-- Config Modal -->
<div id="configModal" class="modal">
  <div class="modal-content">
    <table class="striped" id="configTable">
      <thead>
        <tr>
          <th>Element</th>
          <th>Left&nbsp;(px)</th>
          <th>Top&nbsp;(px)</th>
          <th>Width&nbsp;(px)</th>
          <th>Height</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>

  <div class="modal-footer">
    <a href="#!" id="saveConfigBtn"
       class="modal-close waves-effect waves-green btn">
      Save Config
    </a>
  </div>
</div>

<!-- 1) Firebase (compat mode) ‚Äì must be above your main sorting code -->
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>

<!-- jQuery & Materialize JS -->
<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js"></script>

<!-- Everything is in this single <script> block -->
<script>

let searchActive = false;     // true ‚á¢ we‚Äôre inside single-order search


/********************************************************
 * Base URL & Global Variables
 ********************************************************/
const functionsBaseUrl = window.location.origin + "/.netlify/functions";

// ‚îÄ‚îÄ üÜï Etsy-call counters (temp instrumentation) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
(function(){
  if (window.__etsyFetchWrapped) return;     // idempotent
  window.__etsyFetchWrapped = true;

  // live state
  const state = (window.__etsyQ = { total: 0, times: [], maxQps: 0 });

  // classify: count only Etsy-facing function calls
  const isEtsyCall = (input) => {
    try{
      const url = (typeof input === "string") ? input : (input && input.url) || "";
      // match our known Etsy proxies & token endpoint
      return /\/\.netlify\/functions\/(etsy|etsyImages|etsyOrderProxy|trackOrderProxy|refreshEtsyToken|exchangeToken)\b/i.test(url);
    }catch(_){ return false; }
  };

  const updateCounters = () => {
    const maxEl = document.getElementById("etsyMaxQps");
    const totEl = document.getElementById("etsyTotal");
    if (maxEl) maxEl.textContent = String(state.maxQps);
    if (totEl) totEl.textContent = String(state.total);
  };

  const mark = () => {
    const now = Date.now();
    state.total += 1;
    state.times.push(now);
    // prune to last 1s window
    const cutoff = now - 1000;
    while (state.times.length && state.times[0] < cutoff) state.times.shift();
    // window size = instantaneous QPS; track the max
    const curQps = state.times.length;
    if (curQps > state.maxQps) state.maxQps = curQps;
    updateCounters();
  };

  const origFetch = window.fetch;
  window.fetch = function(input, init){
    if (isEtsyCall(input)) mark();
    return origFetch.apply(this, arguments);
  };
})();  

const selectedOrders = new Set();      // receipt_id strings
const orderCache     = {};             // receipt_id ‚Üí transactions[]
const gridElements   = new Map();      // transaction_id ‚Üí wrapper DOM
let   lastCtrlIdx    = null;           // ‚¨ÖÔ∏è  anchor for Ctrl/‚åò range-select

/* === CLICK HARDENING HELPERS ========================================= */
const ClickHarden = (() => {
  const busy = new WeakSet();

  // Wrap a handler so the *same element* can't re-enter for cooldownMs
  function withLock(el, fn, cooldownMs = 250) {
    return async function (ev) {
      const host = el || ev?.currentTarget || ev?.target || this;
      if (busy.has(host)) return;              // drop rapid re-clicks on same element
      busy.add(host);
      try { await fn.call(this, ev); }
      finally { setTimeout(() => busy.delete(host), cooldownMs); }
    };
  }

  // Lightweight per-element cooldown you can call inline
  function inCooldown(el, key = "lastTapTs", ms = 250) {
    if (!el) return false;
    const now  = performance.now();
    const prev = +el.dataset[key] || 0;
    if (now - prev < ms) return true;
    el.dataset[key] = String(now);
    return false;
  }

  return { withLock, inCooldown };
})();

/* ===== Image fetch flow control (concurrency + memoization) ===== */
const __imagesCache   = new Map();  // listingId -> resolved array
const __imagesFlight  = new Map();  // listingId -> in-flight Promise

function makeQueue(max = 4) {
  let active = 0;
  const q = [];
  const pump = () => {
    if (active >= max || q.length === 0) return;
    active++;
    const { fn, resolve, reject } = q.shift();
    fn().then(v => { active--; pump(); resolve(v); })
       .catch(e => { active--; pump(); reject(e); });
  };
  return (fn) => new Promise((resolve, reject) => { q.push({ fn, resolve, reject }); pump(); });
}

// Limit concurrent image calls; tune 3‚Äì6 based on your quota.
const runImageTask = makeQueue(3);

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Etsy request pacing (one start every 225 ms) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function makeSpacingQueue(spacingMs = 250) {
  let lastStart = 0;
  let chain = Promise.resolve();
  return (fn) => {
    chain = chain.then(async () => {
      const wait = Math.max(0, spacingMs - (Date.now() - lastStart));
      if (wait) await new Promise(r => setTimeout(r, wait));
      lastStart = Date.now();
      return fn();
    });
    return chain;
  };
}
// Group all Etsy-facing proxy routes behind the same pacing queue
const isEtsyPath  = (p) => /^\/(etsy|listOpenOrders|etsyImages)/i.test(p);
const runEtsyTask = makeSpacingQueue(250);

  // ---- Global image helper (single definition, shared everywhere) ----
  // Uses your Netlify imageProxy to avoid CORS and returns a data: URL.
  // If another copy already defined it, we reuse that.
  var getLocalImageData = window.getLocalImageData || (async function(imageUrl) {
    const resp = await fetch(
      functionsBaseUrl + "/imageProxy?url=" + encodeURIComponent(imageUrl)
    );
    if (!resp.ok) throw new Error("imageProxy HTTP " + resp.status);
    const blob = await resp.blob();
    return await new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = () => resolve(reader.result);
      reader.onerror = reject;
      reader.readAsDataURL(blob);
    });
  });
  // expose on window to guarantee reachability from any scope
  window.getLocalImageData = getLocalImageData;

 /* ===== Resilient Etsy fetch (auto-refresh + 401 retry) ===== */
async function apiFetch(path, init = {}) {
  // 1) proactive refresh when near expiry
  await ensureFreshToken();

  // 2) attempt with current token
  let token = localStorage.getItem(TOKEN_KEYS.access) || "";
  const doFetch = () => fetch(`${functionsBaseUrl}${path}`, {
    ...init,
    headers: { ...(init.headers || {}), "access-token": token }
  });
  // üö¶ pace Etsy endpoints at ~4.44 req/s (225 ms between starts)
  let resp  = isEtsyPath(path)
    ? await runEtsyTask(() => doFetch())
    : await doFetch();

  // 3) on 401 ‚Üí single-flight refresh, then retry once
  if (resp.status === 401) {
    try {
      await refreshAccessToken();
      token = localStorage.getItem(TOKEN_KEYS.access) || "";
      resp  = isEtsyPath(path)
        ? await runEtsyTask(() => doFetch())
        : await doFetch();
    } catch (_) {
      // refresh failed ‚Üí fall through
    }

    if (resp.status === 401) {
      try { localStorage.removeItem(TOKEN_KEYS.access); } catch(e) {}
      startOAuth("api-401");
      throw new Error("Unauthorized ‚Äì reconnecting Etsy‚Ä¶");
    }
  }

  // 4) on 429 ‚Üí exponential backoff (respect Retry-After if present)
  if (resp.status === 429) {
    let attempt = 0;
    while (attempt < 4 && resp.status === 429) {
      const retryAfter = resp.headers?.get?.("retry-after");
      const raMs = Number.isFinite(Number(retryAfter)) ? Number(retryAfter) * 1000 : 0;
      const backoff = Math.max(raMs, 500 * Math.pow(2, attempt)); // 500, 1000, 1500, 2000...
      await new Promise(r => setTimeout(r, backoff));
      resp = isEtsyPath(path)
        ? await runEtsyTask(() => doFetch())  // retry still respects pacing
        : await doFetch();
      attempt++;
    }
  }

  return resp;
}

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 * Abortable, resilient receipt fetch (used by repair pass)
 * ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
async function fetchReceiptRobust(rid, { signal, retries = 2 } = {}){
  const url = `/etsyOrderProxy?orderId=${encodeURIComponent(rid)}`;
  let attempt = 0, lastErr = null;
  while (attempt <= retries){
    try{
      const resp = await apiFetch(url, { signal });
      if (!resp.ok) throw new Error("HTTP " + resp.status);
      const data = await resp.json();
      const txs  = data?.transactions || [];
      if (!Array.isArray(txs) || txs.length === 0) throw new Error("no-transactions");
      return data;
    }catch(e){
      // Abort means caller cancelled ‚Üí bubble out
      if (e?.name === "AbortError") throw e;
      lastErr = e;
      // small backoff: 250ms, 500ms
      await new Promise(r => setTimeout(r, 250 * Math.pow(2, attempt)));
    }
    attempt++;
  }
  console.warn("fetchReceiptRobust failed:", rid, lastErr?.message || lastErr);
  return null;
}

/* =====  Staff-Note highlighting  =================================== */
let staffNoteIDs = new Set();

async function refreshStaffNoteIDs(){
  try{
    const ids = [...document.querySelectorAll("#newOrderContainer .new-order-box")]
      .map(el => el.dataset.receipt)
      .filter(Boolean);
    if (!ids.length) { staffNoteIDs = new Set(); markStaffNoteOrders(); return; }
    const qs  = encodeURIComponent(ids.join(","));
    const res = await fetch(`${functionsBaseUrl}/firebaseOrders?staffNotesFor=${qs}`);
    const j   = await res.json();
    staffNoteIDs = new Set((j.orderNumbers || []).map(String));
  }catch(e){ console.error(e); }
}

function markStaffNoteOrders(){
  document.querySelectorAll(".new-order-box").forEach(box=>{
    const id = box.dataset.receipt || box.dataset.orderNumber;
    if(staffNoteIDs.has(String(id))){
      box.classList.add("has-staff-note");
    }else{
      box.classList.remove("has-staff-note");
    }
  });
}


/* ==== SEARCH SNAPSHOT (for restoring UI) ==== */
let searchSnapshot = null;             // { orderHTML, gridHTML, gridMap }
const processedTxIds = new Set();      // guards against duplicate preview tiles

/* storage keys */
const COMPLETED_KEY = "completedOrders";   // green-list

// ‚Äî‚Äî‚Äî buffer that holds the last batch we cleared (for Undo Complete) ‚Äî‚Äî‚Äî
let lastClearedReceipts = [];

/* ‚îÄ‚îÄ‚îÄ helper: recount items and update the little badge ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
function refreshRowCount(receiptId){
  const box = document.querySelector(`.new-order-box[data-receipt='${receiptId}']`);
  if (!box) return;
  const cntEl = box.querySelector(".badge-count");
  if (!cntEl) return;
  cntEl.textContent = (orderCache[receiptId] || []).length;
}

/* ‚îÄ‚îÄ‚îÄ helper: recalc metal counts for one row ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
function refreshRowMetalCounts(receiptId){
  const row = document.querySelector(`.new-order-box[data-receipt='${receiptId}']`);
  if (!row) return;

  let g = 0, s = 0, rG = 0, k = 0;
  (orderCache[receiptId] || []).forEach(tx => {
    let m = tx._wrapEl?.dataset.metal || tx._metalKey || "";

    if (!m && Array.isArray(tx.variations)) {
      for (const v of tx.variations) {
        if (!v?.formatted_name || !v?.formatted_value) continue;
        if (/metal|color|colour/i.test(v.formatted_name.trim())) {
          m = v.formatted_value.toLowerCase();
          break;
        }
      }
    }

    // 14K override: if m is 'gold' but the variation text mentions 14k, force 14k
    if (/^gold$/i.test(m) && Array.isArray(tx.variations)) {
      const joined = tx.variations
        .map(v => String(v.formatted_value || "").toLowerCase())
        .join(" ");
      if (/\b14\s*k(?:t|arat)?\b/.test(joined)) m = "14k";
    }

    const q = tx.quantity || 1;
    if (/^14k$/.test(m) || /\b14\s*k(?:t|arat)?\b/i.test(m)) k += q;
    else if (/rose/i.test(m))                               rG += q;
    else if (/silv(?:er|r)/i.test(m))                       s  += q;
    else if (/gold/i.test(m))                               g  += q;
  });

  row.querySelector(".col-g").textContent = g;
  row.querySelector(".col-s").textContent = s;
  row.querySelector(".col-r").textContent = rG;
  row.querySelector(".col-k").textContent = k;

  const rowMetal = k ? "14k" : rG ? "rose" : s ? "silver" : g ? "gold" : "";
  if (rowMetal) row.dataset.metal = rowMetal;
}

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 * Surgical healer: re-fetch & fix rows with 0/0/0/0 metal counts
 * ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
function __readInt(el, sel){
  const n = parseInt(el.querySelector(sel)?.textContent || "0", 10);
  return Number.isFinite(n) ? n : 0;
}

function normalizeMetalText(s){
  return String(s||"")
    .toLowerCase()
    .replace(/&quot;/g, '"')
    .replace(/[\/_-]+/g, " ")
    .replace(/\s+/g, " ")
    .trim();
}

function deriveMetalKeyFromVariations(tx){
  const vals = (tx?.variations || []).map(v => `${v?.formatted_name||""} ${v?.formatted_value||""}`);
  // widen to include listing title & personalization if parser lacked a hit
  if (tx?.title) vals.push(tx.title);
  if (tx?.personalization) vals.push(tx.personalization);
  const blob = normalizeMetalText(vals.join(" "));
  if (!blob) return "";
  // Order matters: 14k ‚Üí Rose ‚Üí Silver ‚Üí Gold
  if (/\b14\s*k(?:t|arat)?\b/.test(blob))                                  return "14k";
  if (/\brose\s*gold\b|\brose-?gold\b|\brosegold\b/.test(blob))            return "rose";
  if (/\bsterling\b|\bsilver\b|color\s*sterling\s*silver|colorsterling\s*silver/.test(blob))
                                                                           return "silver";
  if (/\bgold\b|\byellow\b/.test(blob))                                    return "gold";
  return "";
}

async function healZeroMetalRows({ passes = 2, concurrency = 4, reason = "" } = {}){
  const container = document.getElementById("newOrderContainer");
  if (!container) return;

  async function healOne(rid){
    try{
      const data = await pullEtsyOrderDetails(rid);
      if (!data) return;
      const txs = data.transactions || [];
      txs.forEach(tx => {
        const k = deriveMetalKeyFromVariations(tx);
        if (k) tx._metalKey = k;
      });
      // seed cache ‚Üí row recalcs will use this
      orderCache[rid] = txs;
      refreshRowCount(rid);
      refreshRowMetalCounts(rid);
    }catch(e){
      console.warn("healOne failed", rid, e);
    }
  }

  for (let pass = 1; pass <= passes; pass++){
    const rows = [...container.querySelectorAll(".new-order-box")];
    const zeroRows = rows.filter(row => {
      const g = __readInt(row, ".col-g");
      const s = __readInt(row, ".col-s");
      const r = __readInt(row, ".col-r");
      const k = __readInt(row, ".col-k");
      return (g + s + r + k) === 0;
    });
    if (!zeroRows.length) break;

    const ids = zeroRows.map(r => r.dataset.receipt).filter(Boolean);
    let idx = 0;
    const workers = Array.from({length: Math.max(1, Math.min(concurrency, ids.length))}, () => (async ()=>{
      while (idx < ids.length){
        const rid = ids[idx++];
        await healOne(rid);
      }
    })());
    await Promise.all(workers);
    // let the DOM paint between passes
    await new Promise(r => setTimeout(r, 50));
  }

  // tidy UI after fixing
  updateCounters?.();
  applyMetalFilter?.();
}

 // handy in console
 window.healZeroMetalRows = healZeroMetalRows;

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 * Repair receipts with absent/empty transactions, then re-derive metals
 * ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
async function repairMissingReceiptData({ passes = 2, concurrency = 4 } = {}){
  const myRun = updateRunId; // only commit if still current
  const container = document.getElementById("newOrderContainer");
  if (!container) return;

  function needsRepair(row){
    const rid = String(row?.dataset?.receipt || "");
    if (!rid) return false;
    const txs = orderCache[rid];
    if (!Array.isArray(txs) || txs.length === 0) return true;
    // also treat rows with 0/0/0/0 as ‚Äúprobably missing data‚Äù
    const g = __readInt(row, ".col-g");
    const s = __readInt(row, ".col-s");
    const r = __readInt(row, ".col-r");
    const k = __readInt(row, ".col-k");
    return (g + s + r + k) === 0;
  }

  async function repairOne(rid){
    // abortable per-task controller, tracked for bulk cancel
    const ctrl = new AbortController();
    pendingUpdateControllers.push(ctrl);
    const data = await fetchReceiptRobust(rid, { signal: ctrl.signal, retries: 2 });
    if (!data) return;                 // still nothing; leave row visible for manual
    if (myRun !== updateRunId) return; // outdated run: do not touch UI/cache

    const txs = data.transactions || [];
    // seed quick metal hints
    txs.forEach(tx => { tx._metalKey = deriveMetalKeyFromVariations(tx) || tx._metalKey || ""; });
    orderCache[rid] = txs;             // populate cache
    refreshRowCount(rid);
    refreshRowMetalCounts(rid);
  }

  for (let pass = 1; pass <= passes; pass++){
    const rowsNeeding = [...container.querySelectorAll(".new-order-box")].filter(needsRepair);
    if (!rowsNeeding.length) break;
    let idx = 0;
    const ids = rowsNeeding.map(r => String(r.dataset.receipt)).filter(Boolean);
    const workers = Array.from({length: Math.min(concurrency, ids.length)}, () => (async ()=>{
      while (idx < ids.length){
        const rid = ids[idx++];
        try{ await repairOne(rid); }catch(e){ if (e?.name !== "AbortError") console.warn("repairOne", rid, e); }
      }
    })());
    await Promise.all(workers);
    await new Promise(r => setTimeout(r, 50)); // paint
  }
  updateCounters?.(); applyMetalFilter?.();
}
window.repairMissingReceiptData = repairMissingReceiptData;

const SELECTED_KEY   = "selectedOrders";         // orange-list
const LAST_PURGE_KEY = "completed_last_purge";   // ISO month stamp
const completedOrders = new Set();               // IDs that are already green



let croppedImagesArray = [];
let userImagesArray = [];
let cellMatches = {};
let matchPrintFlowInProgress = false;
let printDialogOpened = false;
let pendingFetchControllers = [];
let globalRunId = 0;
let currentSaveHandler = null;      // tracks active ‚ÄúSave‚Äù listener
let skipMatches = {};   // { cellIndex: true }  
let earringCells  = {};            // { cellIdx : true }
let earringState  = {};            // { cellIdx : { firstImg:null } }
let orderListOffset = 0;      // 0, 100, 200‚Ä¶

/* ‚îÄ‚îÄ Update-run isolation ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
let updateRunId = 0;                           // increment per Update click
let pendingUpdateControllers = [];             // AbortControllers for Update
function abortAllUpdateWork(){
  try { pendingUpdateControllers.forEach(c=>c.abort()); } catch(_){}
  pendingUpdateControllers = [];
}

/********************************************************
 * Firebase Initialization (REQUIRED)
 ********************************************************/
const firebaseConfig = {
  apiKey: "AIzaSyBXhQLsYRa4i0bX1TPTRiElF9Zjy5vSHlA",
  authDomain: "gokudatabase.firebaseapp.com",
  projectId: "gokudatabase",
  storageBucket: "gokudatabase.firebasestorage.app",
  messagingSenderId: "1078662308113",
  appId: "1:1078662308113:web:41df0e5d229ff2af7a6cb0"
};

if (!firebase.apps?.length) firebase.initializeApp(firebaseConfig);
const db = firebase.firestore();

// Ensure the client is authenticated (anon is fine for rules below)
firebase.auth().onAuthStateChanged(u => {
  if (!u) {
    firebase.auth().signInAnonymously().catch(err => {
      console.warn("Anon auth failed:", err);
    });
  }
});

// Start RT polling immediately on load (no click required)
window.addEventListener('DOMContentLoaded', () => {
  try { startCompletedRealtime(); } catch(_) {}
  beginDeltaPolling();

  // Paint any existing locks as rows are inserted into the sidebar
  const container = document.getElementById('newOrderContainer');
  if (container) {
  new MutationObserver(() => applyAllLocksToDOM())
  .observe(container, { childList: true, subtree: true });
  }
});

async function fetchAllLocksOnce(){
  try{
    const r = await fetch(`${functionsBaseUrl}/firebaseOrders?rt=1`);
    const j = await r.json();
    // seed the local map and paint everything we have in DOM
    rtSelected = new Map(
      Object.entries(j.locks || {}).map(([id,doc]) => [id, doc.selectedBy || null])
    );
    applyAllLocksToDOM();
  }catch(e){ console.warn("hydrate locks failed", e); }
}

// Delta-poll watermark & guards
let __rtSince     = Date.now() - 5 * 60 * 1000; // start 5 min back
let __rtInflight  = null;
let __rtIdleHits  = 0;

// === Real-time ‚Äúselected order‚Äù locks ===
const REALTIME_COLL = "Design_RealTime_Selected_Orders";

const RT = {
  clientId: (() => {
    const k = "rt_client_id";
    let v = null;
    try { v = localStorage.getItem(k); } catch(_) {}
    if (!v) {
      v = (crypto.randomUUID?.() || ("c_" + Math.random().toString(36).slice(2)));
      try { localStorage.setItem(k, v); } catch(_) {}
    }
    return v;
  })(),
  page: location.pathname.toLowerCase().includes("design-1") ? "design-1" : "design"
};

/* All writes go through Netlify function (with small retry) */
async function rtSet(id, on){
  id = String(id);
  const body = on
    ? { rtLockIds:   [id], clientId: RT.clientId, page: RT.page }
    : { rtUnlockIds: [id], clientId: RT.clientId, page: RT.page };

  let attempt = 0, lastErr = null;
  while (attempt < 3){
    try{
      const resp = await fetch(`${functionsBaseUrl}/firebaseOrders`, {
        method: "POST",
        headers: { "Content-Type":"application/json" },
        body: JSON.stringify(body)
      });
      if (!resp.ok) throw new Error("HTTP " + resp.status);

      // optimistic local clear on unlock so light-red + lock vanish immediately
      if (!on) {
        rtSelected.delete(id);
        clearLock(id);
      }
      return; // success
    }catch(err){
      lastErr = err;
      await new Promise(r => setTimeout(r, 150 * Math.pow(2, attempt))); // 150ms, 300ms, 600ms
    }
    attempt++;
  }
  console.warn("rtSet failed after retries:", lastErr);
}

let rtSelected = new Map();  // id -> owner

/* Owner keeps normal orange; others see light red + locked */
function paintLock(id, owner){
  const isMine = owner === RT.clientId;
  document.querySelectorAll(`.new-order-box[data-receipt='${id}']`).forEach(el=>{
    if (isMine){
      el.classList.remove("rt-selected","rt-locked"); // keep your .selected (orange)
    } else {
      el.classList.add("rt-selected","rt-locked");    // others: light red + disabled
    }
  });
}

function clearLock(id){
  document.querySelectorAll(`.new-order-box[data-receipt='${id}']`)
    .forEach(el=> el.classList.remove("rt-selected","rt-locked"));
}

/* If rows were rendered after a snapshot, repaint them */
function applyAllLocksToDOM(){ rtSelected.forEach((owner,id)=>paintLock(id, owner)); }

// Re-apply saved orange selections, then repaint RT locks
function reapplySelectionAndLocks(){
  // tolerate scope/hoist differences across pages
  if (typeof highlightSavedRows === "function") {
    highlightSavedRows();           // adds .selected from your saved set
  } else {
    // minimal local fallback: paint oranges from selectedOrders
    selectedOrders.forEach(id => {
      document
        .querySelectorAll(`.new-order-box[data-receipt='${id}']`)
        .forEach(row => row.classList.add("selected"));
    });
  }
  applyAllLocksToDOM();             // repaints light-red/locks for others
  scheduleHealMissingLocks();       // ensure Firebase gets the lock docs
}

function startCompletedRealtime(){
  // Guard so we don't double-wire on the same page
  if (window.__completedStreamWired) return;
  window.__completedStreamWired = true;

  const COLL = "Design_Completed Orders";

  // Track last-known completed set so we can detect UNDO events
  let knownCompleted = new Set();

  function removeIfCompleted(idSet){
    // Remove from sidebar + grid for any completed receipt IDs
    document.querySelectorAll("#newOrderContainer .new-order-box").forEach(row=>{
      const rid = String(row.dataset.receipt || "");
      if (!rid || !idSet.has(rid)) return;

      // Drop selection + previews + cache
      selectedOrders.delete(rid);
      removePreviewBoxesForOrder(rid);
      delete orderCache[rid];

      // Unlock real-time selection if needed
      try { rtSet(rid, false); } catch (_) {}

      // Remove the row itself
      row.remove();
    });

    // Tidy UI
    reflowGrid?.();
    realignGrid?.();
    updateCounters?.();
    applyMetalFilter?.();
  }

  // When a completion is undone elsewhere, bring the row back locally.
  async function reAddUndone(ids){
    for (const rid of ids.map(String)) {
      // If it's already visible, just strip green and refresh UI.
      const existing = document.querySelector(`.new-order-box[data-receipt='${rid}']`);
      if (existing) {
        existing.classList.remove("completed");
        continue;
      }

      // Try to source the receipt from our existing caches/lists
      const bag = (window.currentReceipts || []).concat(window.allOpenReceipts || []);
      const rec = bag.find(r => String(r.receipt_id) === rid);

      if (rec && Array.isArray(window.currentReceipts)) {
        // Ensure it's in the current list then re-render the list UI
        if (!currentReceipts.some(r => String(r.receipt_id) === rid)) {
          currentReceipts.unshift(rec);
        }
        renderOrderBoxes(currentReceipts);
        reapplySelectionAndLocks?.();
        updateCounters?.();
        applyMetalFilter?.();
        markStaffNoteOrders?.();
        continue;
      }

      // Fallback: fetch the full order + minimally rebuild its row and previews
      try{
        const data = await pullEtsyOrderDetails(rid);
        const txs  = data?.transactions || [];
        const rcpt = data?.receipt || {};
        orderCache[rid] = txs;

        // quick metal counts (matches sidebar columns)
        const cnt = { g:0, s:0, r:0, k:0 };
        txs.forEach(tx=>{
          const q = tx.quantity || 1;
          switch (tx._metalKey){ case "gold": cnt.g+=q; break; case "silver": cnt.s+=q; break; case "rose": cnt.r+=q; break; case "14k": cnt.k+=q; break; }
        });
        const rowMetal = cnt.k ? "14k" : (cnt.r ? "rose" : (cnt.s ? "silver" : (cnt.g ? "gold" : "")));

        const row = document.createElement("div");
        row.className = "new-order-box";
        row.dataset.receipt = rid;
        if (rowMetal) row.dataset.metal = rowMetal;
        row.innerHTML = `
          <span class="col-order">${rcpt.order_number || rid}</span>
          <span class="col-ship">N/A</span>
          <span class="col-g">${cnt.g}</span>
          <span class="col-s">${cnt.s}</span>
          <span class="col-r">${cnt.r}</span>
          <span class="col-k">${cnt.k}</span>`;
        document.getElementById("newOrderContainer").prepend(row);

        // put its items back into the preview grid
        txs.forEach(tx => { if (!tx._inGrid) addPreviewBox(tx); });

        reapplySelectionAndLocks?.();
        updateCounters?.();
        applyMetalFilter?.();
        markStaffNoteOrders?.();
      }catch(_){}
    }
  }

  // Targeted polling: only check completion for receipts currently visible
  function visibleReceipts(){
    return [...document.querySelectorAll("#newOrderContainer .new-order-box")]
      .map(el => el.dataset.receipt)
      .filter(Boolean);
  }

  async function pollCompletedTargeted(){
    const ids = visibleReceipts();
    if (!ids.length) return { changed:false };

    const qs  = encodeURIComponent(ids.join(","));
    const r   = await fetch(`${functionsBaseUrl}/firebaseOrders?dcFor=${qs}`);
    const j   = await r.json();
    const live = new Set((j.orderNumbers || []).map(String));

    // Remove any rows that are confirmed as completed (server truth is additive)
    removeIfCompleted(live); // paints + removes rows, updates UI

    // Monotonic: once completed, we remember it locally until explicit Undo
    knownCompleted = new Set([...knownCompleted, ...live]);

    return { changed: live.size > 0 };
  }

  // adaptive cadence, sleeps until UI interaction resumes
  let t=null, idle=0;
  const steps=[750,1500,3000,6000,12000,30000];
  async function tick(){
    try{
      const { changed } = await pollCompletedTargeted();
      idle = changed ? 0 : Math.min(idle+1, steps.length-1);
    }catch(_){ idle = Math.min(idle+1, steps.length-1); }
    t = setTimeout(tick, steps[idle]);
  }
  // start immediately, then pause/resume with the same interaction hooks you already wire
  tick();

  // Fallback: light polling via Netlify function (?designCompleted=1)
 function beginCompletedPolling(){
   let t = null;
   let dcSince = Date.now() - 5*60*1000;
   let idleHits = 0;
   const steps = [1000, 2000, 4000, 8000, 16000, 30000];
   const maxIdle = steps.length - 1;
   const tick = async ()=>{
     try{
       const r = await fetch(`${functionsBaseUrl}/firebaseOrders?dcSince=${dcSince}`);
       const j = await r.json();
       const ids = (j && j.success ? (j.orderNumbers||[]) : []).map(String);
       if (ids.length){
         removeIfCompleted(new Set(ids));
         idleHits = 0;
       } else {
         idleHits = Math.min(idleHits+1, maxIdle);
       }
       if (j && Number.isFinite(j.now)) dcSince = Number(j.now);
     }catch(_){ idleHits = Math.min(idleHits+1, maxIdle); }
     if (idleHits >= maxIdle){ t = null; return; }   // sleep until interaction
     t = setTimeout(tick, steps[idleHits]);
   };
   // Resume on interaction (same triggers)
   const container = document.getElementById("newOrderContainer");
   const resume = () => { if (!t){ idleHits = 0; tick(); } };
   container?.addEventListener("click", resume);
   ["undoCompleteBtn","qrPreviewPrintBtn","clearBtn","pageButtonsContainer","etsyOrderNumber"]
     .forEach(id => document.getElementById(id)?.addEventListener("click", resume, {capture:true}));
   document.addEventListener("click", (e)=>{ if (e.target?.closest?.(".new-order-box")) resume(); }, {capture:true});
   tick();
  }
}

// === Server-driven delta poller (adaptive backoff, no Firestore onSnapshot) ===
 const RT_POLL = { t:null };
 const RT_STEPS = [100, 200, 400, 800, 1600, 3200, 6400];
 const RT_MAX_IDLE = RT_STEPS.length - 1;
 function nextDelayMs(){
   const i = Math.min(__rtIdleHits, RT_MAX_IDLE);
   return RT_STEPS[i];
 }
function scheduleRtPoll(){
  clearTimeout(RT_POLL.t);
  // Always keep polling; at max backoff we still tick (no full sleep)
  RT_POLL.t = setTimeout(()=>{ fetchLocksOnce(); }, nextDelayMs());
}
 // Resume lock polling on interaction (same triggers)
 window.addEventListener('DOMContentLoaded', () => {
  const container = document.getElementById("newOrderContainer");
  const resume = () => { if (!RT_POLL.t){ __rtIdleHits = 0; scheduleRtPoll(); } };
   container?.addEventListener("click", resume, {capture:true});
   ["undoCompleteBtn","qrPreviewPrintBtn","clearBtn","pageButtonsContainer","etsyOrderNumber"]
     .forEach(id => document.getElementById(id)?.addEventListener("click", resume, {capture:true}));
   document.addEventListener("click", (e)=>{ if (e.target?.closest?.(".new-order-box")) resume(); }, {capture:true});
 });
function beginDeltaPolling(){
  clearTimeout(RT_POLL.t);
  __rtSince    = Date.now() - 5*60*1000;
  __rtIdleHits = 0;
  fetchAllLocksOnce();   // get all current locks once
  scheduleRtPoll();      // then switch to deltas
}


// === Firestore realtime listener (primary) with graceful fallback ===
function beginRtPolling(){
  window.__rtPollTimer && clearInterval(window.__rtPollTimer);
  window.__rtPollTimer = setInterval(fetchLocksOnce, 700);
}
/* async function startLockListener(){
  // stop any prior polling
  if (window.__rtPollTimer){ clearInterval(window.__rtPollTimer); window.__rtPollTimer = null; }
  try{
    __rtUnsub?.(); // close any old snapshot
    __rtUnsub = db.collection(REALTIME_COLL).onSnapshot((snap)=>{
      const next = new Map();
      snap.forEach(doc=>{
        const d = doc.data() || {};
        if (d && d.selected) next.set(String(doc.id), d.selectedBy || null);
      });
      next.forEach((owner, id)=>{
        const prev = rtSelected.get(id);
        if (prev !== owner) paintLock(id, owner);
      });
      rtSelected.forEach((_, id)=>{ if (!next.has(id)) clearLock(id); });
      rtSelected = next;
      applyAllLocksToDOM();
    }, (err)=>{
      console.warn("onSnapshot failed; falling back to lean polling", err);
      __rtUnsub = null;
      beginRtPolling();
    });
  }catch(err){
    console.warn("Realtime listener error; using polling", err);
    beginRtPolling();
  }
} */

 async function fetchLocksOnce(){
   if (__rtInflight) return __rtInflight; // dedupe
   const url = `${functionsBaseUrl}/firebaseOrders?rtSince=${__rtSince}`;
   __rtInflight = fetch(url).then(r=>{
     if (!r.ok) throw new Error("HTTP " + r.status);
     return r.json();
   }).then(json=>{
     let changed = 0;
     // apply new/updated locks
     Object.entries(json.locks || {}).forEach(([id, doc])=>{
       const owner = (doc||{}).selectedBy || null;
       const prev  = rtSelected.get(id);
       if (prev !== owner){
         rtSelected.set(id, owner);
         paintLock(id, owner);
         changed++;
       }
     });
     // apply unlocks
     (json.unlocks || []).forEach(id=>{
       if (rtSelected.has(id)){
         rtSelected.delete(id);
         clearLock(id);
         changed++;
       }
     });
     // watermark
     __rtSince = Number(json.now) || Date.now();
     __rtIdleHits = changed ? 0 : (__rtIdleHits + 1);
     applyAllLocksToDOM();
   }).catch(()=>{}).finally(()=>{
     __rtInflight = null;
     scheduleRtPoll();     // keep the loop going with adaptive cadence
   });
   return __rtInflight;
 }
// (polling now only runs as a fallback via beginRtPolling())

/* Release my locks on tab close ‚Äî via function */
window.addEventListener("beforeunload", ()=>{
  try{
    const myIds = [...rtSelected].filter(([id, owner]) => owner === RT.clientId)
                                 .map(([id]) => String(id));
    if (!myIds.length) return;
    navigator.sendBeacon?.(
      `${functionsBaseUrl}/firebaseOrders`,
      new Blob([JSON.stringify({ rtUnlockIds: myIds, clientId: RT.clientId })],
               { type: "application/json" })
    );
  }catch(_){}
});

// Reconcile helper: compare our rtSelected map to the server's current active locks
async function reconcileActiveLocks() {
  try {
    const r = await fetch(`${functionsBaseUrl}/firebaseOrders?rt=1`);
    if (!r.ok) return;
    const j = await r.json();
    const live = new Set(Object.keys(j.locks || {}));   // ids currently locked (selected==true)

    // Any id we think is locked but isn't in live ‚Üí clear it locally
    rtSelected.forEach((_, id) => {
      if (!live.has(id)) {
        rtSelected.delete(id);
        clearLock(id);
      }
    });

    applyAllLocksToDOM();
  } catch (_) {}
}

// Batch re-lock any locally-selected rows that do not have a live lock owner = me
  let __healTimer = null;

  async function healMissingLocksNow(){
    try{
      const ids = [];
      selectedOrders.forEach(id => {
        const s = String(id);
        const owner = rtSelected.get(s);
        if (owner !== RT.clientId) ids.push(s);
      });
      if (!ids.length) return;

      // single POST with rtLockIds (server already supports arrays)
      await fetch(`${functionsBaseUrl}/firebaseOrders`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ rtLockIds: ids, clientId: RT.clientId, page: RT.page })
      });
    }catch(e){
      console.warn("healMissingLocks failed:", e);
    }
  }

  function scheduleHealMissingLocks(){
    clearTimeout(__healTimer);
    __healTimer = setTimeout(healMissingLocksNow, 120);  // tiny debounce
  }

/* ===== Etsy OAuth boot + auto-refresh wiring ===== */
const TOKEN_KEYS = {
  access  : "access_token",
  refresh : "refresh_token",
  expires : "token_expires_at"   // epoch seconds
};

// --- NEW: single-flight guard to prevent refresh token races ---
let __refreshPromise = null;

function scheduleTokenRefresh(){
  clearTimeout(window.__etsyRefreshTimer);
  const exp = Number(localStorage.getItem(TOKEN_KEYS.expires) || 0);

  // Fallback: if expires is missing but we have a refresh token, refresh at 55 min
  if (!exp){
    if (localStorage.getItem(TOKEN_KEYS.refresh)){
      window.__etsyRefreshTimer = setTimeout(refreshAccessToken, 55 * 60 * 1000);
    }
    return;
  }

  const now = Math.floor(Date.now()/1000);
  const leadSec = 120;
  const delayMs = Math.max(5000, (exp - now - leadSec) * 1000);
  window.__etsyRefreshTimer = setTimeout(refreshAccessToken, delayMs);
}

function setTokens({ access_token, refresh_token, expires_in, issued_at }){
  if (access_token)  localStorage.setItem(TOKEN_KEYS.access, access_token);
  if (refresh_token) localStorage.setItem(TOKEN_KEYS.refresh, refresh_token);

  const now = Math.floor(Date.now()/1000);
  const iat = Number(issued_at || now);
  const exp = iat + Number(expires_in || 3600);
  localStorage.setItem(TOKEN_KEYS.expires, String(exp));

  scheduleTokenRefresh();
}

async function refreshAccessToken(){
  // If a refresh is already in-flight, await it.
  if (__refreshPromise) return __refreshPromise;

  const rt = localStorage.getItem(TOKEN_KEYS.refresh);
  if (!rt) return; // nothing to refresh with

  __refreshPromise = (async () => {
    try{
      const resp = await fetch(`${functionsBaseUrl}/refreshEtsyToken`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ refresh_token: rt })
      });
      if (!resp.ok) throw new Error("HTTP " + resp.status);

      const data = await resp.json();
      setTokens({
        access_token : data.access_token,
        // Etsy rotates refresh_token; if provided, store it, else keep old
        refresh_token: data.refresh_token || rt,
        expires_in   : data.expires_in,
        issued_at    : data.issued_at || Math.floor(Date.now()/1000)
      });
      M.toast({ html: "Etsy token refreshed" });
      return true;
     }catch(err){

       console.warn("Token refresh failed:", err);
       // Clear & start headless OAuth (no button clicks)
       localStorage.removeItem(TOKEN_KEYS.access);
       localStorage.removeItem(TOKEN_KEYS.expires);
       await startOAuth("refresh-failed");
       throw err;   
       
     }finally{
     __refreshPromise = null;

    }

  })();

  return __refreshPromise;
}

// === Micro-batched RT lock writer ===========================================
const __rtBatch = { lock: new Set(), unlock: new Set(), t: null, inflight: null };

function scheduleRtFlush(){ clearTimeout(__rtBatch.t); __rtBatch.t = setTimeout(flushRtBatchImmediately, 80); }

function rtQueueLock(id){
  id = String(id);
  __rtBatch.unlock.delete(id);
  __rtBatch.lock.add(id);
  // optimistic local paint
  rtSelected.set(id, RT.clientId);
  paintLock(id, RT.clientId);
  scheduleRtFlush();
}

function rtQueueUnlock(id){
  id = String(id);
  __rtBatch.lock.delete(id);
  __rtBatch.unlock.add(id);
  // optimistic local clear
  rtSelected.delete(id);
  clearLock(id);
  scheduleRtFlush();
}

async function flushRtBatchImmediately(){
  if (__rtBatch.inflight) {            // serialize flushes
    try { await __rtBatch.inflight; } catch(_) {}
    if (!__rtBatch.lock.size && !__rtBatch.unlock.size) return;
  }
  const locks   = [...__rtBatch.lock];
  const unlocks = [...__rtBatch.unlock];
  __rtBatch.lock.clear(); __rtBatch.unlock.clear();

  if (!locks.length && !unlocks.length) return;

  __rtBatch.inflight = fetch(`${functionsBaseUrl}/firebaseOrders`,{
    method:"POST",
    headers:{ "Content-Type":"application/json" },
    body: JSON.stringify({
      rtLockIds   : locks.length   ? locks   : undefined,
      rtUnlockIds : unlocks.length ? unlocks : undefined,
      clientId    : RT.clientId,
      page        : RT.page
    })
  }).catch((e)=>{ console.warn("rt batch flush failed", e); })
    .finally(()=>{ __rtBatch.inflight = null; scheduleHealMissingLocks(); });
}

// flush when user finishes a burst of clicks
window.addEventListener("mouseup", ()=> { flushRtBatchImmediately(); });

async function ensureFreshToken(){
  const exp = Number(localStorage.getItem(TOKEN_KEYS.expires) || 0);
  if (!exp) return;
  const now = Math.floor(Date.now()/1000);
  if (exp - now <= 120) await refreshAccessToken();
}

/* Boot */
(function () {
  const url = new URLSearchParams(window.location.search);

  // Tokens returned by exchangeToken.js (access, refresh, expires_in, issued_at)
  const a = url.get("access_token");
  if (a){
    setTokens({
      access_token : a,
      refresh_token: url.get("refresh_token"),
      expires_in   : url.get("expires_in"),
      issued_at    : url.get("issued_at")
    });
    window.history.replaceState({}, document.title, window.location.pathname);
    M.toast({ html: "Connection Successful!" });
    return;
  }

  // Standard OAuth code return ‚Üí hand back to server for code‚Üítokens
  const code = url.get("code");
  if (code){
    const v = localStorage.getItem("etsy_code_verifier");
    if (v){
      const qs = new URLSearchParams({
        code,
        code_verifier: v,
        redirect_domain: "design-1"   // ‚¨ÖÔ∏è match shipping-1 behavior
      });
      window.location.href = "/.netlify/functions/exchangeToken?" + qs.toString();
      return;
    }else{
      console.error("No code verifier found in localStorage.");
    }
  }

  // Page load without query: rehydrate existing session and arm refresh
  if (localStorage.getItem(TOKEN_KEYS.access)) {
    scheduleTokenRefresh();
  } else if (localStorage.getItem(TOKEN_KEYS.refresh)) {
    // No access token but we have a refresh token ‚Üí refresh immediately
    refreshAccessToken();
  }
})();

function generateRandomString(length) {
  const chars =
    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  let text = "";
  for (let i = 0; i < length; i++) {
    text += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return text;
}

async function generateCodeChallenge(codeVerifier) {
  const encoder = new TextEncoder();
  const data = encoder.encode(codeVerifier);
  const digest = await crypto.subtle.digest("SHA-256", data);
  let base64String = btoa(String.fromCharCode(...new Uint8Array(digest)));
  return base64String.replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
}

 // Headless OAuth starter (no UI button click)
 let __oauthInFlight = false;
 async function startOAuth(reason = "auto") {
   if (__oauthInFlight) return;
   __oauthInFlight = true;
   try {
     const codeVerifier = generateRandomString(64);
     localStorage.setItem("etsy_code_verifier", codeVerifier);
     const codeChallenge = await generateCodeChallenge(codeVerifier);
 
     const CLIENT_ID   = "k75zdspz4r99txpqdji7i2em";
     const redirectUri = "https://design-1.goldenspike.app";
     const scope       = "listings_w listings_r transactions_r transactions_w";
     const state       = `reconnect_${Date.now()}_${reason}`;
 
     const etsyAuthUrl =
       "https://www.etsy.com/oauth/connect?response_type=code" +
       "&client_id=" + CLIENT_ID +
       "&redirect_uri=" + encodeURIComponent(redirectUri) +
       "&scope=" + encodeURIComponent(scope) +
       "&state=" + encodeURIComponent(state) +
       "&code_challenge=" + encodeURIComponent(codeChallenge) +
       "&code_challenge_method=S256";
 
     window.location.href = etsyAuthUrl;
   } catch (e) {
     console.error("OAuth boot failed:", e);
     __oauthInFlight = false;
   }
 }

// ADDED these two lines so you can reposition/resize them in the Config modal
const configIDs = [
  "connectEtsyBtn",
  "openConfigBtn",
  "updateOrderListBtn",
  "nextPageBtn",            // ‚Üê NEW
  "clearBtn",
  "etsyOrderNumber",
  "photoGridContainer",
  "orderHeaderBar",
  "configModal",
  "configTable",
  "saveConfigBtn",
  "newOrderContainer",
  "pageButtonsContainer",
  "completeBtn",          // ‚Üê NEW
  "undoCompleteBtn",      // ‚Üê NEW
  "qrPreviewPrintBtn",    // ‚Üê NEW
  "goldCounter",
  "silverCounter",
  "roseCounter",
  "solidCounter"

];

/********************************************************
 * DOMContentLoaded: Disable buttons & attach logic
 ********************************************************/
let listingModal;                     // ‚Üê NEW ‚ûä  (declare up-top)

document.addEventListener("DOMContentLoaded", async () => {
  M.AutoInit();

  const completeBtn = document.getElementById("completeBtn");
  if (completeBtn && !completeBtn.dataset.wired) {
    completeBtn.dataset.wired = "1";
    completeBtn.addEventListener(
      "click",
      ClickHarden.withLock(completeBtn, async function () {
        if (this.disabled) return;
        this.disabled = true;
        this.classList.add("disabled");
        this.setAttribute("aria-busy", "true");
        try { await handleCompleteClick(); }
        finally {
          setTimeout(() => {
            this.disabled = false;
            this.classList.remove("disabled");
            this.removeAttribute("aria-busy");
          }, 300);
        }
      }, 600)
    );
  }

  /* wire ‚ÄúUndo Complete‚Äù */
  const undoBtn = document.getElementById("undoCompleteBtn");
  if (undoBtn) undoBtn.addEventListener("click", handleUndoCompleteClick);

// (hardened) wiring moved above; duplicate removed

/* ‚ù∑  on first app load, seed ALL indices (full) */
await fullRefreshAllIndices();

/* ==============================================================
 *  Unified row click: Plain = toggle, Ctrl/‚åò = toggle, Shift = range
 *  Always loads previews for selected rows (so print can proceed)
 * ============================================================*/
const orderContainer = document.getElementById("newOrderContainer");
if (!orderContainer.dataset.rangeWired){
  orderContainer.dataset.rangeWired = "1";

  // Helper: ensure transactions loaded for a receipt
  async function ensureOrderLoaded(rid){
    if (orderCache[rid]) return;
    const ord = await pullEtsyOrderDetails(rid);
    orderCache[rid] = ord?.transactions || [];
    refreshRowCount(rid);
    refreshRowMetalCounts(rid);
  }

  // Delegated handler (capture) to beat per-row listeners
  orderContainer.addEventListener("click", async (e) => {
    const box = e.target.closest(".new-order-box");
    if (!box) return;

    // fast-click guard per row (same row won't toggle twice inside 250 ms)
    if (ClickHarden.inCooldown(box, "rowTapTs", 250)) return;

    /* If someone else has this order locked, block clicks */
    if (box.classList.contains("rt-locked")) {
      if (window.M?.toast) M.toast({ html: "This order is being worked on in another window." });
      return;
    }

    // Prevent legacy handlers from swallowing Ctrl/Meta
    e.preventDefault();
    e.stopImmediatePropagation();
    e.stopPropagation();           // ‚¨ÖÔ∏è block bubble-phase row handler from re-toggling


    const rows = [...orderContainer.querySelectorAll(".new-order-box")];
    const currIdx = rows.indexOf(box);
    if (currIdx === -1) return;

    // Initialize anchor on first interaction
    if (lastCtrlIdx === null) lastCtrlIdx = currIdx;

const selectRow = async (row) => {
  const rid = String(row.dataset.receipt);

  if (!selectedOrders.has(rid)){
    selectedOrders.add(rid);
    row.classList.add("selected");

    // write lock immediately (micro-batched)
    rtQueueLock(rid);

    // then fetch items & render previews without blocking the click flow
    (async ()=>{
      try{
     const myRun = updateRunId;                 // snapshot
     if (!orderCache[rid]) {          const ord = await pullEtsyOrderDetails(rid);
     if (myRun !== updateRunId) return;       // run changed; discard
        orderCache[rid] = ord?.transactions || [];          refreshRowCount(rid);
          refreshRowMetalCounts(rid);
        }
        orderCache[rid].forEach(tx => { if (!tx._inGrid) addPreviewBox(tx); });
        realignGrid(); updateCounters(); persistSelection(); applyMetalFilter();
      }catch(e){ console.warn("ensure/load failed for", rid, e); }
    })();
  }
};

  const deselectRow = (row) => {
    const rid = String(row.dataset.receipt);
    if (!selectedOrders.has(rid)) return;
    selectedOrders.delete(rid);
    row.classList.remove("selected");
    removePreviewBoxesForOrder(rid);
    // micro-batched realtime unlock (no await, no race)
    rtQueueUnlock(rid);
  };

  if (e.ctrlKey || e.metaKey){
    // Range select (inclusive) from last anchor ‚Üí current
    const [from, to] = currIdx > lastCtrlIdx ? [lastCtrlIdx, currIdx] : [currIdx, lastCtrlIdx];
    for (let i = from; i <= to; i++){
      await selectRow(rows[i]);   // range never deselects
    }
    lastCtrlIdx = currIdx;        // advance anchor
  } else {
    // Plain click ‚Üí toggle only this row, set new anchor
    const rid = String(box.dataset.receipt);
    if (selectedOrders.has(rid)) {
      deselectRow(box);
    } else {
      await selectRow(box);
    }
    lastCtrlIdx = currIdx;        // set/advance anchor
  }

    // UI refresh
    realignGrid();
    updateCounters();
    persistSelection();
    applyMetalFilter();
  }, true); // <-- capture
}

  /* ‚ù∏  run monthly purge */
  purgeOldCompleted();

  /* NEW ‚ûã: cache the listing-detail modal so helpers can open it */
  listingModal = M.Modal.init(document.getElementById("listingModal"));

  setTimeout(function () {
    loadPositions();
    document.body.style.opacity = 1;
  }, 200);

    const modalCompleteChk = document.getElementById("modalCompleteChk");
    modalCompleteChk.addEventListener("change", async () => {
    const rid = modalCompleteChk.dataset.rid;
    if(!rid) return;                      // safety

    /* ‚Äî mark as completed ‚Äî */
    completedOrders.add(rid);             // global Set   [oai_citation:2‚Ä°design-1.html](file-service://file-UD87qPNcvFGdsBetdyBDoA)
    selectedOrders.delete(rid);

    /* remove/hide UI elements */
    document.querySelectorAll(
      `.new-order-box[data-receipt='${rid}']`
    ).forEach(el => el.remove());

    removePreviewBoxesForOrder(rid);      // existing helper
    await persistCompleted([rid]);        // write to Firebase
    updateCounters();
    applyMetalFilter();

    listingModal.close();                 // done ‚Äì pop modal
  });

  // Connect Etsy
  document.getElementById("connectEtsyBtn").addEventListener("click", async function () {
    try {
      const codeVerifier = generateRandomString(64);
      localStorage.setItem("etsy_code_verifier", codeVerifier);
      const codeChallenge = await generateCodeChallenge(codeVerifier);
      const CLIENT_ID = "k75zdspz4r99txpqdji7i2em";
      const redirectUri = "https://design-1.goldenspike.app";
      const state = "randomState123";
      const scope = "listings_w listings_r transactions_r transactions_w";
      const etsyAuthUrl =
        "https://www.etsy.com/oauth/connect?response_type=code" +
        "&client_id=" + CLIENT_ID +
        "&redirect_uri=" + encodeURIComponent(redirectUri) +
        "&scope=" + encodeURIComponent(scope) +
        "&state=" + state +
        "&code_challenge=" + encodeURIComponent(codeChallenge) +
        "&code_challenge_method=S256";
      window.location.href = etsyAuthUrl;
    } catch (err) {
      console.error("OAuth start error:", err);
      M.toast({ html: "OAuth error: " + err.message });
    }
  });

      /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Update-Order-List button ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
      document.getElementById("updateOrderListBtn").addEventListener("click", async function () {
      try {
          // 0) cancel any previous Update‚Äôs background work and start a new run
          abortAllUpdateWork();
          updateRunId++;
          const myRun = updateRunId;
          this.disabled = true;
          this.innerHTML = '<span class="loadingWrap">' +
         '  <span class="spinner"></span>' +
         '  <span class="loadingTxt">Loading‚Ä¶</span>' +
         '</span>';

          orderListOffset = 0;                 // reset to first page
          allOpenReceipts = [];                // üöÄ clear cache ‚Üí next call re-fetches
          const gotRows = await buildNewOrderList(orderListOffset);
          /* Pull latest completed set from Firebase, then paint */
          await restoreCompleted();
          highlightCompletedRows();
          reapplySelectionAndLocks();               // ‚Üê keep oranges when list refreshes

          // FULL refresh of auxiliary indices now that rows are present
          await refreshStaffNoteIDs({ mode: "all" }); // pulls all note owners
          markStaffNoteOrders();
          if (typeof fetchAllLocksOnce === "function") await fetchAllLocksOnce(); // fetch active locks

          /* NEW ‚Üí log visible order count */
          const displayedCount = document.getElementById("newOrderContainer").children.length;
          console.log(`Orders displayed (offset ${orderListOffset}):`, displayedCount);

          // A) first: repair rows with missing/empty transactions
          await repairMissingReceiptData({ passes: 2, concurrency: 4 });
          // B) then: heal any rows still showing 0/0/0/0 metals
          await healZeroMetalRows({ passes: 2, concurrency: 4, reason: "update-click" });
          this.disabled = false;
          this.innerHTML = "Update Order List";
        } catch (err) {
          console.error("Order-list fetch error:", err);
          M.toast({ html: "Order-list error: " + err.message });
          this.disabled = false;
          this.innerHTML = "Update Order List";
        }
      });


      /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Clear button ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
      document.getElementById("clearBtn").addEventListener("click", () => {

        /* bail if nothing is selected */
        if (!selectedOrders.size) return;

        /* 1Ô∏è‚É£ remove browser persistence */
        localStorage.removeItem(SELECTED_KEY);          // legacy key
        localStorage.removeItem(STORAGE_KEY);           // current key "savedSelection"

        /* 2Ô∏è‚É£ loop through every receipt in the orange Set */
        selectedOrders.forEach(rid => {

          /* A. remove orange class from left-column row (if still in DOM) */
          const row = document.querySelector(
            `.new-order-box[data-receipt='${rid}']`);
          if (row) row.classList.remove("selected");
          // üîì unlock each cleared receipt in Firebase
          try { rtSet(rid, false); } catch (_) {}

          /* A2. explicit realtime unlock */
          try { rtSet(rid, false); } catch(_) {}

          /* B. nuke every preview wrap for that receipt (even if not orange) */
          document.querySelectorAll(
            `#photoGridContainer .wrap-preview[data-receipt='${rid}']`
          ).forEach(wrap => {
            /* drop from gridElements Map */
            for (const [k,v] of gridElements.entries()){
              if (v === wrap){ gridElements.delete(k); break; }
            }
            /* drop duplicate-guard */
            if (wrap.dataset.tx) processedTxIds.delete(wrap.dataset.tx);
            wrap.remove();                                 // remove from DOM
          });

          /* C. scrub caches */
          delete orderCache[rid];
          /* remove matching items from cachedOrderItems array */
          if (Array.isArray(window.cachedOrderItems)){
            window.cachedOrderItems =
              window.cachedOrderItems.filter(it => it.receipt_id !== rid);
          }
        });

        /* 3Ô∏è‚É£ finally clear the Set itself */
        selectedOrders.clear();

        /* 4Ô∏è‚É£ tidy UI */
        reflowGrid();            // closes photo-grid gaps
        updateCounters();        // top counters
        window.applyMetalFilter(); /* keeps current filter state */

        M.toast({ html: "Selection cleared" });
      });

      /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Clear Completed (green) button  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 
      const clrCompBtn = document.getElementById("clearCompletedBtn");
      if (clrCompBtn) {
        clrCompBtn.addEventListener("click", clearCompleted);   // ‚Üê NEW
      }*/

  // Load multiple orders on Enter (partial snippet)
  const etsyOrderInput = document.getElementById("etsyOrderNumber");
  etsyOrderInput.addEventListener("keydown", async function (e) {
    if (e.key === "Enter") {

      // NEW: cancel *all* outstanding fetches / work from a previous run
      pendingFetchControllers.forEach(ctrl => ctrl.abort());
      pendingFetchControllers = [];     // fresh list for this run

      globalRunId++;                    // ‚Üê bump run ID so old tasks quit

      // Reset arrays & state
      croppedImagesArray = [];
      userImagesArray = [];
      cellMatches = {};
      window.cachedOrderItems = [];
      matchPrintFlowInProgress = false;

  
      // Clear UI
      document.getElementById("photoGridContainer").innerHTML = "";
      const unmatchedEl = document.getElementById("unmatchedContainer");
      if (unmatchedEl) unmatchedEl.innerHTML = "";

      disableSendMatch();
      disableMatchPrintFlow();
      removeAllBlueHighlights();

      const inputVal = etsyOrderInput.value.trim();
      if (!inputVal) return;
      if (!inputVal.includes(",")) return;   // üëà skip bulk loader for single-order search

      let orderNumbers = inputVal
        .split(",")
        .map((x) => x.trim())
        .filter((x) => x);
      orderNumbers = orderNumbers.slice(0, 500);

      await loadBatchEtsyOrders(orderNumbers);
    }
  });

  /* ==============================================================
   *  Single-order SEARCH via #etsyOrderNumber
   * ============================================================*/
  (function attachSearch(){
    const input = document.getElementById("etsyOrderNumber");
    if (!input) return;

    /* ENTER ‚Üí run single-order search when no commas are present */
    input.addEventListener("keydown", async e => {
      searchActive = true;
      if (e.key !== "Enter") return;
      const raw = input.value.trim();
      if (!raw || raw.includes(",")) return;   // bulk loader handles lists
      e.preventDefault();
      e.stopImmediatePropagation();

      try {
        /* 1Ô∏è‚É£ snapshot UI (first time only) */
        const pg = document.getElementById("pageButtonsContainer");
        if (pg) pg.hidden = true;

        if (!searchSnapshot){
          searchSnapshot = {
            orderHTML : document.getElementById("newOrderContainer").innerHTML,
            gridHTML  : document.getElementById("photoGridContainer").innerHTML,
            gridMap   : new Map(gridElements)
          };
        }

        /* 2Ô∏è‚É£ clear current containers & map */
        document.getElementById("newOrderContainer").innerHTML  = "";
        document.getElementById("photoGridContainer").innerHTML = "";
        gridElements.clear();

        /* 3Ô∏è‚É£ fetch FULL order (includes personalization + buyer message) */
        M.toast({ html: `Searching ${raw}‚Ä¶` });
        const data    = await pullEtsyOrderDetails(raw);   // ‚Üê proxy call
        if (!data) throw new Error("Order not found");
        const txs     = data.transactions || [];
        const receipt = data.receipt     || {};
        const rid     = String(receipt.receipt_id || raw);

        /* ‚îÄ‚îÄ derive a readable ‚ÄúShip By‚Äù string ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
        let shipDate = "N/A";
        const tsRaw =
                receipt.expected_ship_date ??
                receipt.dispatch_date      ??
                receipt.ship_by_date       ??
                txs[0]?.expected_ship_date ??
                txs[0]?.dispatch_date      ??
                txs[0]?.ship_by_date       ?? 0;

        if (typeof tsRaw === "number" && tsRaw > 86400) {
          const d = new Date(tsRaw * 1000);
          shipDate = d.toLocaleDateString("en-US", { month: "short", day: "2-digit" });
        } else if (typeof tsRaw === "string" && tsRaw.trim()) {
          shipDate = tsRaw;
        }

        /* 4Ô∏è‚É£ cache transactions so click-handlers work */
        orderCache[rid] = txs;

        /* 5Ô∏è‚É£ compute metal / qty counts */
        const cnt = { g:0, s:0, r:0, k:0 };
        txs.forEach(tx => {
          const q = tx.quantity || 1;
          switch (tx._metalKey) {
            case "gold":   cnt.g += q; break;
            case "silver": cnt.s += q; break;
            case "rose":   cnt.r += q; break;
            case "14k":    cnt.k += q; break;
          }
        });
        let rowMetal = "";
        if      (cnt.k) rowMetal = "14k";
        else if (cnt.r) rowMetal = "rose";
        else if (cnt.s) rowMetal = "silver";
        else if (cnt.g) rowMetal = "gold";

        /* 6Ô∏è‚É£ build sidebar row */
        const row = document.createElement("div");
        row.className       = "new-order-box";
        row.dataset.receipt = rid;
        row.dataset.metal   = rowMetal;
        row.innerHTML = `
          <span class="col-order">${receipt.order_number || raw}</span>
          <span class="col-ship">${shipDate}</span>
          <span class="col-g">${cnt.g}</span>
          <span class="col-s">${cnt.s}</span>
          <span class="col-r">${cnt.r}</span>
          <span class="col-k">${cnt.k}</span>`;
        document.getElementById("newOrderContainer").appendChild(row);

        /* colour row if it was already green/orange */
        if (completedOrders.has(rid))      row.classList.add("completed");
        else if (selectedOrders.has(rid))  row.classList.add("selected");

        /* 7Ô∏è‚É£ add preview tiles */
        txs.forEach(tx => { if (!tx._inGrid) addPreviewBox(tx); });

        /* 8Ô∏è‚É£ wire the row with normal click / hover listeners */
        (function wireRow(box){
          if (box.dataset.wired) return;
          box.dataset.wired = "1";

          /* CLICK ‚Üí toggle select */
          box.addEventListener("click", async e => {
          if (e.ctrlKey || e.metaKey) return;   // range-selector handles these
            const rid = String(box.dataset.receipt);

            if (selectedOrders.has(rid)) {          /* ‚Äî DESELECT ‚Äî */
              selectedOrders.delete(rid);
              box.classList.remove("selected");
              removePreviewBoxesForOrder(rid);
              // üîì unlock in Firebase on deselect
              rtQueueUnlock(rid);
              realignGrid(); updateCounters(); persistSelection(); applyMetalFilter();
              return;
            }

            /* ‚Äî SELECT ‚Äî */
            selectedOrders.add(rid);
            box.classList.add("selected");
            /* set range-anchor on plain click */
            lastCtrlIdx = [...document.querySelectorAll("#newOrderContainer .new-order-box")]
                      .indexOf(box);
            orderCache[rid].forEach(tx => { if (!tx._inGrid) addPreviewBox(tx); });
            realignGrid(); updateCounters(); persistSelection(); applyMetalFilter();
            // ‚úÖ lock it in Firebase
            rtQueueLock(rid);
          });

          /* HOVER ‚Üí outline concurrent previews */
          box.addEventListener("mouseenter", () => {
            if (!box.classList.contains("selected")) return;
            const rec = box.dataset.receipt;
            document.querySelectorAll(`#photoGridContainer .wrap-preview[data-receipt='${rec}']`)
                    .forEach(w => w.classList.add("preview-highlight"));
          });
          box.addEventListener("mouseleave", () => {
            const rec = box.dataset.receipt;
            document.querySelectorAll(`#photoGridContainer .wrap-preview[data-receipt='${rec}']`)
                    .forEach(w => w.classList.remove("preview-highlight"));
          });
        })(row);


        /* 9Ô∏è‚É£ final tidy-up */
        reflowGrid();
        updateCounters();
        applyMetalFilter();
        M.toast({ html:`Search complete (${txs.length} item${txs.length!==1?"s":""})` });

      } catch(err){
        console.error(err);
        M.toast({ html:"Order not found" });
      }
    });

    /* Empty box ‚Üí instant restore */
    input.addEventListener("input", async () => {
      if (input.value.trim() !== "") return;
      if (!searchSnapshot) return;
      searchActive = false;

      const pg = document.getElementById("pageButtonsContainer");
      if (pg) pg.hidden = false;

      /* 1Ô∏è‚É£ restore markup */
      document.getElementById("newOrderContainer").innerHTML  = searchSnapshot.orderHTML;
      document.getElementById("photoGridContainer").innerHTML = searchSnapshot.gridHTML;

      /* 2Ô∏è‚É£  Rebuild gridElements + re-hook preview listeners */
      gridElements.clear();
      document
        .querySelectorAll("#photoGridContainer .wrap-preview")
        .forEach((wrap, idx) => {
          const key = Number(wrap.dataset.idx) || idx;
          gridElements.set(key, wrap);

          /* preview zoom / pan / click */
          const boxEl = wrap.querySelector(".preview-box");
          if (boxEl) attachPreviewBoxListeners(boxEl);

          /* restore TX pointers if cachedOrderItems exists */
          const itemIdx = Number(wrap.dataset.idx);
          if (Array.isArray(window.cachedOrderItems) &&
              itemIdx >= 0 &&
              window.cachedOrderItems[itemIdx]) {
            window.cachedOrderItems[itemIdx]._inGrid  = true;
            window.cachedOrderItems[itemIdx]._wrapEl  = wrap;
          
          /* HOVER ‚Üí blue ring on preview + its row */
          wrap.addEventListener("mouseenter", () => {
            wrap.classList.add("hover-blue");
            const row = document.querySelector(`.new-order-box[data-receipt='${wrap.dataset.receipt}']`);
            if (row) row.classList.add("hover-blue");
          });
          wrap.addEventListener("mouseleave", () => {
            wrap.classList.remove("hover-blue");
            const row = document.querySelector(`.new-order-box[data-receipt='${wrap.dataset.receipt}']`);
            if (row) row.classList.remove("hover-blue");
          });

          }
        });

      /* ------- Ensure orange rows show their previews  (FULL REPLACE) ------- */
      selectedOrders.forEach(rid => {
        const list = orderCache[rid];
        if (!Array.isArray(list)) return;        // no cache for this receipt

        list.forEach(tx => {
          /* already have this TX wrap? */
          const wrapPresent = document.querySelector(
            `#photoGridContainer .wrap-preview[data-tx='${tx.transaction_id}']`
          );
          if (wrapPresent) return;

          /* flag reset & inject a fresh tile */
          tx._inGrid = false;                    // mark as absent
          addPreviewBox(tx);                     // re-adds + updates gridElements
        });
      });

      /* 3Ô∏è‚É£  Re-attach click / hover logic to every order row */
      document.querySelectorAll(".new-order-box").forEach(box => delete box.dataset.wired);  // reset flag
      document.querySelectorAll(".new-order-box").forEach(box => {
        if (box.dataset.wired) return;      // prevent duplicate wiring
        box.dataset.wired = "1";

        /* CLICK ‚Üí toggle orange selection & preview sync */
        box.addEventListener("click", async e => {
        if (e.ctrlKey || e.metaKey) return;   // range-selector handles these
          const rid = String(box.dataset.receipt);

          if (selectedOrders.has(rid)) {    /* ‚Äî DESELECT ‚Äî */
            selectedOrders.delete(rid);
            box.classList.remove("selected");
            removePreviewBoxesForOrder(rid);
            realignGrid();
            updateCounters();
            persistSelection();
            applyMetalFilter();
            try { rtSet(rid, false); } catch (_) {}
            return;
          }

          /* ‚Äî SELECT ‚Äî */
          selectedOrders.add(rid);
          box.classList.add("selected");

          if (!orderCache[rid]) {
            const ord = await pullEtsyOrderDetails(rid);
            orderCache[rid] = ord?.transactions || [];
            refreshRowCount(rid);
            refreshRowMetalCounts(rid);
          }
          orderCache[rid].forEach(tx => { if (!tx._inGrid) addPreviewBox(tx); });

          realignGrid();
          updateCounters();
          persistSelection();
          applyMetalFilter();
        });

        /* HOVER ‚Üí outline concurrent previews */
        box.addEventListener("mouseenter", () => {
          if (!box.classList.contains("selected")) return;
          const rec = box.dataset.receipt;
          document
            .querySelectorAll(`#photoGridContainer .wrap-preview[data-receipt='${rec}']`)
            .forEach(w => w.classList.add("preview-highlight"));
        });
        box.addEventListener("mouseleave", () => {
          const rec = box.dataset.receipt;
          document
            .querySelectorAll(`#photoGridContainer .wrap-preview[data-receipt='${rec}']`)
            .forEach(w => w.classList.remove("preview-highlight"));
        });

        /* HOVER ‚Üí blue ring on row + all its previews */
        box.addEventListener("mouseenter", () => {
          box.classList.add("hover-blue");
          document
            .querySelectorAll(`#photoGridContainer .wrap-preview[data-receipt='${box.dataset.receipt}']`)
            .forEach(w => w.classList.add("hover-blue"));
        });
        box.addEventListener("mouseleave", () => {
          box.classList.remove("hover-blue");
          document
            .querySelectorAll(`#photoGridContainer .wrap-preview[data-receipt='${box.dataset.receipt}']`)
            .forEach(w => w.classList.remove("hover-blue"));
        });

        /* ‚ñº‚ñº  PASTE THE NEW BLOCK RIGHT HERE  ‚ñº‚ñº */
        box.addEventListener("mouseenter", () => {
          box.classList.add("hover-blue");
          document
            .querySelectorAll(`#photoGridContainer .wrap-preview[data-receipt='${box.dataset.receipt}']`)
            .forEach(w => w.classList.add("hover-blue"));
        });
        box.addEventListener("mouseleave", () => {
          box.classList.remove("hover-blue");
          document
            .querySelectorAll(`#photoGridContainer .wrap-preview[data-receipt='${box.dataset.receipt}']`)
            .forEach(w => w.classList.remove("hover-blue"));
        });

      });

      /* 4Ô∏è‚É£ final tidy-up */
      reflowGrid();
      updateCounters();
      applyMetalFilter();
      highlightCompletedRows();
      highlightSavedRows();

      searchSnapshot = null;
      M.toast({ html:"Search cleared" });
    });

  })();   /* ‚Üê single, final close of attachSearch */

  /* =====================================================================
   *  LOCAL-STORAGE PERSISTENCE  ‚Äî  selected orders + their transactions
   * ===================================================================== */
  const idStr = id => String(id);             // ‚Üê helper: always use string ids
  const STORAGE_KEY = "savedSelection";

  /* write current orange receipts ONLY (no transactions) */
  function persistSelection(){
    try{
      const data = {
        selected: [ ...selectedOrders ]   // simple string/number array
    };
      localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
    }catch(err){
      console.warn("localStorage quota hit ‚Äî selection not saved:", err.message);
    }
  }

  /* read the saved receipt-ID list and rebuild from scratch */
  function restoreSelections(){
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) return;

    let data;  try{ data = JSON.parse(raw); } catch(e){ return; }

    /* 1Ô∏è‚É£  revive the set of selected order IDs ------------------ */
    selectedOrders.clear();
    (data.selected || []).forEach(id => selectedOrders.add(id));

    /* 2Ô∏è‚É£  wipe existing cache + grid ---------------------------- */
    Object.keys(orderCache).forEach(k => delete orderCache[k]);
    gridElements.clear();
    document.getElementById("photoGridContainer").innerHTML = "";

    /* 3Ô∏è‚É£  fetch each order again and rebuild previews ----------- */
    selectedOrders.forEach(async id => {
      const ord = await pullEtsyOrderDetails(id);   // fresh call to Etsy
      if (!ord) return;

      orderCache[id] = ord.transactions || [];
      orderCache[id].forEach(tx => addPreviewBox(tx));
    });

    /* 4Ô∏è‚É£  after boxes exist, colour the corresponding rows orange */
    setTimeout(() => {
    selectedOrders.forEach(id => {
      if (completedOrders.has(id)) return;        // ‚Üê NEW: skip green rows
      const row = document.querySelector(`.new-order-box[data-receipt='${id}']`);
      if (row) row.classList.add("selected");
    });
    scheduleHealMissingLocks();   // push locks for restored selections
    }, 0);

    updateCounters();                    // refresh metal totals
  }


   /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ QR-preview helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */

   /* Normalise to 4 allowed metals */
    function canonicalMetal(str){
      const m = String(str || "").toLowerCase();
      if (/\b14\s*k(?:t|arat)?\b/.test(m) || /solid/.test(m)) return "14k";
      if (/rose/.test(m))   return "rose";
      if (/silv/.test(m))   return "silver";
      if (/gold/.test(m))   return "gold";
      return "";
    }

   function toB36(numStr){
     const clean=String(numStr).trim();
     if(!/^\d+$/.test(clean)) return clean;
     let n=BigInt(clean); if(n===0n) return "0";
     const digs="0123456789abcdefghijklmnopqrstuvwxyz"; let out="";
     while(n>0n){ const r=Number(n%36n); out=digs[r]+out; n=n/36n; }
     return out;
   }
   function encodeOrderList(ids,metal){
     const b36=(ids||[]).map(x=>{
       const d=String(x).replace(/\D/g,""); return d?toB36(d):String(x);
     });
     return `B36|${metal}|`+b36.join(".");
   }

   // NEW: split into variable-sized slices so QR payload stays under a safe limit
   // Uses encodeOrderList(slice, metal) length as a proxy for capacity.
   function safeChunks(arr, metal, maxChars = 1000, startSize = 50, minSize = 8){
     const out = [];
     let i = 0, size = startSize;
     while (i < arr.length){
       let slice = arr.slice(i, i + size);
       let payload = encodeOrderList(slice, metal);
       if (payload.length > maxChars && size > minSize){
         size = Math.max(minSize, Math.floor(size * 0.75)); // shrink & retry
         continue;
       }
       out.push(slice);
       i += slice.length;
     }
     return out;
   }

    function showQrPreviewModal(lists){
      const skipped = window._qrSkippedOrders || [];
      const grid = document.getElementById("qrPreviewGrid");
      grid.innerHTML = "";

      Object.entries(lists).forEach(([m, arr]) => {
        if (!arr.length) return;

        const pieces = safeChunks(arr, m, 1000, 50, 8); // ‚Üê adaptive ‚â§1000 chars
        pieces.forEach((slice, idx) => {
          const holder = document.createElement("div");
          holder.style.cssText = "width:120px;text-align:center";

          // Label shows per-slice count, total, and slice index if chunked
          const part = pieces.length > 1 ? ` [${idx + 1}/${pieces.length}]` : "";
          const total = arr.length > 50 ? ` of ${arr.length}` : "";
          const label = `${m.toUpperCase()} (${slice.length}${total})${part}`;

          holder.innerHTML = `
            <div id="qr_${m}_${idx}"></div>
            <div style="font-size:.8em;margin-top:4px;">${label}</div>`;
          grid.appendChild(holder);

          try{
            new QRCode(holder.firstElementChild, {
              text: encodeOrderList(slice, m),         // ‚Üê PER-SLICE payload
              width: 110,
              height: 110,
              correctLevel: QRCode.CorrectLevel.M      // more capacity than H
            });
          }catch(e){
            console.warn("QR overflow at preview, retry with ECC=L:", e.message);
            new QRCode(holder.firstElementChild, {
              text: encodeOrderList(slice, m),
              width: 110,
              height: 110,
              correctLevel: QRCode.CorrectLevel.L      // last-resort
            });
          }
        });
      });

      // Keep the original lists object for printing/completion logic
      window._pendingMetalLists = lists;

      /* ‚è©  display skipped receipts */
      const skipBox = document.getElementById("qrSkippedContainer");
      if (skipBox) {
        if (skipped.length) {
          skipBox.innerHTML = `<b>Skipped&nbsp;orders:</b> ${skipped.join(", ")}`;
          skipBox.style.display = "";
        } else {
          skipBox.innerHTML = "";
          skipBox.style.display = "none";
        }
      }

      (M.Modal.getInstance(document.getElementById("qrPreviewModal"))
        || M.Modal.init(document.getElementById("qrPreviewModal"))).open();

      /* üîÑ  (re)wire Print Labels every time the modal is built */
      const btn = document.getElementById("qrPreviewPrintBtn");
      if (btn && !btn.dataset.wired) {
        btn.dataset.wired = "1";
        btn.addEventListener("click", e => {
          e.preventDefault();            // keep the modal steady
          proceedToPrint(window._pendingMetalLists);
        });
      }
    }
    /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
     * NEW: Mark Brites Messages "DESIGNED :)" for a list of orders
     * Mirrors weld-1 flow (Netlify function), with Firestore fallback.
     * ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
    async function markBritesDesigned(orderIds){
      const ids = Array.from(new Set((orderIds || []).map(String)));
      if (!ids.length) return;

      const staff = (localStorage.getItem("employee_name") || "Design").trim();

      // small batches to be gentle on Netlify/function cold starts
      const chunk = (arr, n=10) => {
        const out = []; for (let i=0;i<arr.length;i+=n) out.push(arr.slice(i,i+n)); return out;
      };
      for (const group of chunk(ids, 10)){
        await Promise.all(group.map(async (rid) => {
          try {
            const resp = await fetch(`${functionsBaseUrl}/firebaseOrders`, {
              method : "POST",
              headers: { "Content-Type": "application/json" },
              body   : JSON.stringify({
                orderNumber : rid,
                newMessage  : "DESIGNED :)",
                employeeName: staff
              })
            });
            if (!resp.ok) throw new Error("HTTP " + resp.status);
          } catch (err) {
            // Fallback ‚Üí direct Firestore upsert + message
            try {
              await db.collection("Brites_Orders").doc(String(rid)).set({}, { merge:true });
              await db.collection("Brites_Orders").doc(String(rid)).collection("messages").add({
                text      : "DESIGNED :)",
                senderName: staff,
                senderRole: "staff",
                timestamp : firebase.firestore.FieldValue.serverTimestamp()
              });
            } catch (ee) {
              console.warn("markBritesDesigned fallback failed:", ee);
            }
          }
        }));
      }
    }

    async function proceedToPrint(lists){

     /* ‚îÄ‚îÄ 1. bail early if there is truly nothing to print ‚îÄ‚îÄ */
     if(!lists || !Object.values(lists).some(arr=>arr.length)){
       M.toast({ html:"No order labels to print" });
       return;
     }

      /* 3Ô∏è‚É£  Commit printed orders as completed & tidy UI */
      const printedIDs = Object.values(lists).flat();      
      if (printedIDs.length) {
        lastClearedReceipts = [...printedIDs];
    
         printedIDs.forEach(rid => {
           // 1) Clear previews first (force so we never get blocked)
           removePreviewBoxesForOrder(rid, { force: true });

           // 2) Remove the sidebar row
           document
             .querySelectorAll(`.new-order-box[data-receipt='${rid}']`)
             .forEach(r => r.remove());

           // 3) Scrub caches & selection
           delete orderCache[rid];
           selectedOrders.delete(String(rid));

           // 4) Finally mark as completed (so future removals skip as intended)
           completedOrders.add(String(rid));
         });
    
        allOpenReceipts = allOpenReceipts
          .filter(r => !printedIDs.includes(String(r.receipt_id)));
    
        await persistCompleted(printedIDs);      // ‚Üê write to Firebase (bulk)
        // After: await persistCompleted(printedIDs);
        try{
          await fetch(`${functionsBaseUrl}/firebaseOrders`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ rtUnlockIds: printedIDs.map(String), clientId: RT.clientId })
          });
        }catch(e){ console.warn("Unlock after complete failed:", e); }        
        persistSelection();
        reflowGrid();
        updateCounters();
        applyMetalFilter();
        M.toast({ html: `${printedIDs.length} order${printedIDs.length !== 1 ? "s" : ""} completed` });

        // NEW: stamp Brites Messages before the print dialog
        try { await markBritesDesigned(printedIDs); }
        catch (e) { console.warn("markBritesDesigned failed:", e); }
      }
 
     printDialogOpened = true;                // mark pending-print
     const metalOrderJobs = [];
     Object.entries(lists).forEach(([metal, ids]) => {
       if (!Array.isArray(ids) || !ids.length) return;
      // Keep each QR payload comfortably under capacity for grcode.min.js too
      const parts = safeChunks(ids, metal, 1000, 50, 8);
       parts.forEach((slice, idx) => {
         metalOrderJobs.push({
           metal,
           ids: slice,
           partIndex: idx + 1,
           partTotal: parts.length,
           total: ids.length
         });
       });
     });
     localStorage.setItem("metalOrderJobs", JSON.stringify(metalOrderJobs)); // new
     localStorage.setItem("metalOrderLists", JSON.stringify(lists));         // back-compat
 
     /* ‚îÄ‚îÄ 2. spawn hidden iframe *then* open system print dialog ‚îÄ‚îÄ */
     const f = document.createElement("iframe");
     f.style.cssText="position:fixed;visibility:hidden;right:9999px;width:1px;height:1px;";
     f.src = "design-print-1.html";

     // print is now triggered inside design-print-1.html
     document.body.appendChild(f);
   }
   document.addEventListener("DOMContentLoaded",()=>{
   const p = document.getElementById("qrPreviewPrintBtn");
   if(p && !p.dataset.wired){
     p.dataset.wired = "1";
     p.addEventListener("click", e => {
       e.preventDefault();                   // keep modal steady
       proceedToPrint(window._pendingMetalLists);
     });
    }
   });


  /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ handleCompleteClick ‚Äî URL-SAFE VERSION ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  async function handleCompleteClick() {
   /* 1Ô∏è‚É£  gather which metal filters are ON (we‚Äôll happily continue even if some are off) */
   const active = Array.from(
     document.querySelectorAll('.metal-counter.active:not([data-metal="completed"])')
   ).map(b => b.dataset.metal);

   // üëá keep the legacy checks happy
   const REQUIRED = active.slice();      // ‚Üê NEW LINE
   const selSet = new Set([...selectedOrders].map(String));
 
   if (!active.length) {                       // nothing selected at all
     M.toast({html:"Enable at least one metal filter before printing labels"});
     return;
   }

    /* 2Ô∏è‚É£  collect every visible preview that matches those metals */

    // ‚îÄ‚îÄ identify orders that span multiple metals ‚îÄ‚îÄ
    const metalSets = {};
    document
      .querySelectorAll("#photoGridContainer .wrap-preview")
      .forEach(w => {
        const rid = w.dataset.receipt;
         metalSets[rid] = metalSets[rid] || new Set();
         const m = canonicalMetal(w.dataset.metal);
         if(m) metalSets[rid].add(m);
      });
    const multiMetalOrders = new Set(
      Object.entries(metalSets)
            .filter(([, metals]) => metals.size > 1)
            .map(([rid]) => rid)
    );

     const listsByMetal  = { gold: [], silver: [], rose: [], "14k": [] };
     const skippedOrders = new Set();              // ‚Üê keep track
     const greenIDs = new Set();

    // ‚îÄ‚îÄ include mixed-metal orders so they get removed from the sidebar too ‚îÄ‚îÄ
    multiMetalOrders.forEach(rid => greenIDs.add(rid));

    document.querySelectorAll("#photoGridContainer .wrap-preview").forEach(w => {
      const rid   = String(w.dataset.receipt);
      const metal = canonicalMetal(w.dataset.metal);
      const isSelected = selSet.has(rid);

      if (!metal) { skippedOrders.add(rid); return; }
      // If the order is selected, include it even if the current metal filter hides it
      if (!isSelected && !active.includes(metal)) return;

      if (multiMetalOrders.has(rid)) return;
      greenIDs.add(rid);
      if (!listsByMetal[metal].includes(rid)) listsByMetal[metal].push(rid);
    });

    if (!greenIDs.size) {
      M.toast({ html: "No matching orders" });
      return;
    }

    /* 3Ô∏è‚É£  Defer UI cleanup‚Äîwill run after ‚ÄúPrint Labels‚Äù */
    // Ensure all selected orders are included, even if hidden or metal flipped late
    [...selectedOrders].forEach(ridRaw => {
      const rid = String(ridRaw);
      if (greenIDs.has(rid) || skippedOrders.has(rid)) return;

      const txs = orderCache[rid] || [];
      let k = "";
      for (const tx of txs) { k = deriveMetalKeyFromVariations(tx); if (k) break; }

      if (k && listsByMetal[k]) {
        if (!listsByMetal[k].includes(rid)) listsByMetal[k].push(rid);
        greenIDs.add(rid);
      } else {
        skippedOrders.add(rid);
      }
    });
     multiMetalOrders.forEach(rid=>{
         const metals = Array.from(metalSets[rid]).filter(m => listsByMetal[m]);
         if(!metals.length){
           console.warn("Unknown metal(s) for order", rid, Array.from(metalSets[rid]));
           return;          // skip this receipt safely
         }
         const target = metals.reduce(
         (a,b)=>listsByMetal[a].length<=listsByMetal[b].length?a:b
       );
       listsByMetal[target].push(rid);
     });
 
      /* üî∏ Keep ONLY orders whose items have zero recognised metals */
      const zeroMetalOrders = [...skippedOrders]
        .filter(rid => (metalSets[rid]?.size || 0) === 0);

      // expose the filtered set so the modal can read it
      window._qrSkippedOrders = zeroMetalOrders;
       showQrPreviewModal(listsByMetal);

      /* ‚úã EARLY EXIT ‚Äî generate QR preview only.
      Do NOT mutate or remove any lists at this stage. */
      return; 
  }

  /* LOCAL, write-once completion ledger (immutable unless explicit Undo) */
  const LOCAL_COMPLETED_KEY = "designCompletedLedger.v1";

  function loadLocalCompleted(){
    try {
      const m = JSON.parse(localStorage.getItem(LOCAL_COMPLETED_KEY) || "{}");
      return new Set(Object.keys(m).map(String));
    } catch (_) {
      return new Set();
    }
  }

  function addToLocalCompleted(ids){
    try {
      const m = JSON.parse(localStorage.getItem(LOCAL_COMPLETED_KEY) || "{}");
      const now = Date.now();
      (ids || []).map(String).forEach(id => { m[id] = now; });
      localStorage.setItem(LOCAL_COMPLETED_KEY, JSON.stringify(m));
    } catch (_) {}
  }

  function removeFromLocalCompleted(ids){
    try {
      const m = JSON.parse(localStorage.getItem(LOCAL_COMPLETED_KEY) || "{}");
      (ids || []).map(String).forEach(id => { delete m[id]; });
      localStorage.setItem(LOCAL_COMPLETED_KEY, JSON.stringify(m));
    } catch (_) {}
  }

  /* ‚îÄ‚îÄ save completed list to Firebase (optionally accept a subset) ‚îÄ‚îÄ */
  async function persistCompleted(ids){
    try{
      const list = Array.isArray(ids) ? ids.map(String) : [...completedOrders];
      if (!list.length) return;


      addToLocalCompleted(list);   // ‚Üê NEW: make the completion sticky locally

      // Use bulk when possible to minimize round-trips
      const resp = await fetch(`${functionsBaseUrl}/firebaseOrders`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ completedIds: list })
      });
      if (!resp.ok) console.warn("persistCompleted: HTTP", resp.status);
    }catch(err){
      console.warn("persistCompleted (Firebase) failed:", err);
    }
  }

  /* ‚îÄ‚îÄ unset completed (bulk) in Firebase for Undo ‚îÄ‚îÄ */
  async function unsetDesignCompletedBulk(ids){
    try{
      const list = Array.isArray(ids) ? ids.map(String) : [];
      if (!list.length) return;

      const resp = await fetch(`${functionsBaseUrl}/firebaseOrders`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ uncompleteIds: list })
      });
      if (!resp.ok) console.warn("unsetDesignCompletedBulk: HTTP", resp.status);
    }catch(err){
      console.warn("unsetDesignCompletedBulk failed:", err);
    }
  }

   /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ handleUndoCompleteClick ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  async function handleUndoCompleteClick(){

    if (!lastClearedReceipts.length){
      M.toast({ html:"Nothing to undo" });    // safety guard
      return;
    }

    for (const rid of lastClearedReceipts){
      completedOrders.delete(rid);        // remove green status
      selectedOrders.add(rid);            // mark orange again (for the undoing user)

      const _row = document.querySelector(`.new-order-box[data-receipt='${rid}']`);
      if (_row && !_row.classList.contains("rt-locked")) {
        _row.classList.add("selected");   // local orange
      }

      // üî¥ Assert a realtime lock so EVERYONE ELSE sees Light Red (rt-selected/rt-locked)
      try { await rtSet(String(rid), true); } catch (e) { console.warn("lock on undo failed", e); }

      /* üîÑ  clear any leftover wraps so counters don‚Äôt double */
      removePreviewBoxesForOrder(rid);    // resets _inGrid flags too

      /* ensure sidebar row exists ‚Äì if missing, fetch it and push the
         receipt object back into `allOpenReceipts` so
         `buildNewOrderList()` can recreate the row */
      if (!document.querySelector(`.new-order-box[data-receipt='${rid}']`)){
        const ord = await pullEtsyOrderDetails(rid);
        if (ord){
          /* ‚ú® rebuild helper meta so buildNewOrderList can sort/render */
          let ts = null;
          if (Array.isArray(ord.transactions) &&
              ord.transactions[0]?.expected_ship_date){
            ts = ord.transactions[0].expected_ship_date;
          }
          if (!ts) ts = ord.dispatch_date || ord.ship_by_date || 0;
          ord._shipTS  = ts;
          ord._shipStr = ts
            ? new Date(ts*1000).toLocaleDateString(
                "en-US",{month:"short",day:"2-digit"})
            : "N/A";

          const mc = { Gold:0, Silver:0, "Rose G":0, "14K":0 };
          (ord.transactions||[]).forEach(t=>{
            const q   = t.quantity||1;
            const val = (t._metalKey||"").toLowerCase();
            if (/14k/.test(val))          mc["14K"]    += q;
            else if (/rose/.test(val))    mc["Rose G"] += q;
            else if (/silv/.test(val))    mc.Silver    += q;
            else if (/gold/.test(val))    mc.Gold      += q;
          });
          ord._metalCounts = mc;

          /* avoid duplicates before pushing back */
          if (!allOpenReceipts.some(r => String(r.receipt_id) === String(rid))){
            allOpenReceipts.push(ord);    // restore master list
          }

          orderCache[rid] = ord.transactions || [];
        }
      }

      /* restore preview boxes */
      orderCache[rid]?.forEach(tx=>{
        if (!tx._inGrid) addPreviewBox(tx);
      });
    }

    /* redraw sidebar starting at page 1 so restored rows show */
    orderListOffset = 0;
    await buildNewOrderList(0);                      // refresh UI

    /* sync everything back to server (removes from Completed so others re-add) */
    await unsetDesignCompletedBulk(lastClearedReceipts);
    removeFromLocalCompleted(lastClearedReceipts); // ‚Üê NEW

    persistSelection();
    updateCounters();
    applyMetalFilter();
    highlightSavedRows();

    lastClearedReceipts = [];             // clear the buffer
    M.toast({ html:"Undo Complete ‚Äì orders restored" });
  }

  /* -------------------------------------------------------------
     Clear all completed-order memory & remove green highlights
  ------------------------------------------------------------- */
  function clearCompleted(){

    /* snapshot IDs before we wipe the Set */
    const greens = [ ...completedOrders ];

    /* 1 ‚ñ∏ purge localStorage buckets */
    localStorage.removeItem(COMPLETED_KEY);    // ID buckets
    localStorage.removeItem(LAST_PURGE_KEY);   // last-purge stamp

    /* 2 ‚ñ∏ reset in-memory tracking */
    completedOrders.clear();

    /* 3 ‚ñ∏ remove every green row & its previews */
    greens.forEach(rid => {

      /* A. sidebar row */
      document.querySelectorAll(
        `.new-order-box[data-receipt='${rid}']`
      ).forEach(row => row.classList.remove("completed"));

      /* B. photo-grid wraps */
      document.querySelectorAll(
        `#photoGridContainer .wrap-preview[data-receipt='${rid}']`
      ).forEach(wrap => {
        for (const [k,v] of gridElements.entries()){
          if (v === wrap){ gridElements.delete(k); break; }
        }
        wrap.remove();
      });

      /* C. caches */
      delete orderCache[rid];
      processedTxIds.forEach(txid=>{
        if (txid.startsWith(rid)) processedTxIds.delete(txid);
      });
    });

    /* D. trim the global item cache (if it exists) */
    if (Array.isArray(window.cachedOrderItems)){
      window.cachedOrderItems =
        window.cachedOrderItems.filter(it =>
          !greens.includes(String(it.receipt_id)));
    }

    /* 4 ‚ñ∏ UI tidy */
    reflowGrid();
    updateCounters();
    window.applyMetalFilter();

    M.toast({ html:"Completed orders cleared" });
  }

  /* ‚îÄ‚îÄ restore completed list on load ‚Äî from Firebase ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  async function restoreCompleted(){
    try{
      const res  = await fetch(`${functionsBaseUrl}/firebaseOrders?designCompleted=1`);
      const json = await res.json();

      completedOrders.clear();
      if (json.success && Array.isArray(json.orderNumbers)) {
        json.orderNumbers.forEach(id => completedOrders.add(String(id)));
      }

      // NEW: merge local sticky completions
      loadLocalCompleted().forEach(id => completedOrders.add(String(id)));

      // paint & tidy
      highlightCompletedRows();
      realignGrid();
      updateCounters();
      window.applyMetalFilter();
    }catch(e){
      console.warn("restoreCompleted (Firebase) failed:", e);
    }
  }

  /* Seed ALL indices once (full) */
async function fullRefreshAllIndices() {
  try {
    // 1) Completed (full) ‚Üí already minimal elsewhere, but full here
    await restoreCompleted();  // uses ?designCompleted=1

    // 2) Staff Notes (full)
    try {
      const r  = await fetch(`${functionsBaseUrl}/firebaseOrders?staffNotes=1`);
      const j  = await r.json();
      const ids = (j.orderNumbers || []).map(String);
      // replace the in-memory set atomically
      if (window.staffNoteIDs instanceof Set) {
        window.staffNoteIDs = new Set(ids);
      } else {
        window.staffNoteIDs = new Set(ids);
      }
    } catch(e) { console.warn("Full staff-notes seed failed:", e); }

    // 3) Active locks (full)
    if (typeof fetchAllLocksOnce === "function") {
      try { await fetchAllLocksOnce(); } catch(e) { console.warn("Full locks seed failed:", e); }
    }

    // Repaint if rows are already on screen
    if (typeof highlightCompletedRows === "function") highlightCompletedRows();
    if (typeof markStaffNoteOrders     === "function") markStaffNoteOrders();
  } catch (e) {
    console.warn("fullRefreshAllIndices failed", e);
  }
}

/* Targeted staff-notes refresher: visible rows only (default) or explicit ids */
async function refreshStaffNoteIDs(opts = {}) {
  const mode = opts.mode || "visible";        // "visible" (default) | "all"
  const ids  = Array.isArray(opts.ids) ? opts.ids.map(String) : null;

  try {
    if (mode === "all") {
      const r  = await fetch(`${functionsBaseUrl}/firebaseOrders?staffNotes=1`);
      const j  = await r.json();
      window.staffNoteIDs = new Set((j.orderNumbers || []).map(String));
      return;
    }

    // visible-only: read as little as possible
    const boxes = document.querySelectorAll("#newOrderContainer .new-order-box");
    const list  = ids || Array.from(boxes).map(el => el.dataset.receipt || el.dataset.orderNumber).filter(Boolean);
    if (!list.length) return;

    const qs  = encodeURIComponent(list.join(","));
    const res = await fetch(`${functionsBaseUrl}/firebaseOrders?staffNotesFor=${qs}`);
    const json = await res.json();
    const visibleSet = new Set((json.orderNumbers || []).map(String));

    // Swap to just what we need for current view
    window.staffNoteIDs = visibleSet;
  } catch (e) {
    console.warn("refreshStaffNoteIDs error", e);
  }
}

  /* ===== Real-time: drive Firebase writes off ORANGE (.selected) state ===== */
  (function wireSelectionObserver(){
    const container = document.getElementById("newOrderContainer");
    if (!container || container.dataset.selObs) return;
    container.dataset.selObs = "1";

    const onSelectedChange = (row, isSelected) => {
      const rid = String(row.dataset.receipt || row.dataset.orderNumber || "");
      if (!rid) return;
      // ignore remote light-red paints
      if (row.classList.contains("rt-selected")) return;

      if (isSelected) selectedOrders.add(rid);
      else selectedOrders.delete(rid);

      // writes are explicit in click handlers; do not mirror CSS back to RT
      // rtSet(rid, isSelected);
    };

    const obs = new MutationObserver((muts) => {
      for (const m of muts) {
        if (m.type === "attributes") {
          const row = m.target;
          if (!row.classList.contains("new-order-box")) continue;
          const had = /\bselected\b/.test(m.oldValue || "");
          const has = row.classList.contains("selected");
          if (had !== has) onSelectedChange(row, has);
        }

          if (m.type === "childList") {
          // NOTE: Page flips re-render rows. Don't treat removals as a user deselect.
          // The addedNodes handler below will re-apply `.selected` from `selectedOrders`.

          // Any newly inserted row whose receipt is in selectedOrders ‚Üí force .selected
          const ensureRowSelected = (row) => {
            if (!row.classList?.contains("new-order-box")) return;
            const rid = String(row.dataset.receipt || row.dataset.orderNumber || "");
            if (!rid) return;
            // green wins if completed
            if (typeof completedOrders !== "undefined" && completedOrders.has(rid)) return;
            if (selectedOrders.has(rid)) row.classList.add("selected");
            if (row.classList.contains("selected")) onSelectedChange(row, true);
            scheduleHealMissingLocks();    // write back missing Firestore locks
          };

          m.addedNodes.forEach(n => {
            if (n.nodeType !== 1) return;
            if (n.classList?.contains("new-order-box")) ensureRowSelected(n);
            n.querySelectorAll?.(".new-order-box").forEach(ensureRowSelected);
          });
        }
      }
    });

    obs.observe(container, {
      attributes: true,
      attributeFilter: ["class"],
      attributeOldValue: true,
      childList: true,
      subtree: true
    });
  })();

  /* ‚îÄ‚îÄ purge buckets older than 2 months (run once per load) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  function purgeOldCompleted(){
    const now = new Date();
    const last   = localStorage.getItem(LAST_PURGE_KEY) || "";
    const nowKey = now.toISOString().slice(0,7);               // "YYYY-MM"

    /* if we already purged this month, skip */
    if (last === nowKey) return;

    const raw = localStorage.getItem(COMPLETED_KEY) || "{}";
    const obj = JSON.parse(raw);

    /* drop buckets older than 2 months */
    Object.keys(obj).forEach(ym=>{
      const [y,m] = ym.split("-").map(n=>parseInt(n,10));
      const dt = new Date(y, m-1);                   // first of that month
      const diff = (now.getFullYear()-dt.getFullYear())*12 + (now.getMonth()-dt.getMonth());
      if (diff > 1) delete obj[ym];                 // keep 0 or 1 months ago
    });

    localStorage.setItem(COMPLETED_KEY, JSON.stringify(obj));
    localStorage.setItem(LAST_PURGE_KEY, nowKey);
  }

  /* -----------------------------------------------------------------
     Paint orange rows, but NEVER repaint something that is already
     marked completed (green).  This guarantees green always wins,
     even if an ID-type mismatch exists between the two Sets.
  ------------------------------------------------------------------*/
  function highlightSavedRows(){
    selectedOrders.forEach(id => {
      const row = document.querySelector(
            `.new-order-box[data-receipt='${id}']`);

      if (!row) return;                      // row not on this page
      if (row.classList.contains("completed")) return;  // already green

      row.classList.add("selected");         // paint orange only once
    });
  }

  /* colour every row whose receipt_id is in completedOrders */
  function highlightCompletedRows() {
    document.querySelectorAll(".new-order-box").forEach(box => {
      const rid = box.dataset.receipt;
      if (completedOrders.has(rid)) {
        box.classList.remove("selected");  // make sure orange never sticks
        box.classList.add("completed");    // paint (or re-paint) green
      } else {
        box.classList.remove("completed"); // remove green if no longer done
      }
    });
  }

  /* =========================================================
  *  LIVE COUNTER updater   (GLOBAL)
  *   ‚Ä¢ counts EVERY preview, even hidden ones,
  *     so totals stay correct when a metal is toggled off
  * ========================================================= */
 function updateCounters(){
   let g = 0, s = 0, r = 0, k = 0;
 
   gridElements.forEach(wrap => {
    if (completedOrders.has(wrap.dataset.receipt)) return;
     const qty = Number(wrap.dataset.qty) || 1;
     switch (wrap.dataset.metal){
       case "gold":   g += qty; break;
       case "silver": s += qty; break;
       case "rose":   r += qty; break;
       case "14k":    k += qty; break;
     }
   });
 
   document.getElementById("goldCounter").innerText   = "Gold: "      + g;
   document.getElementById("silverCounter").innerText = "Silver: "    + s;
   document.getElementById("roseCounter").innerText   = "Rose: " + r;
   document.getElementById("solidCounter").innerText  = "14K: " + k;
 }

   // expose the helper so fillPreviewBoxes() can call it
   window.updateCounters = updateCounters;

    /* =======================================================
     * GLOBAL PREVIEW HELPERS ‚Äì accessible from any click-handler
     * ======================================================= */

      /* ===== removePreviewBoxesForOrder ‚Äî GLOBAL VERSION ===== */
      function removePreviewBoxesForOrder(receiptId, { force = false } = {}){

        console.log("%cREMOVE", "color:#d500f9",
            "receipt:", receiptId,
            "wraps in grid before:", document.querySelectorAll(
              `.wrap-preview[data-receipt='${receiptId}']`).length);

      /* skip removals for completed (green) orders ‚Äî unless forced */
      if (!force && completedOrders.has(receiptId)) return;

        /* PATCH ‚ñ∏ allow this order to be re-added next time */
     (orderCache[receiptId] || []).forEach(tx => {
       tx._inGrid = false;        // flip the guard-flag
       delete tx._wrapEl;         // drop stale DOM ref
     });
 
      /* ‚îÄ‚îÄ‚îÄ helper: recount items and update the little badge ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
      function refreshRowCount(receiptId){
        const box = document.querySelector(`.new-order-box[data-receipt='${receiptId}']`);
        if (!box) return;
        const cntEl = box.querySelector(".badge-count");     // ‚Üê your badge span
        if (!cntEl) return;
        cntEl.textContent = (orderCache[receiptId] || []).length;
      }

      /* 1 ‚ñ∏ delete every wrap belonging to this receipt */
      document.querySelectorAll(
        `#photoGridContainer .wrap-preview[data-receipt='${receiptId}']`
      ).forEach(wrap => {
        wrap.remove();
        /* drop from gridElements map */
        for (const [k,v] of gridElements.entries()){
          if (v === wrap){ gridElements.delete(k); break; }
        }
      });

      /* 2 ‚ñ∏ scrub caches */
      delete orderCache[receiptId];
      processedTxIds.forEach(txid=>{
        if (txid.startsWith(receiptId)) processedTxIds.delete(txid);
      });

      /* 3 ‚ñ∏ UI tidy */
      reflowGrid();
      updateCounters();
    }
    window.removePreviewBoxesForOrder = removePreviewBoxesForOrder;   // expose

    /* append ONE preview without rebuilding the entire grid */
    function addPreviewBox(item){

        console.log(
        "%cADD-PREVIEW start",
        "color:#29b6f6",
        "TX:", item.transaction_id,
        "receipt:", item.receipt_id,
        "_inGrid:", !!item._inGrid,
        "pers:", item.personalization?.length,
        "buyerMsg:", !!item.message_from_buyer
      );

        /* already have this TX? ‚Äî skip duplicate */
        if (document.querySelector(
                `.wrap-preview[data-tx='${item.transaction_id}']`)) {
            console.log("%cDUP-CHECK","color:#ef5350",
            "tx", item.transaction_id, "wrapped ‚Üí SKIPPED");
          return;
        }

      /* build DOM node + auto-append */
      const wrap = makePreviewNode(item);
      gridElements.set(gridElements.size, wrap);   // bookkeeping

      /* outline if order already orange-selected */
      if (selectedOrders.has(String(item.receipt_id))) {
        wrap.classList.add("selected");
      }

      /* maintain cache & indices */
      if (!Array.isArray(window.cachedOrderItems)) window.cachedOrderItems = [];
      window.cachedOrderItems.push(item);
      wrap.dataset.idx = window.cachedOrderItems.length - 1;

      /* back-references on the item itself */
      item._inGrid = true;
      item._wrapEl = wrap;

      /* log attention-flagged listings */
      if (wrap.classList.contains("preview-attn")){
        console.log("ATTN:", item.listing_id,
                    item.personalization, item.message_from_buyer);
      }

      updateCounters();          // refresh metal counters
      window.applyMetalFilter(); // honour current filter state
      return wrap;
    }

    window.addPreviewBox = addPreviewBox;   // keep global handle

  /* build a preview row (image + 4 tiny detail inputs) */
  function makePreviewNode(item){
    const idx = gridElements.size;
    const row = Math.floor(idx / 12);
    const col = idx % 12;

    /* wrapper keeps receipt ID for easy lookup */
    const wrap = document.createElement("div");
    wrap.className = "wrap-preview";                 // <‚Äî NEW class
    wrap.dataset.receipt = item.receipt_id;          // <‚Äî NEW data-tag
    wrap.dataset.tx = item.transaction_id;   // NEW ‚Äî enables duplicate guard
    wrap.style.cssText = `position:absolute;left:${col*125}px;top:${row*165}px;`;

    /* preview image‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶ */
    const box = document.createElement("div");
    box.className = "preview-box";
    box.innerHTML = "Loading‚Ä¶";
    wrap.appendChild(box);
    attachPreviewBoxListeners(box);

    /* 4 detail inputs ------------------------------------------------ */
    const addDetail = (id, y, val) => {
      const inp = document.createElement("input");
      inp.type       = "text";
      inp.readOnly   = true;
      inp.id         = id + idx;
      inp.className  = "detail-box";
      inp.dataset.idx= idx;               // ‚Üê NEW for modal lookup
      inp.style.cssText = `left:0px;top:${y}px;`;
      inp.value      = val;

      /* NEW ‚Äì open listing-detail modal when any detail box is clicked */
      inp.addEventListener("click", e => {
        e.stopPropagation();
        const parentWrap = e.currentTarget.closest(".wrap-preview");
        openListingModal(Number(parentWrap.dataset.idx));
      });

      wrap.appendChild(inp);
    };
    addDetail("orderCell"   ,  95, item.receipt_id || item.orderNumber || "No Order #");
    addDetail("quantityCell", 107, " Qty: " + (item.quantity ?? 0));

    /* ===== metal lookup, SKU, attention flag ========================== */
    let metalSel = "";
    let metalKey = "";
    let otherSel  = "";                    // NEW ‚Äì first non-metal variation

    if (Array.isArray(item.variations)) {
      const ok = [
        "metal",
        "metal choice",
        "metal - engraving",
        "metal colour",
        "color",
        "metal choice / engraving option"
      ];

      /* scan every variation */
      item.variations.forEach(v => {
        if (!v?.formatted_value) return;                 // need a value
        const name = (v.formatted_name  || "").replace(/&quot;/g, '"');
        const val  = (v.formatted_value || "").replace(/&quot;/g, '"');

        /* grab METAL with hard 14K precedence (can override earlier 'gold') */
        {
          const low = val.toLowerCase();
          if (/\b14\s*k(?:t|arat)?\b/.test(low)) {
            metalKey = "14k"; // 14k always wins, even if 'gold' was set earlier
          } else if (!metalKey) {
            if (/rose/.test(low))               metalKey = "rose";
            else if (/silv(?:er|r)/.test(low))  metalKey = "silver";
            else if (/gold/.test(low))          metalKey = "gold";
          }
        }

        /* grab the first NON-metal, NON-personalization variation */
        if (
          !otherSel &&
          !/(metal|colour|color)/i.test(name) &&
          !/personalization/i.test(name) &&
          val.trim()
        ){
          otherSel = val.trim();
        }

        /* remember the very first label for completeness */
        if (!metalSel) metalSel = val;
      });
    }

    /* NEW ‚Äì if missing, borrow the key we just detected for the row */
    item.metalLabel = metalSel || item._metalKey || metalKey || "No Metal";
    item.otherLabel = otherSel || "N/A";         // NEW

    /* does this listing need manual attention? */
    const hasPersonalization =
      (Array.isArray(item.personalization) && item.personalization.length) ||
      (item.personalization &&
       typeof item.personalization === "object" &&
       !Array.isArray(item.personalization) &&
       Object.keys(item.personalization).length) ||
      (typeof item.personalization === "string" &&
       item.personalization.trim().length) ||
      item.is_personalized === true;

    const needsAttn =
      hasPersonalization ||
      (item.message_from_buyer && item.message_from_buyer.trim().length);

    /* detail boxes */
    addDetail("metalCell", 119, " Metal: " + (item.metalLabel || "No Metal"));
    addDetail("skuCell" ,131," SKU: "+(item.sku||"N/A"));
    addDetail("matchCell",143,"");

    /* ‚òÖ FIX-C: trim + lower metal key, then log */
    metalKey = (metalKey || item._metalKey || "").trim().toLowerCase();
    wrap.dataset.metal = metalKey;
    item._metalKey     = metalKey;          // remember final tag
    console.log("%cMETAL-TAG","color:#29b6f6","assigned ‚Üí", `[${wrap.dataset.metal}]`);
    wrap.dataset.qty   = item.quantity ?? 1;

    if (needsAttn) wrap.classList.add("preview-attn");   // ORANGERED!

    /* attach wrapper & load thumbnail‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶ */
    document.getElementById("photoGridContainer").appendChild(wrap);

    /* keep the parent row‚Äôs counts in sync */
    refreshRowMetalCounts(String(item.receipt_id));

    fetchListingImages(item.listing_id)
      .then(imgs => {
        const first = Array.isArray(imgs) ? imgs[0] : null;
        const u = first?.url_fullxfull
               || first?.url
               || first?.image_url
               || first?.fullsize_url
               || first?.src
               || null;
        if (!u) throw new Error("no-image");
        return getLocalImageData(u);
      })
      .then(data => {
        box.innerHTML = `<img src="${data}" style="width:110%;height:110%;object-fit:cover;">`;
        item.image = data;
      })
      .catch((e)=>{ console.warn("Image load issue:", e); box.textContent = "No image"; });
    return wrap;
  }


(() => {


    /* =========================================================
     * DYNAMIC-REMOVE HELPERS
     * ========================================================= */



  /* 0.  GLOBAL HOOKS ----------------------------------------------------- */
  let currentReceipts = [];            // populated by buildNewOrderList()
  let sortKey   = null;                // "order", "ship", "gold", ...
  let sortDir   = 1;                   // 1 = asc, -1 = desc

  /** helper ‚Üí render the stacked boxes from `currentReceipts` array */
  function renderOrderBoxes(arr) {
    const container = document.getElementById("newOrderContainer");
    container.innerHTML = "";
    arr.forEach(async (r, idx) => {

      /* build the DOM node */
      const box = document.createElement("div");
      box.className = "new-order-box";
      box.id        = "newOrder" + idx;
      box.dataset.receipt = r.receipt_id;      // ‚Üê NEW data-tag

      /* click ‚Üí toggle highlight + (de)load images ---------------------- */
      box.addEventListener("click", async e => {
      if (e.ctrlKey || e.metaKey) return;   // range-selector handles these

                /* LOG #2 ‚Äì detected metal colour */
        console.log("%cMETAL","color:#ff9100;font-weight:bold",
              "metal:", box.dataset.metal || "N/A");

        const receiptId = idStr(r.receipt_id);      // ‚Üê always string

        /* ‚îÄ‚îÄ 1. toggle selected state ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
    if (selectedOrders.has(receiptId)) {
      /* ‚îÄ‚îÄ‚îÄ DESELECT ‚îÄ‚îÄ‚îÄ */
      selectedOrders.delete(receiptId);
      box.classList.remove("selected");

      /* clean up previews & bookkeeping */
      removePreviewBoxesForOrder(receiptId);  // drop every wrap
      realignGrid();                          // close gaps
      updateCounters();                       // badge totals
      persistSelection();                     // save smaller Set

      /* re-evaluate visibility after the removals */
      window.applyMetalFilter();

    } else {
      /* ‚îÄ‚îÄ‚îÄ SELECT ‚îÄ‚îÄ‚îÄ */
      selectedOrders.add(receiptId);
      box.classList.add("selected");

      /* set range-anchor on plain click */
      lastCtrlIdx = [...document.querySelectorAll("#newOrderContainer .new-order-box")]
                      .indexOf(box);

      /* pull + cache if first time */
      if (!orderCache[receiptId]) {
        const ord = await pullEtsyOrderDetails(receiptId);
        orderCache[receiptId] = ord?.transactions || [];

        refreshRowCount(receiptId);          // ‚Üê NEW: badge updates instantly
        refreshRowMetalCounts(receiptId); // ‚Üê NEW: per-metal numbers
      }

      /* ‚Äî check transactions array before we try to add previews ‚Äî */
      console.log("%cTX-ARRAY","color:#ff1744;font-weight:bold",
            "order:", receiptId,
            "tx count:", orderCache[receiptId]?.length,
            orderCache[receiptId]);

      /* iterate each transaction exactly once */
      let firstTxMetal = "";
      orderCache[receiptId].forEach(tx => {

        /* pass the row‚Äôs metal value to the transaction */
        tx._metalKey = box.dataset.metal;
        if (!firstTxMetal && tx._metalKey) firstTxMetal = tx._metalKey;

        if (!tx._inGrid) addPreviewBox(tx);
      });

      /* if the row tag is still missing, adopt the preview‚Äôs tag */
      if ((!box.dataset.metal || box.dataset.metal === "N/A") && firstTxMetal) {
        box.dataset.metal = firstTxMetal;
        console.log("%cROW-METAL-FIX","color:#8e24aa;font-weight:bold",
              "receipt:", receiptId, "now ‚Üí", box.dataset.metal);
      }

      persistSelection();                     // üî∏ keep after caching
    }

        //* ‚îÄ‚îÄ 2. build combined list from all active orders ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
    let combined = [];
    selectedOrders.forEach(id => {
      const txs = orderCache[id] || [];
      combined.push(...txs);
    });

    /* ‚îÄ‚îÄ 3. (de)render the grid ‚Äî incremental append version ‚îÄ */
    const grid = document.getElementById("photoGridContainer");

    if (combined.length === 0) {               // nothing selected
      grid.innerHTML = "";
      gridElements.clear();
      earringCells  = {};
      earringState  = {};
    } else {
      combined.forEach(tx => {                 // only add new ones
        if (!tx._inGrid) addPreviewBox(tx);
      });
    }

    /* ‚îÄ‚îÄ 4. housekeeping after grid changes ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
    realignGrid();
    updateCounters();
    window.applyMetalFilter();

    });   /* ‚Üê closes box.addEventListener("click", ‚Ä¶ ) */

    /* ‚îÄ‚îÄ HOVER ‚Üí outline matching preview boxes ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
    box.addEventListener("mouseenter", () => {
      if (!box.classList.contains("selected")) return;    // orange rows only
      const rec = r.receipt_id;
      document.querySelectorAll(`#photoGridContainer .wrap-preview[data-receipt="${rec}"]`)
              .forEach(w => w.classList.add("preview-highlight"));
    });
    box.addEventListener("mouseleave", () => {
      const rec = r.receipt_id;
      document.querySelectorAll(`#photoGridContainer .wrap-preview[data-receipt="${rec}"]`)
              .forEach(w => w.classList.remove("preview-highlight"));
    });

    /* ‚ñº‚ñº  PASTE THE SAME NEW BLOCK HERE  ‚ñº‚ñº */
    box.addEventListener("mouseenter", () => {
      box.classList.add("hover-blue");
      document
        .querySelectorAll(`#photoGridContainer .wrap-preview[data-receipt='${box.dataset.receipt}']`)
        .forEach(w => w.classList.add("hover-blue"));
    });
    box.addEventListener("mouseleave", () => {
      box.classList.remove("hover-blue");
      document
        .querySelectorAll(`#photoGridContainer .wrap-preview[data-receipt='${box.dataset.receipt}']`)
        .forEach(w => w.classList.remove("hover-blue"));
    });

    /* order-row content ----------------------------------------------- */
    const orderNum = r.order_number || r.receipt_id || "‚Äî";
    const shipStr  = r._shipStr || "N/A";
    const g  = r._metalCounts.Gold     || 0;
    const s  = r._metalCounts.Silver   || 0;
    const rG = r._metalCounts["Rose G"]|| 0;
    const k  = r._metalCounts["14K"]   || 0;

    /* assign one metal key to the whole order for filtering */
    let rowMetal = "";
    if     (k)        rowMetal = "14k";
    else if(rG)       rowMetal = "rose";
    else if(s)        rowMetal = "silver";
    else if(g)        rowMetal = "gold";
    box.dataset.metal = rowMetal;          // ‚Üê moved here

    box.innerHTML = `
      <span class="col-order">${orderNum}</span>
      <span class="col-ship">${shipStr}</span>
      <span class="col-g">${g}</span>
      <span class="col-s">${s}</span>
      <span class="col-r">${rG}</span>
      <span class="col-k">${k}</span>
    `;
    container.appendChild(box);            // last line inside arr.forEach
    });                                // closes arr.forEach

    highlightSavedRows();              // ‚Üê NEW: paint saved rows
    requestAnimationFrame(highlightCompletedRows);   // green wins after paint

     /* keep greens hidden unless Completed filter is on */
     requestAnimationFrame(window.applyMetalFilter);

     requestAnimationFrame(markStaffNoteOrders);      // üîÑ restore Staff-Note purple/bold

  }           

  /** 1.  HEADER BAR  +  EVENT LISTENERS ------------------------------- */
  const bar = document.createElement("div");
  bar.id = "orderHeaderBar";
  bar.style.cssText =
    "position:absolute;left:20px;top:206px;width:285px;height:23px;" +
    "display:flex;gap:2px;background:#626262;color:#fff;font-size:0.75em;" +
    "align-items:center;user-select:none;z-index:9999;";

  const COLS = [
    { key:"order",  label:"Order", flex:"1.55" },
    { key:"ship",   label:"Date",  flex:"1.25" },
    { key:"gold",   label:"G",     flex:"0.45" },
    { key:"silver", label:"S",     flex:"0.45" },
    { key:"rose",   label:"R",     flex:"0.45" },
    { key:"14k",    label:"14",    flex:"0.45" }
  ];

  COLS.forEach(col => {
    const div = document.createElement("div");
    div.className = "hdr";
    div.dataset.key = col.key;
    div.style.cssText = `flex:${col.flex};text-align:center;cursor:pointer;`;
    div.innerHTML =
      `${col.label}<span class="chev">` +
      `<span class="up">‚ñ≤</span><br><span class="down">‚ñº</span>` +
      `</span>`;
    bar.appendChild(div);
  });

  document.body.appendChild(bar);
  loadPositions();   // re-apply positions now that #orderHeaderBar exists

  /* 2.  SORT ROUTINE ---------------------------------------------------- */
    bar.addEventListener("click", ev => {
      const hdr = ev.target.closest(".hdr");
      if (!hdr) return;

      // toggle dir / remember key
      const key = hdr.dataset.key;
      sortDir = (sortKey === key) ? -sortDir : 1;
      sortKey = key;

      // run the sort
      currentReceipts.sort((a, b) => {
        switch (key) {
          case "order":  return sortDir * ((a.order_number || a.receipt_id) - (b.order_number || b.receipt_id));
          case "ship":   return sortDir * ((a._shipTS || 0) - (b._shipTS || 0));
          case "gold":   return sortDir * ((a._metalCounts.Gold || 0) - (b._metalCounts.Gold || 0));
          case "silver": return sortDir * ((a._metalCounts.Silver || 0) - (b._metalCounts.Silver || 0));
          case "rose":   return sortDir * ((a._metalCounts["Rose G"] || 0) - (b._metalCounts["Rose G"] || 0));
          case "14k":    return sortDir * ((a._metalCounts["14K"] || 0)   - (b._metalCounts["14K"] || 0));
        }
        return 0;
      });

      // arrow colour logic
      bar.querySelectorAll(".chev .up, .chev .down").forEach(el => (el.style.color = "#ffffff"));
      if (sortDir === 1) hdr.querySelector(".chev .up").style.color = "#2196F3";
      else               hdr.querySelector(".chev .down").style.color = "#2196F3";

      // ‚úÖ re-render now (single click)
      currentReceipts = currentReceipts.filter(r => !completedOrders.has(String(r.receipt_id)));
      renderOrderBoxes(currentReceipts);
      reapplySelectionAndLocks?.();
      applyMetalFilter?.();
      markStaffNoteOrders?.();
      requestAnimationFrame(highlightCompletedRows);
    });



/* 3. HOOK INTO buildNewOrderList() ‚Äî pass-through only -------------- */
const originalBuild = buildNewOrderList;
buildNewOrderList = async function (offset = 0) {
  /* do NOT hydrate here; just forward the call */
  return await originalBuild.call(this, offset);
};

/* Monkey-patch to expose display array for observer ------------------ */
const origFuncTxt = buildNewOrderList.toString();
if (!origFuncTxt.includes("window._lastDisplayReceipts")) {
  console.warn(
    "Patch buildNewOrderList manually to expose displayReceipts:\n" +
    "Inside buildNewOrderList(), after you define displayReceipts, add:\n" +
    "    window._lastDisplayReceipts = displayReceipts;"
  );
}

let __obsBusy = false;

/** observer detects page changes and triggers initial render --------- */
const observer = new MutationObserver(async () => {
  if (__obsBusy) return;
  if (window._lastDisplayReceipts && window._lastDisplayReceipts !== currentReceipts) {
    __obsBusy = true;
    try {
      /* lightweight receipts landed ‚Äî hydrate them BEFORE we draw rows */
      currentReceipts = window._lastDisplayReceipts;

      /* FULL HYDRATE: pull transactions for EVERY receipt -------------- */
      await Promise.all(
        currentReceipts.map(async r => {
          const id = String(r.receipt_id);
          if (!orderCache[id]) {
            try {
              const ord = await pullEtsyOrderDetails(id);
              orderCache[id] = ord?.transactions || [];
            } catch (err) {
              console.warn("Detail pull failed for", id, err);
              orderCache[id] = [];
            }
          }
          r.transactions = orderCache[id];
        })
      );

    /* helper fields for sorting + metal counts ----------------------- */
    currentReceipts.forEach(r => {
      /* ship timestamp + pretty string */
      if (!r._shipTS) {
        const ts = r.transactions?.[0]?.expected_ship_date || 0;
        r._shipTS  = ts;
        r._shipStr = ts
          ? new Date(ts * 1000).toLocaleDateString("en-US", { month:"short", day:"2-digit" })
          : "N/A";
      }

      /* metal counts (check EVERY variation value + fallback tag) */
      const mc = { Gold:0, Silver:0, "Rose G":0, "14K":0 };

      (r.transactions || []).forEach(t => {
        const q = t.quantity || 1;

        /* add counts from every variation value */
        if (Array.isArray(t.variations)) {
          t.variations.forEach(v => {
          const val = (v?.formatted_value || "").toLowerCase();
          if (/\b14\s*k(?:t|arat)?\b/.test(val))   mc["14K"]    += q;
          else if (/rose/.test(val))               mc["Rose G"] += q;
          else if (/silv(?:er|r)/.test(val))       mc.Silver    += q;
          else if (/gold/.test(val))               mc.Gold      += q;
          });
        }

        /* fallback to propagated _metalKey if all counts still zero */
        if (!mc.Gold && !mc.Silver && !mc["Rose G"] && !mc["14K"] && t._metalKey) {
          switch (t._metalKey) {
            case "14k":    mc["14K"]    += q; break;
            case "rose":   mc["Rose G"] += q; break;
            case "silver": mc.Silver    += q; break;
            case "gold":   mc.Gold      += q; break;
          }
        }
      });
      r._metalCounts = mc;

      /* derive a single row-level metal tag (may stay blank) */
      if      (mc["14K"])    r._rowMetal = "14k";
      else if (mc["Rose G"]) r._rowMetal = "rose";
      else if (mc.Silver)    r._rowMetal = "silver";
      else if (mc.Gold)      r._rowMetal = "gold";
      else                   r._rowMetal = "";         // no metal detected
    });

    /* initial sort direction ---------------------------------------- */
    if (!sortKey) { sortKey = "order"; sortDir = -1; }

    /* arrow colours ------------------------------------------------- */
    bar.querySelectorAll(".chev .up, .chev .down")
       .forEach(el => (el.style.color = "#ffffff"));
    const activeChev = bar.querySelector(`[data-key="${sortKey}"] .chev`);
    (sortDir === 1
      ? activeChev.querySelector(".up")
      : activeChev.querySelector(".down")
    ).style.color = "#2196F3";

    /* render fully-hydrated rows ‚Äî RESPECT current sortKey/sortDir */
    (function applyCurrentSort(){
      const key = sortKey || "order";
      currentReceipts.sort((a, b) => {
        switch (key) {
          case "order":  return sortDir * ((a.order_number || a.receipt_id) - (b.order_number || b.receipt_id));
          case "ship":   return sortDir * ((a._shipTS || 0) - (b._shipTS || 0));
          case "gold":   return sortDir * ((a._metalCounts?.Gold   || 0) - (b._metalCounts?.Gold   || 0));
          case "silver": return sortDir * ((a._metalCounts?.Silver || 0) - (b._metalCounts?.Silver || 0));
          case "rose":   return sortDir * ((a._metalCounts?.["Rose G"] || 0) - (b._metalCounts?.["Rose G"] || 0));
          case "14k":    return sortDir * ((a._metalCounts?.["14K"]   || 0) - (b._metalCounts?.["14K"]   || 0));
          default:       return 0;
        }
      });
    })();

/* keep completed rows hidden */
currentReceipts = currentReceipts.filter(r => !completedOrders.has(String(r.receipt_id)));

renderOrderBoxes(currentReceipts);
applyAllLocksToDOM();   // repaint locks after the list is rebuilt
    /* ‚îÄ‚îÄ‚îÄ INSERT ‚Üì‚Üì‚Üì  (exactly here) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
    await refreshStaffNoteIDs();
    markStaffNoteOrders();

    } finally {
      __obsBusy = false;
    }
  }
});
observer.observe(document.getElementById("newOrderContainer"), { childList: true });

})();   /* ‚îÄ‚îÄ‚îÄ END SORT HEADER MODULE ‚îÄ‚îÄ‚îÄ */

/********************************************************
 * helper: sleep(ms)
 ********************************************************/
const sleep = ms => new Promise(res => setTimeout(res, ms));


/********************************************************
 * updatePageButtons(totalPages, currentPage)
 *   ‚Ä¢ draws 1‚Ä¶N circular buttons under #newOrderContainer
 ********************************************************/
function updatePageButtons(totalPages, currentPage){
  const holder = document.getElementById("pageButtonsContainer");
  holder.innerHTML = "";                               // wipe + rebuild
  for(let i=1;i<=totalPages;i++){
    const btn = document.createElement("div");
    btn.className = "page-btn" + (i===currentPage ? " active": "");
    btn.textContent = i;
    btn.addEventListener(
      "click",
      ClickHarden.withLock(btn, async () => {
        orderListOffset = (i-1)*100;
        await buildNewOrderList(orderListOffset);

        // Repaint orange after all late DOM work
        reapplySelectionAndLocks();
        // When all orders have loaded ‚Üí do a full database refresh of "available orders"
        await refreshStaffNoteIDs({ mode: "all" });  // ?staffNotes=1
        if (typeof markStaffNoteOrders === "function") markStaffNoteOrders();
        if (typeof fetchAllLocksOnce   === "function") await fetchAllLocksOnce(); // ?rt=1
        requestAnimationFrame(reapplySelectionAndLocks);
        requestAnimationFrame(() => requestAnimationFrame(reapplySelectionAndLocks));

        // NEW: perform a light heal on page-switch in case any rows rendered as 0/0/0/0
        await healZeroMetalRows({ passes: 1, concurrency: 4, reason: "page-nav" });

        // buildNewOrderList already refreshes the pager; avoid a double call
      }, 400)
    );
    holder.appendChild(btn);
  }
}


/********************************************************
 * fetchOpenOrdersSequential()   ‚Üê DROP-IN REPLACEMENT
 *    ‚Ä¢ grabs EVERY open receipt in 100-row pages
 *    ‚Ä¢ waits 250 ms between calls (safe for Etsy‚Äôs rate limits)
 *    ‚Ä¢ stops only when a page returns < 100 rows
 ********************************************************/
// Replace the existing fetchOpenOrdersSequential with this:
async function fetchOpenOrdersSequential() {
  const all = [];
  let offset = 0;

  while (true) {
    const resp = await apiFetch(`/listOpenOrders?offset=${offset}`);
    if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
    const payload = await resp.json();

    const receipts = payload.results || [];
    all.push(...receipts);

    if (receipts.length < 100) break; // done
    offset += 100;
    await new Promise(r => setTimeout(r, 250)); // polite pacing
  }

  return all;
}

  /********************************************************
 * buildNewOrderList ‚Äì serves 100-row ‚Äúpages‚Äù from cache
 ********************************************************/
let allOpenReceipts = [];                 // ‚Üê master cache

async function buildNewOrderList(offset = 0) {
  /* ‚ù∂ first call ‚Üí fetch everything & sort once */
  if (allOpenReceipts.length === 0) {
    allOpenReceipts = await fetchOpenOrdersSequential();

    /* helper fields + oldest-ship-date sort */
    allOpenReceipts.forEach(r => {
      /* ship timestamp + pretty string */
      if (!r._shipTS) {
        let ts = null;
        if (Array.isArray(r.transactions) && r.transactions[0]?.expected_ship_date) {
          ts = r.transactions[0].expected_ship_date;
        }
        if (!ts) ts = r.dispatch_date || r.ship_by_date || 0;
        r._shipTS  = ts;
        r._shipStr = ts
          ? new Date(ts * 1000).toLocaleDateString("en-US", { month:"short", day:"2-digit" })
          : "N/A";
      }

      /* one-time metal counts ‚Äî scan EVERY variation value + fallback tag */
      if (!r._metalCounts) {
        const mc = { Gold:0, Silver:0, "Rose G":0, "14K":0 };

        (r.transactions || []).forEach(t => {
          const q = t.quantity || 1;

          /* add counts from every variation value */
          if (Array.isArray(t.variations)) {
            t.variations.forEach(v => {
              const val = (v?.formatted_value || "").toLowerCase();
              if (/14\s*k\s*solid/i.test(val))         mc["14K"]    += q;
              else if (/rose/.test(val))   mc["Rose G"] += q;
              else if (/silv(?:er|r)/.test(val)) mc.Silver    += q;
              else if (/gold/.test(val))   mc.Gold      += q;
            });
          }

          /* if still zero, use the propagated _metalKey */
          if (!mc.Gold && !mc.Silver && !mc["Rose G"] && !mc["14K"] && t._metalKey) {
            switch (t._metalKey) {
              case "14k":    mc["14K"]    += q; break;
              case "rose":   mc["Rose G"] += q; break;
              case "silver": mc.Silver    += q; break;
              case "gold":   mc.Gold      += q; break;
            }
          }
        });
        r._metalCounts = mc;
      }

      /* ‚îÄ‚îÄ NEW: attach buyer-message + keep personalization as array ‚îÄ‚îÄ */
      const buyerMsg = r.message_from_buyer || "";
      (r.transactions || []).forEach(t => {
        t.message_from_buyer = buyerMsg;

        t.personalization = (t.variations || []).find(v => /personalization/i.test(v.formatted_name || ""))?.formatted_value
          ? [ (t.variations.find(v => /personalization/i.test(v.formatted_name || ""))).formatted_value.trim() ]
          : [];

        // always make personalization an array
        if (t.personalization) {
          if (!Array.isArray(t.personalization)) {
            t.personalization = [ t.personalization ];
          }
        } else {
          t.personalization = [];
        }

        // dev-log any personalized transaction
        if (t.personalization.length) {
          console.log("‚üπ Personalization TX", t.transaction_id,
                      JSON.stringify(t.personalization));
        }
      });

    }); /* end forEach(r) */
  }

  /* ‚Ä¶ remainder of buildNewOrderList() unchanged ‚Ä¶ */

  allOpenReceipts.sort((a, b) => {
    if (a._shipTS === 0 && b._shipTS === 0) return 0;
    if (a._shipTS === 0) return  1;
    if (b._shipTS === 0) return -1;
    return a._shipTS - b._shipTS;            // oldest ‚Üí newest
  });

  /* ‚ù∑ slice requested page ‚Äì skip receipts already completed */
  const filtered     = allOpenReceipts.filter(r => !completedOrders.has(String(r.receipt_id)));
  const page         = filtered.slice(offset, offset + 100);
  // expose the current page using the exact name the console hint expects
  const displayReceipts = page;
  window._lastDisplayReceipts = displayReceipts;

  const totalPages   = Math.ceil(filtered.length / 100);
  const currentPage  = Math.floor(offset / 100) + 1;
  updatePageButtons(totalPages, currentPage);

  /******** render stacked boxes (unchanged widths) ********/
  const container = document.getElementById("newOrderContainer");
  container.innerHTML = "";
  page.forEach((r, idx) => {

    const box = document.createElement("div");
    box.className = "new-order-box";
    box.id        = "newOrder" + (offset + idx);

    const rid = idStr(r.receipt_id);         // ‚Üê use string everywhere
    box.dataset.receipt = rid;

    /* colour immediately if it was saved */
    if (completedOrders.has(rid)) {          // green first
      box.classList.add("completed");
    } else if (selectedOrders.has(rid)) {    // orange only if not green
      box.classList.add("selected");
    }

    const orderNum = r.order_number || r.receipt_id || "‚Äî";
    const shipStr  = r._shipStr || "N/A";
    const g  = r._metalCounts.Gold     || 0;
    const s  = r._metalCounts.Silver   || 0;
    const rG = r._metalCounts["Rose G"]|| 0;
    const k  = r._metalCounts["14K"]   || 0;

    /* NEW ‚ñ∏ decide the metal key for this entire order */
    let rowMetal = "";
    if     (k)   rowMetal = "14k";
    else if(rG)  rowMetal = "rose";
    else if(s)   rowMetal = "silver";
    else if(g)   rowMetal = "gold";
    box.dataset.metal = rowMetal;            // ‚Üê NEW

    box.innerHTML = `
      <span class="col-order">${orderNum}</span>
      <span class="col-ship">${shipStr}</span>
      <span class="col-g">${g}</span>
      <span class="col-s">${s}</span>
      <span class="col-r">${rG}</span>
      <span class="col-k">${k}</span>
    `;
    container.appendChild(box);
  });                                         // ‚Üê closes page.forEach

  highlightSavedRows();        // orange first‚Ä¶

  /* Green next, then re-assert orange so nothing strips it */
  requestAnimationFrame(() => {
    highlightCompletedRows();
    // one more pass to ensure orange persists after any late handlers
    highlightSavedRows();
  });

  /* ‚îÄ‚îÄ refresh the four metal badges no matter what filters are set ‚îÄ‚îÄ */
  updateCounters();

  /* üÜï highlight any rows that own a Staff Note */
  await refreshStaffNoteIDs();     // pulls latest note IDs
  markStaffNoteOrders();           // adds .has-staff-note class

  /* return page size (0-100) so buttons enable/disable correctly */
  return page.length;
}

/********************************************************
 * startScannedSortingListener (NEW partial snippet)
 ********************************************************/
async function startScannedSortingListener() {
  try {
    const docRef = db.collection("Brites_Orders").doc("ScannedSortingOrder");
    docRef.onSnapshot((docSnap) => {
      if (!docSnap.exists) {
        console.log("No 'ScannedSortingOrder' doc in Firestore yet.");
        return;
      }
      const docData = docSnap.data();
      if (!docData["Order Number"]) {
        console.log("No 'Order Number' in 'ScannedSortingOrder' doc.");
        return;
      }
      const scannedVal = docData["Order Number"];
      console.log("Scanned Sorting code =>", scannedVal);

      const input = document.getElementById("etsyOrderNumber");
      if (!input) return;
      input.value = scannedVal;

      // [NEW: reset states as if app just opened]
      disableSendMatch();
      disableMatchPrintFlow();
      removeAllBlueHighlights();

      // Programmatically fire an Enter key
      const enterEvent = new KeyboardEvent("keydown", { key: "Enter" });
      input.dispatchEvent(enterEvent);
    });
  } catch (err) {
    console.error("Error starting scannedSortingListener:", err);
  }
}



/* === Restore saved orange selections === */
  restoreSelections();            // ‚Üê add this line

});        /* ‚Üê‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì CLOSED DOMContentLoaded LISTENER */

/* ===== Hard-coded fallback positions & sizes (no calculations) ===== */
const defaultPos = {
  connectEtsyBtn:           { left:1123, top:803, width:126, height:35 },
  openConfigBtn:            { left:1270,  top:803, width:133, height:35 },
  updateOrderListBtn:       { left:1204,top:5,  width:120, height:35 },
  clearBtn:               { left:1339,  top:5, width:120, height:35 },
  etsyOrderNumber:          { left:663,  top:5,  width:200, height:25 },
  photoGridContainer:     { left:318,   top:45,   width:1513, height:850 },
  orderHeaderBar:       { left:6,   top:19,   width:290,   height:27 },
  configModal:              { left:50,  top:50, width:250, height:450 },
  configTable:              { left:27,   top:7,   width:525,  height:1562 },
  saveConfigBtn:            { left:10, top:3,  width:85, height:35 },
  newOrderContainer:        { left:1, top:45,  width:318, height:800 },
  pageButtonsContainer:     { left:71,top:-4, width:325, height:25 },
  completeBtn:              { left:1057,   top:5, width:134, height:35 },
  undoCompleteBtn:          { left:902,  top:5, width:139, height:35 },
  goldCounter:          { left:319, top:9,  width:72,height:27 },
  silverCounter:        { left:402,  top:9,   width:72, height:27 },
  roseCounter:          { left:485,  top:9,  width:72, height:27 },
  solidCounter:         { left:568,  top:9, width:72, height:27 }
};

/********************************************************
 * loadPositions -- apply stored values or hard defaults
 ********************************************************/
function loadPositions() {
  configIDs.forEach((id) => {
    const el = document.getElementById(id);
    if (!el) return;

    const def = defaultPos[id] || {};
    const left   = parseInt(localStorage.getItem(`pos-${id}-left`), 10)   || def.left   || 0;
    const top    = parseInt(localStorage.getItem(`pos-${id}-top`), 10)    || def.top    || 0;
    const width  = parseInt(localStorage.getItem(`pos-${id}-width`), 10)  || def.width  || 0;
    const height = parseInt(localStorage.getItem(`pos-${id}-height`), 10) || def.height || 0;

    el.style.position = "absolute";
    el.style.left   = left   + "px";
    el.style.top    = top    + "px";
    if (width  > 0) el.style.width  = width  + "px";
    if (height > 0) el.style.height = height + "px";
  });
}

// --------------- (Your code for config table, openConfigBtn, saveConfigBtn, etc.) --------------
document.getElementById("openConfigBtn").addEventListener("click", function () {
  populateConfigTable();
  M.Modal.getInstance(document.getElementById("configModal")).open();
});

document.getElementById("saveConfigBtn").addEventListener("click", function () {
  configIDs.forEach(function (id) {
    const el = document.getElementById(id);
    if (!el) return;
    const cs = window.getComputedStyle(el);
    localStorage.setItem("pos-" + id + "-left", parseInt(cs.left, 10) || 0);
    localStorage.setItem("pos-" + id + "-top", parseInt(cs.top, 10) || 0);
    localStorage.setItem("pos-" + id + "-width", parseInt(cs.width, 10) || 0);
    localStorage.setItem("pos-" + id + "-height", parseInt(cs.height, 10) || 0);
  });
  M.toast({ html: "Positions saved!" });
});

function populateConfigTable() {
  const tbody = document.querySelector("#configTable tbody");
  tbody.innerHTML = "";

  configIDs.forEach(function (id) {
    const el = document.getElementById(id);
    if (!el) return;
    const cs = window.getComputedStyle(el);
    const leftVal = parseInt(cs.left, 10) || 0;
    const topVal = parseInt(cs.top, 10) || 0;
    const widthVal = parseInt(cs.width, 10) || 0;
    const heightVal = parseInt(cs.height, 10) || 0;

    const row = document.createElement("tr");
    row.innerHTML = `
      <td>${id}</td>
      <td><input type="number" value="${leftVal}" data-id="${id}" class="left-input"></td>
      <td><input type="number" value="${topVal}" data-id="${id}" class="top-input"></td>
      <td><input type="number" value="${widthVal}" data-id="${id}" class="width-input"></td>
      <td><input type="number" value="${heightVal}" data-id="${id}" class="height-input"></td>
    `;
    tbody.appendChild(row);

    row.querySelector(".left-input").addEventListener("input", function () {
      const target = document.getElementById(this.dataset.id);
      if (target) target.style.left = parseInt(this.value, 10) + "px";
    });
    row.querySelector(".top-input").addEventListener("input", function () {
      const target = document.getElementById(this.dataset.id);
      if (target) target.style.top = parseInt(this.value, 10) + "px";
    });
    row.querySelector(".width-input").addEventListener("input", function () {
      const target = document.getElementById(this.dataset.id);
      if (target) target.style.width = parseInt(this.value, 10) + "px";
    });
    row.querySelector(".height-input").addEventListener("input", function () {
      const target = document.getElementById(this.dataset.id);
      if (target) target.style.height = parseInt(this.value, 10) + "px";
    });
  });
}

/******************************************************************
 * fillPreviewBoxes(items)      ‚¨áÔ∏è  <------------- REPLACE THIS WHOLE FUNCTION
 ******************************************************************/
function fillPreviewBoxes(items){
  /* reset state ----------------------------------------------- */
  gridElements.clear();
  earringCells = {};
  earringState = {};
  const container = document.getElementById("photoGridContainer");
  container.innerHTML = "";

  window.cachedOrderItems = items;        // global cache

  /* helper phrase lists (unchanged) --------------------------- */
  const groupA = ["stud","studs","stud earrings","ring","rings","earrings"];
  const groupB = ["necklace","necklaces","huggie","huggies","huggie earrings",
                  "hoop","hoops","hoop earrings","bracelet","bracelets",
                  "extender","extenders","chain","chains"];
  const EARRING_PHRASES = [
    "stud","stud earrings","earring","earrings",
    "huggie","huggies","huggie earrings","hoop","hoops","hoop earrings"
  ];
  const containsPhrase = (str="",ph="")=>{
    const pat="\\b"+ph.trim().replace(/\s+/g,"[\\s\\W]+")+"\\b";
    return new RegExp(pat,"i").test(str.toLowerCase());
  };
  const isEarringString = str =>
    EARRING_PHRASES.some(ph=>new RegExp("\\b"+ph.replace(/\s+/g,"\\s+")+"\\b","i").test(str.toLowerCase()));

  /* main loop: one preview per transaction -------------------- */
  items.forEach(item=>{
    /* keyword tagging */
    item.keywords=[];
    if(item.title){
      groupA.forEach(p=>{if(containsPhrase(item.title,p)) item.keywords.push(p);});
      groupB.forEach(p=>{if(containsPhrase(item.title,p)) item.keywords.push(p);});
    }
    if(item.keywords.length===0) item.keywords.push("groupB");

    /* earring detector */
    item.isEarring = isEarringString(item.title||"") ||
                     (item.variations||[]).some(v=>v.formatted_value && isEarringString(v.formatted_value));
    if(item.isEarring){
      const idx = gridElements.size;
      earringCells[idx]=true;
      earringState[idx]={firstImg:null};
    }

    /* build + append preview row */
    addPreviewBox(item);
  });

    updateCounters();                  // ‚Üê NEW: recalc counters
    reflowGrid();

}  /* ---------------------------- END fillPreviewBoxes -------- */

function attachPreviewBoxListeners(box) {
  let isDragging = false;
  let isMouseDown = false;
  let dragStartX = 0,
      dragStartY = 0;
  let lastX = 0,
      lastY = 0;
  const dragThreshold = 3;

  box.addEventListener("wheel", function (ev) {
    const img = box.querySelector("img");
    if (!img) return;
    ev.preventDefault();
    let currentScale = parseFloat(img.dataset.scale) || 1;
    let offX = parseFloat(img.dataset.offsetX) || 0;
    let offY = parseFloat(img.dataset.offsetY) || 0;
    if (ev.deltaY < 0) {
      currentScale *= 1.1;
    } else {
      currentScale /= 1.1;
      if (currentScale <= 1) {
        currentScale = 1;
        offX = 0;
        offY = 0;
      }
    }
    if (currentScale > 7) currentScale = 7;
    img.dataset.scale = currentScale;
    img.dataset.offsetX = offX;
    img.dataset.offsetY = offY;
    img.style.transform = `translate(${offX}px, ${offY}px) scale(${currentScale})`;
  });

  box.addEventListener("mousedown", function (ev) {
    const img = box.querySelector("img");
    if (!img) return;
    const scaleNow = parseFloat(img.dataset.scale) || 1;
    if (scaleNow <= 1) return;
    ev.preventDefault();
    isMouseDown = true;
    isDragging = false;
    dragStartX = ev.clientX;
    dragStartY = ev.clientY;
    lastX = ev.clientX;
    lastY = ev.clientY;
  });

  box.addEventListener("mousemove", function (ev) {
    if (!isMouseDown) return;
    ev.preventDefault();
    const dxAll = Math.abs(ev.clientX - dragStartX);
    const dyAll = Math.abs(ev.clientY - dragStartY);
    if (dxAll > dragThreshold || dyAll > dragThreshold) isDragging = true;
    const img = box.querySelector("img");
    if (!img) return;
    const scaleNow = parseFloat(img.dataset.scale) || 1;
    let offX = parseFloat(img.dataset.offsetX) || 0;
    let offY = parseFloat(img.dataset.offsetY) || 0;
    const dx = ev.clientX - lastX;
    const dy = ev.clientY - lastY;
    offX += dx;
    offY += dy;
    img.dataset.offsetX = offX;
    img.dataset.offsetY = offY;
    img.style.transform = `translate(${offX}px, ${offY}px) scale(${scaleNow})`;
    lastX = ev.clientX;
    lastY = ev.clientY;
  });

  box.addEventListener("mouseup", function () {
    isMouseDown = false;
  });
  box.addEventListener("mouseleave", function () {
    isMouseDown = false;
  });

  box.addEventListener("click", function (ev) {
    if (isDragging) {
      isDragging = false;
      return;
    }
    const img = box.querySelector("img");
    if (!img) return;
    const rect = box.getBoundingClientRect();
    const boxCenterX = rect.left + box.clientWidth / 2;
    const boxCenterY = rect.top + box.clientHeight / 2;
    const dx = ev.clientX - boxCenterX;
    const dy = ev.clientY - boxCenterY;
    const scale = 5;
    const fudgeY = 10;
    const offsetX = -scale * dx;
    const offsetY = -scale * dy + fudgeY;
    img.dataset.scale = scale;
    img.dataset.offsetX = offsetX;
    img.dataset.offsetY = offsetY;
    img.style.transform = `translate(${offsetX}px, ${offsetY}px) scale(${scale})`;
  });

}

/* ------------------------------------------------------------------
 * fetchEtsyOrder(orderNum) ‚Üí full Etsy payload for ONE order
 * -----------------------------------------------------------------*/
async function fetchEtsyOrder(orderNum){
  const token = localStorage.getItem("access_token") || "";
  const url   = functionsBaseUrl +
                "/etsyOrderProxy?orderId=" + encodeURIComponent(orderNum);
  const resp  = await apiFetch(`/etsyOrderProxy?orderId=${encodeURIComponent(orderNum)}`);
  if(!resp.ok) throw new Error("HTTP "+resp.status);
  return await resp.json();            // { receipt, transactions, ‚Ä¶ }
}

  /* Fetch a reliable SKU for a single order item */
  async function fetchItemSKU(item){
    try{
      if (item?.sku && String(item.sku).trim()) return String(item.sku).trim();

      const orderId = String(item?.receipt_id || item?.orderNumber || "");
      if (!orderId) return "";

      const resp = await apiFetch(`/etsyOrderProxy?orderId=${encodeURIComponent(orderId)}`);
      if (!resp.ok) return "";

      const data = await resp.json();
      const tx = (data.transactions || []).find(t =>
        String(t.transaction_id) === String(item.transaction_id)
      );

      return String(tx?.sku || tx?.product_data?.sku || "").trim();
    }catch(_){
      return "";
    }
  }

/********************************************************
 * loadBatchEtsyOrders, fetchListingImages, getLocalImageData
 ********************************************************/
async function loadBatchEtsyOrders(orderNumbers) {
  try {
    /* Accept a raw comma-separated string or an array; normalize, de-dupe, cap at 500 */
    let list = [];
    if (typeof orderNumbers === "string") {
      list = orderNumbers
        .split(/[,\n\r\t ]+/)
        .map(s => s.trim())
        .filter(Boolean);
    } else if (Array.isArray(orderNumbers)) {
      list = orderNumbers.map(x => String(x).trim()).filter(Boolean);
    }
    const seen = new Set();
    list = list.filter(id => (id && !seen.has(id)) ? (seen.add(id), true) : false)
               .slice(0, 500);

    M.toast({ html: "Loading " + list.length + " order(s)..." });

    /* Prepare/refresh the left rail list */
    const container = document.getElementById("newOrderContainer");
    if (container) container.innerHTML = "";
    const frag = document.createDocumentFragment();

    const combinedItems = [];

    /* ‚îÄ‚îÄ loop through each receiptId ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
    for (let i = 0; i < list.length; i++) {
      const ord  = list[i];
      const resp = await apiFetch(`/etsyOrderProxy?orderId=${encodeURIComponent(ord)}`);

      /* DEBUG ‚¨áÔ∏é record every payload */
      console.log("%cFETCH ‚úì", "color:#00c853",
            "receipt:", ord,
            "status:", resp.status);

      if (!resp.ok) {
        console.warn("Order fetch failed for " + ord + ", status=" + resp.status);
        continue;
      }

      const data = await resp.json();

      console.log("%cCACHE", "color:#ff9100",
            "receipt:", ord,
            "TX ids:", (data.transactions||[]).map(t => t.transaction_id));

      console.log("Etsy Order Data:", data);

      /* -----------------------------------------------------------
       * attach buyer-message & keep Etsy's transaction.personalization
       * ----------------------------------------------------------- */
      if (Array.isArray(data.transactions)) {
        const buyerMsg    = data.receipt?.message_from_buyer || "";
        const receiptPers = data.receipt?.personalization    || "";

        data.transactions.forEach(t => {
          t.typedOrderNumber   = ord;
          t.message_from_buyer = buyerMsg;

          /* inherit receipt-level personalization if tx lacks its own */
          if (
              receiptPers &&
              (
                !t.personalization ||
                (Array.isArray(t.personalization) && !t.personalization.length)
              )
          ){
            t.personalization = receiptPers;
          }

          /* normalize + trim blanks */
          if (!Array.isArray(t.personalization)) {
            t.personalization = [ t.personalization ];
          }
          t.personalization = t.personalization.filter(txt => txt && txt.trim());

          if (t.personalization.length) {
            console.log("‚üπ Personalization TX", t.transaction_id, t.personalization);
          }
        });

        /* -------- expected_ship_date ‚Üí dispatch_date ------------ */
        if (data.transactions.length > 0) {
          const firstTrans = data.transactions[0];
          if (firstTrans.expected_ship_date) {
            const sTS   = new Date(firstTrans.expected_ship_date * 1000);
            const sDay  = ("0" + sTS.getDate()).slice(-2);
            const sMon  = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug",
                           "Sep","Oct","Nov","Dec"][sTS.getMonth()];
            const sYr   = sTS.getFullYear();
            const formatted = `${sDay} ${sMon} ${sYr}`;

            data.transactions.forEach(t => { t.dispatch_date = formatted; });
          }
        }

        combinedItems.push(...data.transactions);   // merge
      } else {
        console.warn("No transactions for order", ord);
      }

      /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
       * Build a left-rail row for this order (with metal tallies)
       * ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
      try {
        const txs     = data?.transactions || [];
        const receipt = data?.receipt || {};
        const rid     = String(receipt.receipt_id || ord);

        // Compute ship date from receipt/tx data
        let shipDate = "N/A";
        const tsRaw =
              receipt.expected_ship_date ??
              receipt.dispatch_date      ??
              receipt.ship_by_date       ??
              txs[0]?.expected_ship_date ??
              txs[0]?.dispatch_date      ??
              txs[0]?.ship_by_date       ?? 0;

        if (typeof tsRaw === "number" && tsRaw > 86400) {
          const d = new Date(tsRaw * 1000);
          shipDate = d.toLocaleDateString("en-US", { month: "short", day: "2-digit" });
        } else if (typeof tsRaw === "string" && tsRaw.trim()) {
          shipDate = tsRaw;
        }

        // Tally metals by quantity
        let g = 0, s = 0, rG = 0, k = 0;
        txs.forEach(tx => {
          let m = (tx._wrapEl && tx._wrapEl.dataset && tx._wrapEl.dataset.metal) || tx._metalKey || "";

          if (!m && Array.isArray(tx.variations)) {
            for (const v of tx.variations) {
              const name  = String(v?.formatted_name  || "");
              const value = String(v?.formatted_value || "");
              if (/metal|color|colour/i.test(name)) {
                m = value.toLowerCase();
                break;
              }
            }
          }

          // 14K override: if m is 'gold' but the variation text mentions 14k, force 14k
          if (/^gold$/i.test(m) && Array.isArray(tx.variations)) {
            const joined = tx.variations
              .map(v => String(v.formatted_value || "").toLowerCase())
              .join(" ");
            if (/\b14\s*k(?:t|arat)?\b/.test(joined)) m = "14k";
          }

          const q = tx.quantity || 1;
          if (/^14k$/.test(m) || /\b14\s*k(?:t|arat)?\b/i.test(m)) k += q;
          else if (/rose/i.test(m))                               rG += q;
          else if (/silv(?:er|r)/i.test(m))                       s  += q;
          else if (/gold/i.test(m))                               g  += q;
        });

        const rowMetal = k ? "14k" : (rG ? "rose" : (s ? "silver" : (g ? "gold" : "")));

        if (container) {
          const row = document.createElement("div");
          row.className = "new-order-box";
          row.dataset.receipt = rid;
          if (rowMetal) row.dataset.metal = rowMetal;

          row.innerHTML = `
            <span class="col-order">${receipt.order_number || ord}</span>
            <span class="col-ship">${shipDate}</span>
            <span class="col-g">${g}</span>
            <span class="col-s">${s}</span>
            <span class="col-r">${rG}</span>
            <span class="col-k">${k}</span>
          `;

          // Preserve selection/completed visuals if globals exist
          try {
            if (typeof completedOrders !== "undefined" && completedOrders.has(rid)) {
              row.classList.add("completed");
            }
            if (typeof selectedOrders !== "undefined" && selectedOrders.has(rid)) {
              row.classList.add("selected");
            }
          } catch (_e) {}

          frag.appendChild(row);
        }
      } catch (rowErr) {
        console.warn("Left-rail row build error for", ord, rowErr);
      }
    }  /* ‚Üê end for-loop */

    /* One paint for the left rail (fast) */
    if (container) container.appendChild(frag);

    /* ‚îÄ‚îÄ render combined results ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
    await fillPreviewBoxes(combinedItems);
    attachMatchCellListeners();         // keep listener wiring
    if (typeof updateCounters === "function")   updateCounters();   // refresh metal tallies
    if (typeof applyMetalFilter === "function") applyMetalFilter(); // apply any active filters

    M.toast({ html: "Bulk load complete" });

  } catch (err) {
    console.error("Error loading batch orders:", err);
    M.toast({ html: "Error: " + err.message });
  }
}

async function fetchListingImages(listingId) {
  const key = String(listingId);

  // 1) Serve from cache if we have it
  if (__imagesCache.has(key)) return __imagesCache.get(key);

  // 2) Share the same in-flight promise for duplicate callers
  if (__imagesFlight.has(key)) return __imagesFlight.get(key);

  // 3) Run inside the queue with built-in 429 tolerance via apiFetch
  const task = runImageTask(async () => {
    let attempt = 0;
    while (attempt < 4) {
      const resp = await apiFetch(`/etsyImages?listingId=${encodeURIComponent(key)}`);
      if (resp.status === 429) {
        // Extra defense: apiFetch already retried, keep spacing calls if still 429
        const retryAfter = resp.headers?.get?.("retry-after");
        const raMs = Number.isFinite(Number(retryAfter)) ? Number(retryAfter) * 1000 : 0;
        const backoff = Math.max(raMs, 500 * Math.pow(2, attempt)); // 350ms, 700ms, 1400ms...
        await new Promise(r => setTimeout(r, backoff));
        attempt++;
        continue;
      }
      if (!resp.ok) {
        console.warn("Image fetch HTTP error:", resp.status);
        return [];
      }
      const data = await resp.json();
      const imgs = Array.isArray(data)
      ? data
      : (data?.results || data?.images || data?.data || []);
      return imgs || [];
    }
    return [];
  });

  __imagesFlight.set(key, task);
  try {
    const results = await task;
    __imagesCache.set(key, results);
    return results;
  } finally {
    __imagesFlight.delete(key);
  }
}

// ---------------------------------------------------------
// Pull Etsy order details and update grid details
// ---------------------------------------------------------
function pullEtsyOrderDetails(orderNumber){
  console.log("Pulling Etsy order details for:", orderNumber);
  const token = localStorage.getItem("access_token") || "";

  return apiFetch(`/etsyOrderProxy?orderId=${encodeURIComponent(orderNumber)}`
    )

  .then(r => r.json())
  .then(data => {
    console.log("Etsy Order Data:", data);

    /* ‚îÄ‚îÄ attach buyer-message & guarantee personalization array ‚îÄ‚îÄ */
    const buyerMsg = data.receipt?.message_from_buyer || "";

    (data.transactions || []).forEach((t, idx) => {
      t.message_from_buyer = buyerMsg;

      /* NEW ‚Üí lift the ‚ÄúPersonalization‚Äù variation into its own field */
      const engrave = (t.variations||[])
                        .find(v=>/personalization/i.test(v.formatted_name||""))?.formatted_value || "";

      const clean = engrave.trim();
      if (clean && !/not requested/i.test(clean)) {
        t.personalization = [ clean ];
      } else {
        t.personalization = [];            // treat as ‚Äúno personalization‚Äù
      }

      console.log("PERSONALIZATION DEBUG:", t.transaction_id, t.personalization, typeof t.personalization);
      if (idx === 0) {                       // dump only the first transaction
        console.log("TX FIELDS:", Object.keys(t));
      }

      /* normalize personalization ---------------------------------- */
      if (t.personalization) {
        if (!Array.isArray(t.personalization)) {
          t.personalization = [ t.personalization ];
        }
      } else {
        t.personalization = [];
      }

      /* DEBUG: log any transaction that has personalization text */
      if (t.personalization.length) {
        console.log("‚üπ Personalization TX", t.transaction_id, t.personalization);
      }
    });

    return data;                       // hand the cleaned object upward
  })
  .catch(err => {
    console.error("Error fetching Etsy order details:", err);
    return null;
  });
}

// Example: update the grid details using pulled Etsy order details
async function updateImageGrid(data) {
  let items = [];
  if (data.transactions && Array.isArray(data.transactions)) {
    items = data.transactions;
  } else if (Array.isArray(data)) {          
    items = data;
  }
  window.cachedOrderItems = items;
  await fillPreviewBoxes(items);
}

/* ---- stubbed out empty functions ---- */
function disableSendMatch() {}
function disableMatchPrintFlow() {}
function removeAllBlueHighlights() {}
function attachMatchCellListeners() {}  


/* ‚îÄ‚îÄ‚îÄ grid reflow after filter ‚îÄ‚îÄ‚îÄ */
function reflowGrid(){
  const wraps = Array.from(document.querySelectorAll("#photoGridContainer .wrap-preview"))
                     .filter(w => w.style.display !== "none");

  wraps.forEach((wrap, idx) => {
    const row = Math.floor(idx / 12);      // 9 cols per row
    const col = idx % 12;
    wrap.style.left = (col * 125) + "px";
    wrap.style.top  = (row * 165) + "px";
  });

  /* optional: grow the container so you can scroll all rows */
  const grid = document.getElementById("photoGridContainer");
  const totalRows = Math.ceil(wraps.length / 9);
  grid.style.height = (totalRows * 165) + "px";
}

  /* ‚îÄ‚îÄ‚îÄ METAL FILTER INITIALISER ‚îÄ‚îÄ‚îÄ */
  document.addEventListener("DOMContentLoaded", () => {

    const completedBtn = document.getElementById("completedCounter");

    /* click-toggle for the FOUR metal buttons (skip Completed) */
    document
      .querySelectorAll('.metal-counter:not([data-metal="completed"])')
      .forEach(btn => {
        btn.addEventListener("click", () => {
          btn.classList.toggle("active");          // blue outline
          completedBtn.classList.remove("active"); // Completed must turn off
          applyMetalFilter();
        });
      });

    /* exclusivity toggle for Completed */
    completedBtn.addEventListener("click", async () => {
      const isNowActive = completedBtn.classList.toggle("active");

      /* flip the four metal buttons */
      document
        .querySelectorAll(
          '.metal-counter[data-metal]:not([data-metal="completed"])'
        )
        .forEach(btn => btn.classList.toggle("active", !isNowActive));

       if (isNowActive) {
         await ensureCompletedPreviews();     // when turning Completed ON
       } else {
         await ensureOrangeIntegrity();      // brings orange back cleanly
       }

      applyMetalFilter();                 // refresh grid
    });

    /* -------------------------------------------------------------
     * ensureCompletedPreviews ‚Äì make sure every completed receipt
     *                           has at least one wrap in the grid
     * -------------------------------------------------------------*/
    function ensureCompletedPreviews(){
      const needReceipts = [];

      /* reveal existing wraps + collect truly-missing ones */
      completedOrders.forEach(id => {
        const wrap = document.querySelector(`.wrap-preview[data-receipt='${id}']`);
        if (wrap){
          wrap.style.display = "";
        }else{
          needReceipts.push(id);
        }
      });

      /* fetch only the missing ones */
      if (needReceipts.length){
        loadBatchEtsyOrders(needReceipts)
          .then(()=>{ reflowGrid(); window.updateCounters?.(); })
          .catch(err => console.error("Completed sync error:", err));
      }else{
        reflowGrid();
        window.updateCounters?.();
      }
    }

    /* -------------------------------------------------------------
     * ensureSelectedPreviews ‚Äì make sure every orange (selected)
     *   receipt that is NOT completed has a preview in the grid
     * -------------------------------------------------------------*/
    async function ensureSelectedPreviews() {
      const need = [];
      selectedOrders.forEach(rid => {
        if (completedOrders.has(rid)) return;                // skip greens
        const found = document.querySelector(
          `.wrap-preview[data-receipt="${rid}"]`
        );
        if (!found) need.push(rid);
      });
      if (need.length) {
        console.log("Loading previews for selected orders:", need);
        await loadBatchEtsyOrders(need);
      }
    }

    /* =================================================================
     * ensureOrangeIntegrity
     * ‚îÄ Re-syncs the orange (selected) state across rows, previews,
     *   Sets, maps, and duplicate guards.
     *   - creates any missing preview wraps
     *   - restores .selected class on rows & wraps
     *   - guarantees only one wrap per transaction
     * =================================================================*/
    async function ensureOrangeIntegrity() {
      const needReceipts = [];

      selectedOrders.forEach(rid => {
        /* A. make sure row carries the orange class */
        const row = document.querySelector(
          `.new-order-box[data-receipt='${rid}']`);
        if (row) row.classList.add("selected");

        /* B. make sure at least one preview exists */
        const anyWrap = document.querySelector(
          `#photoGridContainer .wrap-preview[data-receipt='${rid}']`);
        if (!anyWrap) needReceipts.push(rid);
      });

      /* C. load missing previews (if any) */
      if (needReceipts.length) {
        await loadBatchEtsyOrders(needReceipts);     // uses addPreviewBox
          reflowGrid();            // üÜï pack the grid tightly
          window.updateCounters?.(); // üÜï keep the badges honest (safe)
      }

      /* D. mark every visible wrap for a selected receipt */
      selectedOrders.forEach(rid => {
        document.querySelectorAll(
          `#photoGridContainer .wrap-preview[data-receipt='${rid}']`
        ).forEach(w => w.classList.add("selected"));
      });
    }

    /* filter helper --------------------------------------------------- */
    function applyMetalFilter() {

      const completedOn = completedBtn.classList.contains("active");

      /* 0Ô∏è‚É£  Handle left-column order rows ---------------------------- */
      document.querySelectorAll(".new-order-box").forEach(row => {
        const isGreen = row.classList.contains("completed");
        const hideGreens = !searchActive && !completedOn;
        row.style.display = hideGreens && isGreen ? "none" : "";
      });

      /* 1Ô∏è‚É£  Completed ON ‚Üí show only green previews ------------------ */
      if (completedOn) {
        gridElements.forEach(wrap => {
          wrap.style.display =
            completedOrders.has(wrap.dataset.receipt) ? "" : "none";
        });
        reflowGrid();
        window.updateCounters?.();  // counters stay metal-only
        return;
      }

      /* 2Ô∏è‚É£  Completed OFF ‚Üí normal metal filtering ------------------- */
      const activeMetals = new Set(
        Array.from(document.querySelectorAll(".metal-counter.active"))
             .map(btn => btn.dataset.metal)
      );

      gridElements.forEach(wrap => {
      const hideGreens = !searchActive && !completedOn;
      const show =
        ( !wrap.dataset.metal || activeMetals.has(wrap.dataset.metal) ) &&
        !(hideGreens && completedOrders.has(wrap.dataset.receipt));
              wrap.style.display = show ? "" : "none";

        /* ‚òÖ PROBE-B: is this wrap ghost-completed? */
            console.log("%cCOMPLETED?","color:#ff9100;font-weight:bold",
            wrap.dataset.receipt, completedOrders.has(wrap.dataset.receipt));

      });

      /* ‚îÄ‚îÄ restore 3-px orangered outline and orange rows ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
      selectedOrders.forEach(rid => {
        /* preview boxes */
        document.querySelectorAll(
          `#photoGridContainer .wrap-preview[data-receipt='${rid}']`
        ).forEach(wrap => wrap.classList.add("selected"));

        /* left-column rows */
        const row = document.querySelector(
          `.new-order-box[data-receipt='${rid}']`
        );
        if (row) row.classList.add("selected");
      });

      reflowGrid();
      window.updateCounters?.();    // keep top counters in sync

       /* one more pass in the next frame ‚Äî guarantees nothing strips the outline */
       requestAnimationFrame(() => {
         selectedOrders.forEach(rid => {
           document.querySelectorAll(
             `#photoGridContainer .wrap-preview[data-receipt='${rid}']`
           ).forEach(w => w.classList.add("selected"));
         });
       });

    }   /* ‚Üê end applyMetalFilter */

    /* make it callable from addPreviewBox and other helpers */
    window.applyMetalFilter = applyMetalFilter;

    /* first run honours the initial .active states */
    applyMetalFilter();

    });  /* ‚îÄ‚îÄ‚îÄ END METAL FILTER INITIALISER ‚îÄ‚îÄ‚îÄ */

      // Mirror shipping-1 helper used when reading variations
      if (typeof window.deQuote !== "function") {
        window.deQuote = function(s){
          return (s == null ? "" : String(s)).replace(/&quot;/g, '"');
        };
      }

    async function openListingModal(cellIdx){
      const item = window.cachedOrderItems[cellIdx];
      if(!item){ return; }

      /* 1. title & image */
      document.getElementById("modalListingTitle").textContent =
      "Order #" + (item.receipt_id || item.orderNumber || "N/A");

      document.getElementById("modalListingImg").src = item.image;

      /* ‚ñº SKU row: set loading state, fetch, then enable Copy */
      const skuTextEl  = document.getElementById("modalSkuText");
      const skuCopyBtn = document.getElementById("modalSkuCopyBtn");

      if (skuTextEl) skuTextEl.textContent = "SKU: loading‚Ä¶";
      if (skuCopyBtn) skuCopyBtn.onclick = null;

      try{
        const fetched = await fetchItemSKU(item);
        const finalSku = fetched || item.sku || "N/A";
        if (skuTextEl) skuTextEl.textContent = "SKU: " + finalSku;
        if (skuCopyBtn){
          skuCopyBtn.onclick = async () => {
            try{
              await navigator.clipboard.writeText(finalSku);
              M.toast({ html: "SKU copied" });
            }catch(err){
              // Fallback for older browsers
              const tmp = document.createElement("textarea");
              tmp.value = finalSku;
              document.body.appendChild(tmp);
              tmp.select();
              document.execCommand("copy");
              document.body.removeChild(tmp);
              M.toast({ html: "SKU copied" });
            }
          };
        }
      }catch(_){
        if (skuTextEl) skuTextEl.textContent = "SKU: N/A";
      }

      /* 2. notes ‚Äî mirror shipping-1 Personalization logic */
      const lines = [];

      // 2.1 Extract Personalization from item.variations (same approach as shipping-1)
      let persText = "";
      if (Array.isArray(item.variations)) {
        const pv = item.variations.find(v => /personalization/i.test(v?.formatted_name || ""));
        if (pv && pv.formatted_value) {
          let val = (typeof window.deQuote === "function"
                      ? window.deQuote(pv.formatted_value)
                      : String(pv.formatted_value));
          val = val.trim();
          // Map Etsy default ‚Üí our wording, just like shipping-1
          if (/^Not requested on this item\.$/i.test(val)) val = "Not Requested";
          if (val) persText = val;
        }
      }

      // 2.2 Fallback to any existing normalized array (keeps prior behavior if present)
      if (!persText && Array.isArray(item.personalization) && item.personalization.length) {
        persText = item.personalization.join("\n");
      }

      if (persText) {
        lines.push("Personalization:\n" + persText);
      }

      // 2.3 Buyer message stays as-is
      if (item.message_from_buyer) {
        lines.push("Buyer Message:\n" + item.message_from_buyer.trim());
      }

      document.getElementById("modalListingNotes").value =
        (lines.length ? lines.join("\n\n") : "‚Äî No notes ‚Äî");

      /* ----- build the 4 read-only fields ----- */
      const detRow = document.getElementById("modalListingDetails");
      detRow.innerHTML = "";                            // reset

      const mkInput = (lbl,val) => {
        const inp = document.createElement("input");
        inp.type = "text";
        inp.readOnly = true;
        inp.value = `${lbl}: ${val}`;
        detRow.appendChild(inp);
      };

      /* ensure we have otherLabel even if makePreviewNode missed it */
      if (!item.otherLabel && Array.isArray(item.variations)) {
        const v = item.variations.find(x =>
          !/(metal|colour|color)/i.test(x.formatted_name || "") &&
          !/personalization/i.test(x.formatted_name || "")
        );
        item.otherLabel = v ? v.formatted_value : "N/A";
      }

      mkInput("Qty"  , item.quantity   ?? "0");
      mkInput("Metal", item.metalLabel || "N/A");
      mkInput("SKU"  , item.sku        || "N/A");
      mkInput("Other", item.otherLabel || "N/A");   // NEW line

      /* ‚ñº‚ñº  STAFF NOTE sync  (deduped) ‚ñº‚ñº */
      const staffInp = document.getElementById("modalStaffNote");
      const orderId  = String(item.receipt_id || item.orderNumber);

      staffInp.value = "";   // reset before fetch

      fetch(`${functionsBaseUrl}/firebaseOrders?orderId=${encodeURIComponent(orderId)}`)
        .then(r => r.json())
        .then(res => {
          if (res.success && res.data && res.data["Staff Note"]) {
            staffInp.value = res.data["Staff Note"];
          }
        })
        .catch(console.error);

      /* overwrite any previous handlers */
        staffInp.onchange = staffInp.onblur = async () => {
        const note = staffInp.value.trim();

        /* write to Firestore */
        fetch(`${functionsBaseUrl}/firebaseOrders`,{
          method : "POST",
          headers: { "Content-Type":"application/json" },
          body   : JSON.stringify({ orderNumber: orderId, staffNote: note })
        }).catch(console.error);

        /* instant UI feedback */
        if(note){
          staffNoteIDs.add(orderId);
        }else{
          staffNoteIDs.delete(orderId);
        }
        markStaffNoteOrders();
      };
      /* ‚ñ≤‚ñ≤  end STAFF NOTE sync ‚ñ≤‚ñ≤ */

      /* sync checkbox with this order */
      modalCompleteChk.checked   = completedOrders.has(orderId);
      modalCompleteChk.dataset.rid = orderId;    // pass receipt ID

      listingModal.open();
    }

    /* pack remaining previews after removals ------------------------ */
    function realignGrid(){
      const wraps = Array.from(document.querySelectorAll("#photoGridContainer .wrap-preview"));
      wraps.forEach((w, idx) => {
        const row = Math.floor(idx / 12);
        const col = idx % 12;
        w.style.left = (col * 125) + "px";
        w.style.top  = (row * 165) + "px";
      });
    }  

  </script>

<!-- ‚îÄ‚îÄ‚îÄ Listing-detail modal ‚îÄ‚îÄ‚îÄ -->
<div id="listingModal" class="modal">
  <div class="modal-content">
    <!-- ‚ñº‚ñº NEW COMPLETE-CHECKBOX + TITLE ‚ñº‚ñº -->
    <span class="modal-skip-title">Skip Order</span>
    <label class="modal-complete-label">
      <input id="modalCompleteChk" type="checkbox" class="filled-in" />
      <span></span>
    </label>
    <!-- ‚ñ≤‚ñ≤ NEW COMPLETE-CHECKBOX + TITLE ‚ñ≤‚ñ≤ -->

    <h5 id="modalListingTitle"></h5>
    <div id="modalSkuRow" class="modal-sku-row" style="display:flex;align-items:center;gap:10px;margin:6px 0 12px;">
      <span id="modalSkuText" class="sku-text" style="font-weight:300;">SKU: ‚Äî</span>
      <a id="modalSkuCopyBtn" href="#!" class="btn-small">Copy</a>
    </div>

    <div class="modal-flex-row">
      <img id="modalListingImg" />

      <!-- notes + staff input stacked -->
      <div class="modal-notes-col">
        <textarea id="modalListingNotes" readonly></textarea>

        <textarea id="modalStaffNote" placeholder="Staff Note"></textarea>

      </div>
    </div>

    <div id="modalListingDetails" class="modal-detail-row"></div>
  </div><!-- /modal-content -->

  <div class="modal-footer">
    <a href="#!" class="modal-close btn-flat">Close</a>
  </div>
</div><!-- /listingModal -->

 <!-- ‚îÄ‚îÄ‚îÄ QR Preview Modal ‚îÄ‚îÄ‚îÄ -->
 <div id="qrPreviewModal" class="modal">
   <div class="modal-content">
     <h5>QR Preview</h5>
       <!-- Skipped orders appear here (always visible) -->
       <div id="qrSkippedContainer"
            style="margin:10px 0;font-size:.9em;color:#d32f2f;"></div>
 
       <div id="qrPreviewGrid" style="display:flex;flex-wrap:wrap;gap:20px;"></div>

   </div>
   <div class="modal-footer">
     <a href="#!" id="qrPreviewPrintBtn" class="modal-close btn green">Print&nbsp;Labels</a>
     <a href="#!" class="modal-close btn-flat">Cancel</a>
   </div>
 </div>

</body>
</html>